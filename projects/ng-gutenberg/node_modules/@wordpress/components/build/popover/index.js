"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classnames = _interopRequireDefault(require("classnames"));

var _dom = require("@wordpress/dom");

var _keycodes = require("@wordpress/keycodes");

var _isShallowEqual = _interopRequireDefault(require("@wordpress/is-shallow-equal"));

var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));

var _utils = require("./utils");

var _withFocusReturn = _interopRequireDefault(require("../higher-order/with-focus-return"));

var _withConstrainedTabbing = _interopRequireDefault(require("../higher-order/with-constrained-tabbing"));

var _detectOutside = _interopRequireDefault(require("./detect-outside"));

var _iconButton = _interopRequireDefault(require("../icon-button"));

var _scrollLock = _interopRequireDefault(require("../scroll-lock"));

var _isolatedEventContainer = _interopRequireDefault(require("../isolated-event-container"));

var _slotFill = require("../slot-fill");

var _animate = _interopRequireDefault(require("../animate"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
var FocusManaged = (0, _withConstrainedTabbing.default)((0, _withFocusReturn.default)(function (_ref) {
  var children = _ref.children;
  return children;
}));
/**
 * Name of slot in which popover should fill.
 *
 * @type {string}
 */

var SLOT_NAME = 'Popover';
/**
 * Hook used trigger an event handler once the window is resized or scrolled.
 *
 * @param {Function} handler              Event handler.
 * @param {Object}   ignoredScrollableRef scroll events inside this element are ignored.
 */

function useThrottledWindowScrollOrResize(handler, ignoredScrollableRef) {
  // Refresh anchor rect on resize
  (0, _element.useEffect)(function () {
    var refreshHandle;

    var throttledRefresh = function throttledRefresh(event) {
      window.cancelAnimationFrame(refreshHandle);

      if (ignoredScrollableRef && event && event.type === 'scroll' && ignoredScrollableRef.current.contains(event.target)) {
        return;
      }

      refreshHandle = window.requestAnimationFrame(handler);
    };

    window.addEventListener('resize', throttledRefresh);
    window.addEventListener('scroll', throttledRefresh, true);
    return function () {
      window.removeEventListener('resize', throttledRefresh);
      window.removeEventListener('scroll', throttledRefresh, true);
    };
  }, []);
}
/**
 * Hook used to compute and update the anchor position properly.
 *
 * @param {Object} anchorRef       reference to the popover anchor element.
 * @param {Object} contentRef      reference to the popover content element.
 * @param {Object} anchorRect      anchor Rect prop used to override the computed value.
 * @param {Function} getAnchorRect function used to override the anchor value computation algorithm.
 *
 * @return {Object} Anchor position.
 */


function useAnchor(anchorRef, contentRef, anchorRect, getAnchorRect) {
  var _useState = (0, _element.useState)(null),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      anchor = _useState2[0],
      setAnchor = _useState2[1];

  var refreshAnchorRect = function refreshAnchorRect() {
    if (!anchorRef.current) {
      return;
    }

    var newAnchor;

    if (anchorRect) {
      newAnchor = anchorRect;
    } else if (getAnchorRect) {
      newAnchor = getAnchorRect(anchorRef.current);
    } else {
      var rect = anchorRef.current.parentNode.getBoundingClientRect(); // subtract padding

      var _window$getComputedSt = window.getComputedStyle(anchorRef.current.parentNode),
          paddingTop = _window$getComputedSt.paddingTop,
          paddingBottom = _window$getComputedSt.paddingBottom;

      var topPad = parseInt(paddingTop, 10);
      var bottomPad = parseInt(paddingBottom, 10);
      newAnchor = {
        x: rect.left,
        y: rect.top + topPad,
        width: rect.width,
        height: rect.height - topPad - bottomPad,
        left: rect.left,
        right: rect.right,
        top: rect.top + topPad,
        bottom: rect.bottom - bottomPad
      };
    }

    var didAnchorRectChange = !(0, _isShallowEqual.default)(newAnchor, anchor);

    if (didAnchorRectChange) {
      setAnchor(newAnchor);
    }
  };

  (0, _element.useEffect)(refreshAnchorRect, [anchorRect, getAnchorRect]);
  (0, _element.useEffect)(function () {
    if (!anchorRect) {
      /*
      * There are sometimes we need to reposition or resize the popover that are not
      * handled by the resize/scroll window events (i.e. CSS changes in the layout
      * that changes the position of the anchor).
      *
      * For these situations, we refresh the popover every 0.5s
      */
      var intervalHandle = setInterval(refreshAnchorRect, 500);
      return function () {
        return clearInterval(intervalHandle);
      };
    }
  }, [anchorRect]);
  useThrottledWindowScrollOrResize(refreshAnchorRect, contentRef);
  return anchor;
}
/**
 * Hook used to compute the initial size of an element.
 * The popover applies styling to limit the height of the element,
 * we only care about the initial size.
 *
 * @param {Object} ref Reference to the popover content element.
 *
 * @return {Object} Content size.
 */


function useInitialContentSize(ref) {
  var _useState3 = (0, _element.useState)(null),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      contentSize = _useState4[0],
      setContentSize = _useState4[1];

  (0, _element.useEffect)(function () {
    var contentRect = ref.current.getBoundingClientRect();
    setContentSize({
      width: contentRect.width,
      height: contentRect.height
    });
  }, []);
  return contentSize;
}
/**
 * Hook used to compute and update the position of the popover
 * based on the anchor position and the content size.
 *
 * @param {Object} anchor          Anchor Position.
 * @param {Object} contentSize     Content Size.
 * @param {string} position        Position prop.
 * @param {boolean} expandOnMobile Whether to show the popover full width on mobile.
 * @param {Object} contentRef      Reference to the popover content element.
 *
 * @return {Object} Popover position.
 */


function usePopoverPosition(anchor, contentSize, position, expandOnMobile, contentRef) {
  var _useState5 = (0, _element.useState)({
    popoverLeft: null,
    popoverTop: null,
    yAxis: 'top',
    xAxis: 'center',
    contentHeight: null,
    contentWidth: null,
    isMobile: false
  }),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      popoverPosition = _useState6[0],
      setPopoverPosition = _useState6[1];

  var refreshPopoverPosition = function refreshPopoverPosition() {
    if (!anchor || !contentSize) {
      return;
    }

    var newPopoverPosition = (0, _utils.computePopoverPosition)(anchor, contentSize, position, expandOnMobile);

    if (popoverPosition.yAxis !== newPopoverPosition.yAxis || popoverPosition.xAxis !== newPopoverPosition.xAxis || popoverPosition.popoverLeft !== newPopoverPosition.popoverLeft || popoverPosition.popoverTop !== newPopoverPosition.popoverTop || popoverPosition.contentHeight !== newPopoverPosition.contentHeight || popoverPosition.contentWidth !== newPopoverPosition.contentWidth || popoverPosition.isMobile !== newPopoverPosition.isMobile) {
      setPopoverPosition(newPopoverPosition);
    }
  };

  (0, _element.useEffect)(refreshPopoverPosition, [anchor, contentSize]);
  useThrottledWindowScrollOrResize(refreshPopoverPosition, contentRef);
  return popoverPosition;
}
/**
 * Hook used to focus the first tabbable element on mount.
 *
 * @param {boolean|string} focusOnMount Focus on mount mode.
 * @param {Object} contentRef           Reference to the popover content element.
 */


function useFocusContentOnMount(focusOnMount, contentRef) {
  // Focus handling
  (0, _element.useEffect)(function () {
    /*
     * Without the setTimeout, the dom node is not being focused. Related:
     * https://stackoverflow.com/questions/35522220/react-ref-with-focus-doesnt-work-without-settimeout-my-example
     *
     * TODO: Treat the cause, not the symptom.
     */
    var focusTimeout = setTimeout(function () {
      if (!focusOnMount || !contentRef.current) {
        return;
      }

      if (focusOnMount === 'firstElement') {
        // Find first tabbable node within content and shift focus, falling
        // back to the popover panel itself.
        var firstTabbable = _dom.focus.tabbable.find(contentRef.current)[0];

        if (firstTabbable) {
          firstTabbable.focus();
        } else {
          contentRef.current.focus();
        }

        return;
      }

      if (focusOnMount === 'container') {
        // Focus the popover panel itself so items in the popover are easily
        // accessed via keyboard navigation.
        contentRef.current.focus();
      }
    }, 0);
    return function () {
      return clearTimeout(focusTimeout);
    };
  }, []);
}

var Popover = function Popover(_ref2) {
  var headerTitle = _ref2.headerTitle,
      onClose = _ref2.onClose,
      onKeyDown = _ref2.onKeyDown,
      children = _ref2.children,
      className = _ref2.className,
      _ref2$noArrow = _ref2.noArrow,
      noArrow = _ref2$noArrow === void 0 ? false : _ref2$noArrow,
      _ref2$position = _ref2.position,
      position = _ref2$position === void 0 ? 'top' : _ref2$position,
      range = _ref2.range,
      _ref2$focusOnMount = _ref2.focusOnMount,
      focusOnMount = _ref2$focusOnMount === void 0 ? 'firstElement' : _ref2$focusOnMount,
      anchorRect = _ref2.anchorRect,
      getAnchorRect = _ref2.getAnchorRect,
      expandOnMobile = _ref2.expandOnMobile,
      _ref2$animate = _ref2.animate,
      animate = _ref2$animate === void 0 ? true : _ref2$animate,
      onClickOutside = _ref2.onClickOutside,
      onFocusOutside = _ref2.onFocusOutside,
      contentProps = (0, _objectWithoutProperties2.default)(_ref2, ["headerTitle", "onClose", "onKeyDown", "children", "className", "noArrow", "position", "range", "focusOnMount", "anchorRect", "getAnchorRect", "expandOnMobile", "animate", "onClickOutside", "onFocusOutside"]);
  var anchorRef = (0, _element.useRef)(null);
  var contentRef = (0, _element.useRef)(null); // Animation

  var _useState7 = (0, _element.useState)(false),
      _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
      isReadyToAnimate = _useState8[0],
      setIsReadyToAnimate = _useState8[1]; // Anchor position


  var anchor = useAnchor(anchorRef, contentRef, anchorRect, getAnchorRect); // Content size

  var contentSize = useInitialContentSize(contentRef);
  (0, _element.useEffect)(function () {
    if (contentSize) {
      setIsReadyToAnimate(true);
    }
  }, [contentSize]); // Compute the position

  var popoverPosition = usePopoverPosition(anchor, contentSize, position, expandOnMobile, contentRef);
  useFocusContentOnMount(focusOnMount, contentRef); // Event handlers

  var maybeClose = function maybeClose(event) {
    // Close on escape
    if (event.keyCode === _keycodes.ESCAPE && onClose) {
      event.stopPropagation();
      onClose();
    } // Preserve original content prop behavior


    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  /**
   * Shims an onFocusOutside callback to be compatible with a deprecated
   * onClickOutside prop function, if provided.
   *
   * @param {FocusEvent} event Focus event from onFocusOutside.
   */


  function handleOnFocusOutside(event) {
    // Defer to given `onFocusOutside` if specified. Call `onClose` only if
    // both `onFocusOutside` and `onClickOutside` are unspecified. Doing so
    // assures backwards-compatibility for prior `onClickOutside` default.
    if (onFocusOutside) {
      onFocusOutside(event);
      return;
    } else if (!onClickOutside) {
      if (onClose) {
        onClose();
      }

      return;
    } // Simulate MouseEvent using FocusEvent#relatedTarget as emulated click
    // target. MouseEvent constructor is unsupported in Internet Explorer.


    var clickEvent;

    try {
      clickEvent = new window.MouseEvent('click');
    } catch (error) {
      clickEvent = document.createEvent('MouseEvent');
      clickEvent.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
    }

    Object.defineProperty(clickEvent, 'target', {
      get: function get() {
        return event.relatedTarget;
      }
    });
    (0, _deprecated.default)('Popover onClickOutside prop', {
      alternative: 'onFocusOutside'
    });
    onClickOutside(clickEvent);
  } // Compute the animation position


  var yAxisMapping = {
    top: 'bottom',
    bottom: 'top'
  };
  var xAxisMapping = {
    left: 'right',
    right: 'left'
  };
  var animateYAxis = yAxisMapping[popoverPosition.yAxis] || 'middle';
  var animateXAxis = xAxisMapping[popoverPosition.xAxis] || 'center';
  var classes = (0, _classnames.default)('components-popover', className, 'is-' + popoverPosition.yAxis, 'is-' + popoverPosition.xAxis, {
    'is-mobile': popoverPosition.isMobile,
    'is-without-arrow': noArrow || popoverPosition.xAxis === 'center' && popoverPosition.yAxis === 'middle'
  }); // Disable reason: We care to capture the _bubbled_ events from inputs
  // within popover as inferring close intent.

  var content = (0, _element.createElement)(_detectOutside.default, {
    onFocusOutside: handleOnFocusOutside
  }, (0, _element.createElement)(_animate.default, {
    type: animate && isReadyToAnimate ? 'appear' : null,
    options: {
      origin: animateYAxis + ' ' + animateXAxis
    }
  }, function (_ref3) {
    var animateClassName = _ref3.className;
    return (0, _element.createElement)(_isolatedEventContainer.default, (0, _extends2.default)({
      className: (0, _classnames.default)(classes, animateClassName),
      style: {
        top: !popoverPosition.isMobile && popoverPosition.popoverTop ? popoverPosition.popoverTop + 'px' : undefined,
        left: !popoverPosition.isMobile && popoverPosition.popoverLeft ? popoverPosition.popoverLeft + 'px' : undefined,
        visibility: contentSize ? undefined : 'hidden'
      }
    }, contentProps, {
      onKeyDown: maybeClose
    }), popoverPosition.isMobile && (0, _element.createElement)("div", {
      className: "components-popover__header"
    }, (0, _element.createElement)("span", {
      className: "components-popover__header-title"
    }, headerTitle), (0, _element.createElement)(_iconButton.default, {
      className: "components-popover__close",
      icon: "no-alt",
      onClick: onClose
    })), (0, _element.createElement)("div", {
      ref: contentRef,
      className: "components-popover__content",
      style: {
        maxHeight: !popoverPosition.isMobile && popoverPosition.contentHeight ? popoverPosition.contentHeight + 'px' : undefined,
        maxWidth: !popoverPosition.isMobile && popoverPosition.contentWidth ? popoverPosition.contentWidth + 'px' : undefined
      },
      tabIndex: "-1"
    }, children));
  })); // Apply focus to element as long as focusOnMount is truthy; false is
  // the only "disabled" value.

  if (focusOnMount) {
    content = (0, _element.createElement)(FocusManaged, null, content);
  }

  return (0, _element.createElement)(_slotFill.Consumer, null, function (_ref4) {
    var getSlot = _ref4.getSlot;

    // In case there is no slot context in which to render,
    // default to an in-place rendering.
    if (getSlot && getSlot(SLOT_NAME)) {
      content = (0, _element.createElement)(_slotFill.Fill, {
        name: SLOT_NAME
      }, content);
    }

    return (0, _element.createElement)("span", {
      ref: anchorRef
    }, content, popoverPosition.isMobile && expandOnMobile && (0, _element.createElement)(_scrollLock.default, null));
  });
};

var PopoverContainer = Popover;

PopoverContainer.Slot = function () {
  return (0, _element.createElement)(_slotFill.Slot, {
    bubblesVirtually: true,
    name: SLOT_NAME
  });
};

var _default = PopoverContainer;
exports.default = _default;
//# sourceMappingURL=index.js.map