import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import React from 'react';
import { View, ImageBackground, Text, TouchableWithoutFeedback, Dimensions } from 'react-native';
import { requestMediaImport, mediaUploadSync, requestImageFailedRetryDialog, requestImageUploadCancelDialog } from 'react-native-gutenberg-bridge';
import { isEmpty } from 'lodash';
/**
 * WordPress dependencies
 */

import { BottomSheet, Icon, Toolbar, ToolbarButton } from '@wordpress/components';
import { Caption, MediaPlaceholder, MediaUpload, MEDIA_TYPE_IMAGE, BlockControls, InspectorControls } from '@wordpress/block-editor';
import { __, sprintf } from '@wordpress/i18n';
import { isURL } from '@wordpress/url';
import { doAction, hasAction } from '@wordpress/hooks';
/**
 * Internal dependencies
 */

import styles from './styles.scss';
import MediaUploadProgress from './media-upload-progress';
import SvgIcon from './icon';
import SvgIconRetry from './icon-retry';
var LINK_DESTINATION_CUSTOM = 'custom';
var LINK_DESTINATION_NONE = 'none'; // Default Image ratio 4:3

var IMAGE_ASPECT_RATIO = 4 / 3;

var ImageEdit =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ImageEdit, _React$Component);

  function ImageEdit(props) {
    var _this;

    _classCallCheck(this, ImageEdit);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ImageEdit).call(this, props));
    _this.state = {
      showSettings: false,
      isCaptionSelected: false
    };
    _this.finishMediaUploadWithSuccess = _this.finishMediaUploadWithSuccess.bind(_assertThisInitialized(_this));
    _this.finishMediaUploadWithFailure = _this.finishMediaUploadWithFailure.bind(_assertThisInitialized(_this));
    _this.mediaUploadStateReset = _this.mediaUploadStateReset.bind(_assertThisInitialized(_this));
    _this.onSelectMediaUploadOption = _this.onSelectMediaUploadOption.bind(_assertThisInitialized(_this));
    _this.updateMediaProgress = _this.updateMediaProgress.bind(_assertThisInitialized(_this));
    _this.updateAlt = _this.updateAlt.bind(_assertThisInitialized(_this));
    _this.updateImageURL = _this.updateImageURL.bind(_assertThisInitialized(_this));
    _this.onSetLinkDestination = _this.onSetLinkDestination.bind(_assertThisInitialized(_this));
    _this.onImagePressed = _this.onImagePressed.bind(_assertThisInitialized(_this));
    _this.onClearSettings = _this.onClearSettings.bind(_assertThisInitialized(_this));
    _this.onFocusCaption = _this.onFocusCaption.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(ImageEdit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props,
          attributes = _this$props.attributes,
          setAttributes = _this$props.setAttributes; // This will warn when we have `id` defined, while `url` is undefined.
      // This may help track this issue: https://github.com/wordpress-mobile/WordPress-Android/issues/9768
      // where a cancelled image upload was resulting in a subsequent crash.

      if (attributes.id && !attributes.url) {
        // eslint-disable-next-line no-console
        console.warn('Attributes has id with no url.');
      }

      if (attributes.id && attributes.url && !isURL(attributes.url)) {
        if (attributes.url.indexOf('file:') === 0) {
          requestMediaImport(attributes.url, function (mediaId, mediaUri) {
            if (mediaUri) {
              setAttributes({
                url: mediaUri,
                id: mediaId
              });
            }
          });
        }

        mediaUploadSync();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // this action will only exist if the user pressed the trash button on the block holder
      if (hasAction('blocks.onRemoveBlockCheckUpload') && this.state.isUploadInProgress) {
        doAction('blocks.onRemoveBlockCheckUpload', this.props.attributes.id);
      }
    }
  }, {
    key: "onImagePressed",
    value: function onImagePressed() {
      var attributes = this.props.attributes;

      if (this.state.isUploadInProgress) {
        requestImageUploadCancelDialog(attributes.id);
      } else if (attributes.id && !isURL(attributes.url)) {
        requestImageFailedRetryDialog(attributes.id);
      }

      this.setState({
        isCaptionSelected: false
      });
    }
  }, {
    key: "updateMediaProgress",
    value: function updateMediaProgress(payload) {
      var setAttributes = this.props.setAttributes;

      if (payload.mediaUrl) {
        setAttributes({
          url: payload.mediaUrl
        });
      }

      if (!this.state.isUploadInProgress) {
        this.setState({
          isUploadInProgress: true
        });
      }
    }
  }, {
    key: "finishMediaUploadWithSuccess",
    value: function finishMediaUploadWithSuccess(payload) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        url: payload.mediaUrl,
        id: payload.mediaServerId
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "finishMediaUploadWithFailure",
    value: function finishMediaUploadWithFailure(payload) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        id: payload.mediaId
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "mediaUploadStateReset",
    value: function mediaUploadStateReset() {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        id: null,
        url: null
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "updateAlt",
    value: function updateAlt(newAlt) {
      this.props.setAttributes({
        alt: newAlt
      });
    }
  }, {
    key: "updateImageURL",
    value: function updateImageURL(url) {
      this.props.setAttributes({
        url: url,
        width: undefined,
        height: undefined
      });
    }
  }, {
    key: "onSetLinkDestination",
    value: function onSetLinkDestination(href) {
      this.props.setAttributes({
        linkDestination: LINK_DESTINATION_CUSTOM,
        href: href
      });
    }
  }, {
    key: "onClearSettings",
    value: function onClearSettings() {
      this.props.setAttributes({
        alt: '',
        linkDestination: LINK_DESTINATION_NONE,
        href: undefined
      });
    }
  }, {
    key: "onSelectMediaUploadOption",
    value: function onSelectMediaUploadOption(mediaId, mediaUrl) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        url: mediaUrl,
        id: mediaId
      });
    }
  }, {
    key: "onFocusCaption",
    value: function onFocusCaption() {
      if (this.props.onFocus) {
        this.props.onFocus();
      }

      if (!this.state.isCaptionSelected) {
        this.setState({
          isCaptionSelected: true
        });
      }
    }
  }, {
    key: "getIcon",
    value: function getIcon(isRetryIcon) {
      if (isRetryIcon) {
        return createElement(Icon, _extends({
          icon: SvgIconRetry
        }, styles.iconRetry));
      }

      return createElement(Icon, _extends({
        icon: SvgIcon
      }, styles.icon));
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          attributes = _this$props2.attributes,
          isSelected = _this$props2.isSelected;
      var url = attributes.url,
          height = attributes.height,
          width = attributes.width,
          alt = attributes.alt,
          href = attributes.href,
          id = attributes.id;

      var onImageSettingsButtonPressed = function onImageSettingsButtonPressed() {
        _this2.setState({
          showSettings: true
        });
      };

      var onImageSettingsClose = function onImageSettingsClose() {
        _this2.setState({
          showSettings: false
        });
      };

      var getToolbarEditButton = function getToolbarEditButton(open) {
        return createElement(BlockControls, null, createElement(Toolbar, null, createElement(ToolbarButton, {
          title: __('Edit image'),
          icon: "edit",
          onClick: open
        })));
      };

      var getInspectorControls = function getInspectorControls() {
        return createElement(BottomSheet, {
          isVisible: _this2.state.showSettings,
          onClose: onImageSettingsClose,
          hideHeader: true
        }, createElement(BottomSheet.Cell, {
          icon: 'admin-links',
          label: __('Link To'),
          value: href || '',
          valuePlaceholder: __('Add URL'),
          onChangeValue: _this2.onSetLinkDestination,
          autoCapitalize: "none",
          autoCorrect: false,
          keyboardType: "url"
        }), createElement(BottomSheet.Cell, {
          icon: 'editor-textcolor',
          label: __('Alt Text'),
          value: alt || '',
          valuePlaceholder: __('None'),
          separatorType: 'fullWidth',
          onChangeValue: _this2.updateAlt
        }), createElement(BottomSheet.Cell, {
          label: __('Clear All Settings'),
          labelStyle: styles.clearSettingsButton,
          separatorType: 'none',
          onPress: _this2.onClearSettings
        }));
      };

      if (!url) {
        return createElement(View, {
          style: {
            flex: 1
          }
        }, createElement(MediaPlaceholder, {
          mediaType: MEDIA_TYPE_IMAGE,
          onSelectURL: this.onSelectMediaUploadOption,
          icon: this.getIcon(false),
          onFocus: this.props.onFocus
        }));
      }

      var imageContainerHeight = Dimensions.get('window').width / IMAGE_ASPECT_RATIO;

      var getImageComponent = function getImageComponent(openMediaOptions, getMediaOptions) {
        return createElement(TouchableWithoutFeedback, {
          accessible: !isSelected,
          onPress: _this2.onImagePressed,
          onLongPress: openMediaOptions,
          disabled: !isSelected
        }, createElement(View, {
          style: {
            flex: 1
          }
        }, getInspectorControls(), getMediaOptions(), !_this2.state.isCaptionSelected && getToolbarEditButton(openMediaOptions), createElement(InspectorControls, null, createElement(ToolbarButton, {
          title: __('Image Settings'),
          icon: "admin-generic",
          onClick: onImageSettingsButtonPressed
        })), createElement(MediaUploadProgress, {
          height: height,
          width: width,
          coverUrl: url,
          mediaId: id,
          onUpdateMediaProgress: _this2.updateMediaProgress,
          onFinishMediaUploadWithSuccess: _this2.finishMediaUploadWithSuccess,
          onFinishMediaUploadWithFailure: _this2.finishMediaUploadWithFailure,
          onMediaUploadStateReset: _this2.mediaUploadStateReset,
          renderContent: function renderContent(_ref) {
            var isUploadInProgress = _ref.isUploadInProgress,
                isUploadFailed = _ref.isUploadFailed,
                finalWidth = _ref.finalWidth,
                finalHeight = _ref.finalHeight,
                imageWidthWithinContainer = _ref.imageWidthWithinContainer,
                retryMessage = _ref.retryMessage;
            var opacity = isUploadInProgress ? 0.3 : 1;

            var icon = _this2.getIcon(isUploadFailed);

            var iconContainer = createElement(View, {
              style: styles.modalIcon
            }, icon);
            return createElement(View, {
              style: {
                flex: 1
              }
            }, !imageWidthWithinContainer && createElement(View, {
              style: [styles.imageContainer, {
                height: imageContainerHeight
              }]
            }, _this2.getIcon(false)), createElement(ImageBackground, {
              accessible: true,
              disabled: !isSelected,
              accessibilityLabel: alt,
              accessibilityHint: __('Double tap and hold to edit'),
              accessibilityRole: 'imagebutton',
              style: {
                width: finalWidth,
                height: finalHeight,
                opacity: opacity
              },
              resizeMethod: "scale",
              source: {
                uri: url
              },
              key: url
            }, isUploadFailed && createElement(View, {
              style: [styles.imageContainer, {
                flex: 1,
                backgroundColor: 'rgba(0, 0, 0, 0.5)'
              }]
            }, iconContainer, createElement(Text, {
              style: styles.uploadFailedText
            }, retryMessage))));
          }
        }), createElement(Caption, {
          clientId: _this2.props.clientId,
          isSelected: _this2.state.isCaptionSelected,
          accessible: true,
          accessibilityLabelCreator: function accessibilityLabelCreator(caption) {
            return isEmpty(caption) ?
            /* translators: accessibility text. Empty image caption. */
            'Image caption. Empty' : sprintf(
            /* translators: accessibility text. %s: image caption. */
            __('Image caption. %s'), caption);
          },
          onFocus: _this2.onFocusCaption,
          onBlur: _this2.props.onBlur // always assign onBlur as props

        })));
      };

      return createElement(MediaUpload, {
        mediaType: MEDIA_TYPE_IMAGE,
        onSelectURL: this.onSelectMediaUploadOption,
        render: function render(_ref2) {
          var open = _ref2.open,
              getMediaOptions = _ref2.getMediaOptions;
          return getImageComponent(open, getMediaOptions);
        }
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      // Avoid a UI flicker in the toolbar by insuring that isCaptionSelected
      // is updated immediately any time the isSelected prop becomes false
      return {
        isCaptionSelected: props.isSelected && state.isCaptionSelected
      };
    }
  }]);

  return ImageEdit;
}(React.Component);

export default ImageEdit;
//# sourceMappingURL=edit.native.js.map