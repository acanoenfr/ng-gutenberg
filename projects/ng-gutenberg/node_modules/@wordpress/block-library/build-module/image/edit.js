import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
import { find, get, isEmpty, map, last, omit, pick } from 'lodash';
/**
 * WordPress dependencies
 */

import { getBlobByURL, isBlobURL, revokeBlobURL } from '@wordpress/blob';
import { Button, ButtonGroup, ExternalLink, IconButton, MenuItem, NavigableMenu, PanelBody, Path, Rect, ResizableBox, SelectControl, Spinner, SVG, TextareaControl, TextControl, ToggleControl, Toolbar, withNotices } from '@wordpress/components';
import { compose } from '@wordpress/compose';
import { LEFT, RIGHT, UP, DOWN, BACKSPACE, ENTER } from '@wordpress/keycodes';
import { withSelect, withDispatch } from '@wordpress/data';
import { BlockAlignmentToolbar, BlockControls, BlockIcon, InspectorControls, MediaPlaceholder, URLPopover, RichText } from '@wordpress/block-editor';
import { Component, useCallback, useState, useRef } from '@wordpress/element';
import { __, sprintf } from '@wordpress/i18n';
import { getPath } from '@wordpress/url';
import { withViewportMatch } from '@wordpress/viewport';
import { speak } from '@wordpress/a11y';
/**
 * Internal dependencies
 */

import { createUpgradedEmbedBlock } from '../embed/util';
import icon from './icon';
import ImageSize from './image-size';
/**
 * Module constants
 */

var MIN_SIZE = 20;
var LINK_DESTINATION_NONE = 'none';
var LINK_DESTINATION_MEDIA = 'media';
var LINK_DESTINATION_ATTACHMENT = 'attachment';
var LINK_DESTINATION_CUSTOM = 'custom';
var NEW_TAB_REL = 'noreferrer noopener';
var ALLOWED_MEDIA_TYPES = ['image'];
var DEFAULT_SIZE_SLUG = 'large';
export var pickRelevantMediaFiles = function pickRelevantMediaFiles(image) {
  var imageProps = pick(image, ['alt', 'id', 'link', 'caption']);
  imageProps.url = get(image, ['sizes', 'large', 'url']) || get(image, ['media_details', 'sizes', 'large', 'source_url']) || image.url;
  return imageProps;
};
/**
 * Is the URL a temporary blob URL? A blob URL is one that is used temporarily
 * while the image is being uploaded and will not have an id yet allocated.
 *
 * @param {number=} id The id of the image.
 * @param {string=} url The url of the image.
 *
 * @return {boolean} Is the URL a Blob URL
 */

var isTemporaryImage = function isTemporaryImage(id, url) {
  return !id && isBlobURL(url);
};
/**
 * Is the url for the image hosted externally. An externally hosted image has no id
 * and is not a blob url.
 *
 * @param {number=} id  The id of the image.
 * @param {string=} url The url of the image.
 *
 * @return {boolean} Is the url an externally hosted url?
 */


var isExternalImage = function isExternalImage(id, url) {
  return url && !id && !isBlobURL(url);
};

var stopPropagation = function stopPropagation(event) {
  event.stopPropagation();
};

var stopPropagationRelevantKeys = function stopPropagationRelevantKeys(event) {
  if ([LEFT, DOWN, RIGHT, UP, BACKSPACE, ENTER].indexOf(event.keyCode) > -1) {
    // Stop the key event from propagating up to ObserveTyping.startTypingInTextField.
    event.stopPropagation();
  }
};

var ImageURLInputUI = function ImageURLInputUI(_ref) {
  var advancedOptions = _ref.advancedOptions,
      linkDestination = _ref.linkDestination,
      mediaLinks = _ref.mediaLinks,
      onChangeUrl = _ref.onChangeUrl,
      url = _ref.url;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  var openLinkUI = useCallback(function () {
    setIsOpen(true);
  });

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isEditingLink = _useState4[0],
      setIsEditingLink = _useState4[1];

  var _useState5 = useState(null),
      _useState6 = _slicedToArray(_useState5, 2),
      urlInput = _useState6[0],
      setUrlInput = _useState6[1];

  var startEditLink = useCallback(function () {
    if (linkDestination === LINK_DESTINATION_MEDIA || linkDestination === LINK_DESTINATION_ATTACHMENT) {
      setUrlInput('');
    }

    setIsEditingLink(true);
  });
  var stopEditLink = useCallback(function () {
    setIsEditingLink(false);
  });
  var closeLinkUI = useCallback(function () {
    setUrlInput(null);
    stopEditLink();
    setIsOpen(false);
  });
  var autocompleteRef = useRef(null);
  var onClickOutside = useCallback(function () {
    return function (event) {
      // The autocomplete suggestions list renders in a separate popover (in a portal),
      // so onClickOutside fails to detect that a click on a suggestion occurred in the
      // LinkContainer. Detect clicks on autocomplete suggestions using a ref here, and
      // return to avoid the popover being closed.
      var autocompleteElement = autocompleteRef.current;

      if (autocompleteElement && autocompleteElement.contains(event.target)) {
        return;
      }

      setIsOpen(false);
      setUrlInput(null);
      stopEditLink();
    };
  });
  var onSubmitLinkChange = useCallback(function () {
    return function (event) {
      if (urlInput) {
        onChangeUrl(urlInput);
      }

      stopEditLink();
      setUrlInput(null);
      event.preventDefault();
    };
  });
  var onLinkRemove = useCallback(function () {
    closeLinkUI();
    onChangeUrl('');
  });
  var linkEditorValue = urlInput !== null ? urlInput : url;
  var urlLabel = (find(mediaLinks, ['linkDestination', linkDestination]) || {}).title;
  return createElement(Fragment, null, createElement(IconButton, {
    icon: "admin-links",
    className: "components-toolbar__control",
    label: url ? __('Edit link') : __('Insert link'),
    "aria-expanded": isOpen,
    onClick: openLinkUI
  }), isOpen && createElement(URLPopover, {
    onClickOutside: onClickOutside(),
    onClose: closeLinkUI,
    renderSettings: function renderSettings() {
      return advancedOptions;
    },
    additionalControls: !linkEditorValue && createElement(NavigableMenu, null, map(mediaLinks, function (link) {
      return createElement(MenuItem, {
        key: link.linkDestination,
        icon: link.icon,
        onClick: function onClick() {
          setUrlInput(null);
          onChangeUrl(link.url);
          stopEditLink();
        }
      }, link.title);
    }))
  }, (!url || isEditingLink) && createElement(URLPopover.LinkEditor, {
    className: "editor-format-toolbar__link-container-content block-editor-format-toolbar__link-container-content",
    value: linkEditorValue,
    onChangeInputValue: setUrlInput,
    onKeyDown: stopPropagationRelevantKeys,
    onKeyPress: stopPropagation,
    onSubmit: onSubmitLinkChange(),
    autocompleteRef: autocompleteRef
  }), url && !isEditingLink && createElement(Fragment, null, createElement(URLPopover.LinkViewer, {
    className: "editor-format-toolbar__link-container-content block-editor-format-toolbar__link-container-content",
    onKeyPress: stopPropagation,
    url: url,
    onEditLinkClick: startEditLink,
    urlLabel: urlLabel
  }), createElement(IconButton, {
    icon: "no",
    label: __('Remove link'),
    onClick: onLinkRemove
  }))));
};

export var ImageEdit =
/*#__PURE__*/
function (_Component) {
  _inherits(ImageEdit, _Component);

  function ImageEdit(_ref2) {
    var _this;

    var attributes = _ref2.attributes;

    _classCallCheck(this, ImageEdit);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ImageEdit).apply(this, arguments));
    _this.updateAlt = _this.updateAlt.bind(_assertThisInitialized(_this));
    _this.updateAlignment = _this.updateAlignment.bind(_assertThisInitialized(_this));
    _this.onFocusCaption = _this.onFocusCaption.bind(_assertThisInitialized(_this));
    _this.onImageClick = _this.onImageClick.bind(_assertThisInitialized(_this));
    _this.onSelectImage = _this.onSelectImage.bind(_assertThisInitialized(_this));
    _this.onSelectURL = _this.onSelectURL.bind(_assertThisInitialized(_this));
    _this.updateImage = _this.updateImage.bind(_assertThisInitialized(_this));
    _this.updateWidth = _this.updateWidth.bind(_assertThisInitialized(_this));
    _this.updateHeight = _this.updateHeight.bind(_assertThisInitialized(_this));
    _this.updateDimensions = _this.updateDimensions.bind(_assertThisInitialized(_this));
    _this.onSetHref = _this.onSetHref.bind(_assertThisInitialized(_this));
    _this.onSetLinkClass = _this.onSetLinkClass.bind(_assertThisInitialized(_this));
    _this.onSetLinkRel = _this.onSetLinkRel.bind(_assertThisInitialized(_this));
    _this.onSetNewTab = _this.onSetNewTab.bind(_assertThisInitialized(_this));
    _this.getFilename = _this.getFilename.bind(_assertThisInitialized(_this));
    _this.toggleIsEditing = _this.toggleIsEditing.bind(_assertThisInitialized(_this));
    _this.onUploadError = _this.onUploadError.bind(_assertThisInitialized(_this));
    _this.onImageError = _this.onImageError.bind(_assertThisInitialized(_this));
    _this.getLinkDestinations = _this.getLinkDestinations.bind(_assertThisInitialized(_this));
    _this.state = {
      captionFocused: false,
      isEditing: !attributes.url
    };
    return _this;
  }

  _createClass(ImageEdit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var _this$props = this.props,
          attributes = _this$props.attributes,
          mediaUpload = _this$props.mediaUpload,
          noticeOperations = _this$props.noticeOperations;
      var id = attributes.id,
          _attributes$url = attributes.url,
          url = _attributes$url === void 0 ? '' : _attributes$url;

      if (isTemporaryImage(id, url)) {
        var file = getBlobByURL(url);

        if (file) {
          mediaUpload({
            filesList: [file],
            onFileChange: function onFileChange(_ref3) {
              var _ref4 = _slicedToArray(_ref3, 1),
                  image = _ref4[0];

              _this2.onSelectImage(image);
            },
            allowedTypes: ALLOWED_MEDIA_TYPES,
            onError: function onError(message) {
              noticeOperations.createErrorNotice(message);

              _this2.setState({
                isEditing: true
              });
            }
          });
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _prevProps$attributes = prevProps.attributes,
          prevID = _prevProps$attributes.id,
          _prevProps$attributes2 = _prevProps$attributes.url,
          prevURL = _prevProps$attributes2 === void 0 ? '' : _prevProps$attributes2;
      var _this$props$attribute = this.props.attributes,
          id = _this$props$attribute.id,
          _this$props$attribute2 = _this$props$attribute.url,
          url = _this$props$attribute2 === void 0 ? '' : _this$props$attribute2;

      if (isTemporaryImage(prevID, prevURL) && !isTemporaryImage(id, url)) {
        revokeBlobURL(url);
      }

      if (!this.props.isSelected && prevProps.isSelected && this.state.captionFocused) {
        this.setState({
          captionFocused: false
        });
      }
    }
  }, {
    key: "onUploadError",
    value: function onUploadError(message) {
      var noticeOperations = this.props.noticeOperations;
      noticeOperations.removeAllNotices();
      noticeOperations.createErrorNotice(message);
      this.setState({
        isEditing: true
      });
    }
  }, {
    key: "onSelectImage",
    value: function onSelectImage(media) {
      if (!media || !media.url) {
        this.props.setAttributes({
          url: undefined,
          alt: undefined,
          id: undefined,
          caption: undefined
        });
        return;
      }

      this.setState({
        isEditing: false
      });
      var _this$props$attribute3 = this.props.attributes,
          id = _this$props$attribute3.id,
          url = _this$props$attribute3.url,
          alt = _this$props$attribute3.alt,
          caption = _this$props$attribute3.caption;
      var mediaAttributes = pickRelevantMediaFiles(media); // If the current image is temporary but an alt or caption text was meanwhile written by the user,
      // make sure the text is not overwritten.

      if (isTemporaryImage(id, url)) {
        if (alt) {
          mediaAttributes = omit(mediaAttributes, ['alt']);
        }

        if (caption) {
          mediaAttributes = omit(mediaAttributes, ['caption']);
        }
      }

      var additionalAttributes; // Reset the dimension attributes if changing to a different image.

      if (!media.id || media.id !== id) {
        additionalAttributes = {
          width: undefined,
          height: undefined,
          sizeSlug: DEFAULT_SIZE_SLUG
        };
      } else {
        // Keep the same url when selecting the same file, so "Image Size" option is not changed.
        additionalAttributes = {
          url: url
        };
      }

      this.props.setAttributes(_objectSpread({}, mediaAttributes, additionalAttributes));
    }
  }, {
    key: "onSelectURL",
    value: function onSelectURL(newURL) {
      var url = this.props.attributes.url;

      if (newURL !== url) {
        this.props.setAttributes({
          url: newURL,
          id: undefined,
          sizeSlug: DEFAULT_SIZE_SLUG
        });
      }

      this.setState({
        isEditing: false
      });
    }
  }, {
    key: "onImageError",
    value: function onImageError(url) {
      // Check if there's an embed block that handles this URL.
      var embedBlock = createUpgradedEmbedBlock({
        attributes: {
          url: url
        }
      });

      if (undefined !== embedBlock) {
        this.props.onReplace(embedBlock);
      }
    }
  }, {
    key: "onSetHref",
    value: function onSetHref(value) {
      var linkDestinations = this.getLinkDestinations();
      var attributes = this.props.attributes;
      var linkDestination = attributes.linkDestination;
      var linkDestinationInput;

      if (!value) {
        linkDestinationInput = LINK_DESTINATION_NONE;
      } else {
        linkDestinationInput = (find(linkDestinations, function (destination) {
          return destination.url === value;
        }) || {
          linkDestination: LINK_DESTINATION_CUSTOM
        }).linkDestination;
      }

      if (linkDestination !== linkDestinationInput) {
        this.props.setAttributes({
          linkDestination: linkDestinationInput,
          href: value
        });
        return;
      }

      this.props.setAttributes({
        href: value
      });
    }
  }, {
    key: "onSetLinkClass",
    value: function onSetLinkClass(value) {
      this.props.setAttributes({
        linkClass: value
      });
    }
  }, {
    key: "onSetLinkRel",
    value: function onSetLinkRel(value) {
      this.props.setAttributes({
        rel: value
      });
    }
  }, {
    key: "onSetNewTab",
    value: function onSetNewTab(value) {
      var rel = this.props.attributes.rel;
      var linkTarget = value ? '_blank' : undefined;
      var updatedRel = rel;

      if (linkTarget && !rel) {
        updatedRel = NEW_TAB_REL;
      } else if (!linkTarget && rel === NEW_TAB_REL) {
        updatedRel = undefined;
      }

      this.props.setAttributes({
        linkTarget: linkTarget,
        rel: updatedRel
      });
    }
  }, {
    key: "onFocusCaption",
    value: function onFocusCaption() {
      if (!this.state.captionFocused) {
        this.setState({
          captionFocused: true
        });
      }
    }
  }, {
    key: "onImageClick",
    value: function onImageClick() {
      if (this.state.captionFocused) {
        this.setState({
          captionFocused: false
        });
      }
    }
  }, {
    key: "updateAlt",
    value: function updateAlt(newAlt) {
      this.props.setAttributes({
        alt: newAlt
      });
    }
  }, {
    key: "updateAlignment",
    value: function updateAlignment(nextAlign) {
      var extraUpdatedAttributes = ['wide', 'full'].indexOf(nextAlign) !== -1 ? {
        width: undefined,
        height: undefined
      } : {};
      this.props.setAttributes(_objectSpread({}, extraUpdatedAttributes, {
        align: nextAlign
      }));
    }
  }, {
    key: "updateImage",
    value: function updateImage(sizeSlug) {
      var image = this.props.image;
      var url = get(image, ['media_details', 'sizes', sizeSlug, 'source_url']);

      if (!url) {
        return null;
      }

      this.props.setAttributes({
        url: url,
        width: undefined,
        height: undefined,
        sizeSlug: sizeSlug
      });
    }
  }, {
    key: "updateWidth",
    value: function updateWidth(width) {
      this.props.setAttributes({
        width: parseInt(width, 10)
      });
    }
  }, {
    key: "updateHeight",
    value: function updateHeight(height) {
      this.props.setAttributes({
        height: parseInt(height, 10)
      });
    }
  }, {
    key: "updateDimensions",
    value: function updateDimensions() {
      var _this3 = this;

      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      return function () {
        _this3.props.setAttributes({
          width: width,
          height: height
        });
      };
    }
  }, {
    key: "getFilename",
    value: function getFilename(url) {
      var path = getPath(url);

      if (path) {
        return last(path.split('/'));
      }
    }
  }, {
    key: "getLinkDestinations",
    value: function getLinkDestinations() {
      return [{
        linkDestination: LINK_DESTINATION_MEDIA,
        title: __('Media File'),
        url: this.props.image && this.props.image.source_url || this.props.attributes.url,
        icon: icon
      }, {
        linkDestination: LINK_DESTINATION_ATTACHMENT,
        title: __('Attachment Page'),
        url: this.props.image && this.props.image.link,
        icon: createElement(SVG, {
          viewBox: "0 0 24 24",
          xmlns: "http://www.w3.org/2000/svg"
        }, createElement(Path, {
          d: "M0 0h24v24H0V0z",
          fill: "none"
        }), createElement(Path, {
          d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zM6 20V4h7v5h5v11H6z"
        }))
      }];
    }
  }, {
    key: "toggleIsEditing",
    value: function toggleIsEditing() {
      this.setState({
        isEditing: !this.state.isEditing
      });

      if (this.state.isEditing) {
        speak(__('You are now viewing the image in the image block.'));
      } else {
        speak(__('You are now editing the image in the image block.'));
      }
    }
  }, {
    key: "getImageSizeOptions",
    value: function getImageSizeOptions() {
      var imageSizes = this.props.imageSizes;
      return map(imageSizes, function (_ref5) {
        var name = _ref5.name,
            slug = _ref5.slug;
        return {
          value: slug,
          label: name
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var isEditing = this.state.isEditing;
      var _this$props2 = this.props,
          attributes = _this$props2.attributes,
          setAttributes = _this$props2.setAttributes,
          isLargeViewport = _this$props2.isLargeViewport,
          isSelected = _this$props2.isSelected,
          className = _this$props2.className,
          maxWidth = _this$props2.maxWidth,
          noticeUI = _this$props2.noticeUI,
          isRTL = _this$props2.isRTL,
          onResizeStart = _this$props2.onResizeStart,
          _onResizeStop = _this$props2.onResizeStop;
      var url = attributes.url,
          alt = attributes.alt,
          caption = attributes.caption,
          align = attributes.align,
          id = attributes.id,
          href = attributes.href,
          rel = attributes.rel,
          linkClass = attributes.linkClass,
          linkDestination = attributes.linkDestination,
          width = attributes.width,
          height = attributes.height,
          linkTarget = attributes.linkTarget,
          sizeSlug = attributes.sizeSlug;
      var isExternal = isExternalImage(id, url);
      var editImageIcon = createElement(SVG, {
        width: 20,
        height: 20,
        viewBox: "0 0 20 20"
      }, createElement(Rect, {
        x: 11,
        y: 3,
        width: 7,
        height: 5,
        rx: 1
      }), createElement(Rect, {
        x: 2,
        y: 12,
        width: 7,
        height: 5,
        rx: 1
      }), createElement(Path, {
        d: "M13,12h1a3,3,0,0,1-3,3v2a5,5,0,0,0,5-5h1L15,9Z"
      }), createElement(Path, {
        d: "M4,8H3l2,3L7,8H6A3,3,0,0,1,9,5V3A5,5,0,0,0,4,8Z"
      }));
      var controls = createElement(BlockControls, null, createElement(BlockAlignmentToolbar, {
        value: align,
        onChange: this.updateAlignment
      }), url && createElement(Fragment, null, createElement(Toolbar, null, createElement(IconButton, {
        className: classnames('components-icon-button components-toolbar__control', {
          'is-active': this.state.isEditing
        }),
        label: __('Edit image'),
        "aria-pressed": this.state.isEditing,
        onClick: this.toggleIsEditing,
        icon: editImageIcon
      })), createElement(Toolbar, null, createElement(ImageURLInputUI, {
        url: href || '',
        onChangeUrl: this.onSetHref,
        mediaLinks: this.getLinkDestinations(),
        linkDestination: linkDestination,
        advancedOptions: createElement(Fragment, null, createElement(ToggleControl, {
          label: __('Open in New Tab'),
          onChange: this.onSetNewTab,
          checked: linkTarget === '_blank'
        }), createElement(TextControl, {
          label: __('Link CSS Class'),
          value: linkClass || '',
          onKeyPress: stopPropagation,
          onKeyDown: stopPropagationRelevantKeys,
          onChange: this.onSetLinkClass
        }), createElement(TextControl, {
          label: __('Link Rel'),
          value: rel || '',
          onChange: this.onSetLinkRel,
          onKeyPress: stopPropagation,
          onKeyDown: stopPropagationRelevantKeys
        }))
      }))));
      var src = isExternal ? url : undefined;
      var labels = {
        title: !url ? __('Image') : __('Edit image'),
        instructions: __('Upload an image file, pick one from your media library, or add one with a URL.')
      };
      var mediaPreview = !!url && createElement("img", {
        alt: __('Edit image'),
        title: __('Edit image'),
        className: 'edit-image-preview',
        src: url
      });
      var mediaPlaceholder = createElement(MediaPlaceholder, {
        icon: createElement(BlockIcon, {
          icon: icon
        }),
        className: className,
        labels: labels,
        onSelect: this.onSelectImage,
        onSelectURL: this.onSelectURL,
        onDoubleClick: this.toggleIsEditing,
        onCancel: !!url && this.toggleIsEditing,
        notices: noticeUI,
        onError: this.onUploadError,
        accept: "image/*",
        allowedTypes: ALLOWED_MEDIA_TYPES,
        value: {
          id: id,
          src: src
        },
        mediaPreview: mediaPreview,
        dropZoneUIOnly: !isEditing && url
      });

      if (isEditing || !url) {
        return createElement(Fragment, null, controls, mediaPlaceholder);
      }

      var classes = classnames(className, _defineProperty({
        'is-transient': isBlobURL(url),
        'is-resized': !!width || !!height,
        'is-focused': isSelected
      }, "size-".concat(sizeSlug), sizeSlug));
      var isResizable = ['wide', 'full'].indexOf(align) === -1 && isLargeViewport;
      var imageSizeOptions = this.getImageSizeOptions();

      var getInspectorControls = function getInspectorControls(imageWidth, imageHeight) {
        return createElement(InspectorControls, null, createElement(PanelBody, {
          title: __('Image Settings')
        }, createElement(TextareaControl, {
          label: __('Alt Text (Alternative Text)'),
          value: alt,
          onChange: _this4.updateAlt,
          help: createElement(Fragment, null, createElement(ExternalLink, {
            href: "https://www.w3.org/WAI/tutorials/images/decision-tree"
          }, __('Describe the purpose of the image')), __('Leave empty if the image is purely decorative.'))
        }), !isEmpty(imageSizeOptions) && createElement(SelectControl, {
          label: __('Image Size'),
          value: sizeSlug,
          options: imageSizeOptions,
          onChange: _this4.updateImage
        }), isResizable && createElement("div", {
          className: "block-library-image__dimensions"
        }, createElement("p", {
          className: "block-library-image__dimensions__row"
        }, __('Image Dimensions')), createElement("div", {
          className: "block-library-image__dimensions__row"
        }, createElement(TextControl, {
          type: "number",
          className: "block-library-image__dimensions__width",
          label: __('Width'),
          value: width || imageWidth || '',
          min: 1,
          onChange: _this4.updateWidth
        }), createElement(TextControl, {
          type: "number",
          className: "block-library-image__dimensions__height",
          label: __('Height'),
          value: height || imageHeight || '',
          min: 1,
          onChange: _this4.updateHeight
        })), createElement("div", {
          className: "block-library-image__dimensions__row"
        }, createElement(ButtonGroup, {
          "aria-label": __('Image Size')
        }, [25, 50, 75, 100].map(function (scale) {
          var scaledWidth = Math.round(imageWidth * (scale / 100));
          var scaledHeight = Math.round(imageHeight * (scale / 100));
          var isCurrent = width === scaledWidth && height === scaledHeight;
          return createElement(Button, {
            key: scale,
            isSmall: true,
            isPrimary: isCurrent,
            "aria-pressed": isCurrent,
            onClick: _this4.updateDimensions(scaledWidth, scaledHeight)
          }, scale, "%");
        })), createElement(Button, {
          isSmall: true,
          onClick: _this4.updateDimensions()
        }, __('Reset'))))));
      }; // Disable reason: Each block can be selected by clicking on it

      /* eslint-disable jsx-a11y/click-events-have-key-events */


      return createElement(Fragment, null, controls, createElement("figure", {
        className: classes
      }, createElement(ImageSize, {
        src: url,
        dirtynessTrigger: align
      }, function (sizes) {
        var imageWidthWithinContainer = sizes.imageWidthWithinContainer,
            imageHeightWithinContainer = sizes.imageHeightWithinContainer,
            imageWidth = sizes.imageWidth,
            imageHeight = sizes.imageHeight;

        var filename = _this4.getFilename(url);

        var defaultedAlt;

        if (alt) {
          defaultedAlt = alt;
        } else if (filename) {
          defaultedAlt = sprintf(__('This image has an empty alt attribute; its file name is %s'), filename);
        } else {
          defaultedAlt = __('This image has an empty alt attribute');
        }

        var img = // Disable reason: Image itself is not meant to be interactive, but
        // should direct focus to block.

        /* eslint-disable jsx-a11y/no-noninteractive-element-interactions */
        createElement(Fragment, null, createElement("img", {
          src: url,
          alt: defaultedAlt,
          onDoubleClick: _this4.toggleIsEditing,
          onClick: _this4.onImageClick,
          onError: function onError() {
            return _this4.onImageError(url);
          }
        }), isBlobURL(url) && createElement(Spinner, null))
        /* eslint-enable jsx-a11y/no-noninteractive-element-interactions */
        ;

        if (!isResizable || !imageWidthWithinContainer) {
          return createElement(Fragment, null, getInspectorControls(imageWidth, imageHeight), createElement("div", {
            style: {
              width: width,
              height: height
            }
          }, img));
        }

        var currentWidth = width || imageWidthWithinContainer;
        var currentHeight = height || imageHeightWithinContainer;
        var ratio = imageWidth / imageHeight;
        var minWidth = imageWidth < imageHeight ? MIN_SIZE : MIN_SIZE * ratio;
        var minHeight = imageHeight < imageWidth ? MIN_SIZE : MIN_SIZE / ratio; // With the current implementation of ResizableBox, an image needs an explicit pixel value for the max-width.
        // In absence of being able to set the content-width, this max-width is currently dictated by the vanilla editor style.
        // The following variable adds a buffer to this vanilla style, so 3rd party themes have some wiggleroom.
        // This does, in most cases, allow you to scale the image beyond the width of the main column, though not infinitely.
        // @todo It would be good to revisit this once a content-width variable becomes available.

        var maxWidthBuffer = maxWidth * 2.5;
        var showRightHandle = false;
        var showLeftHandle = false;
        /* eslint-disable no-lonely-if */
        // See https://github.com/WordPress/gutenberg/issues/7584.

        if (align === 'center') {
          // When the image is centered, show both handles.
          showRightHandle = true;
          showLeftHandle = true;
        } else if (isRTL) {
          // In RTL mode the image is on the right by default.
          // Show the right handle and hide the left handle only when it is aligned left.
          // Otherwise always show the left handle.
          if (align === 'left') {
            showRightHandle = true;
          } else {
            showLeftHandle = true;
          }
        } else {
          // Show the left handle and hide the right handle only when the image is aligned right.
          // Otherwise always show the right handle.
          if (align === 'right') {
            showLeftHandle = true;
          } else {
            showRightHandle = true;
          }
        }
        /* eslint-enable no-lonely-if */


        return createElement(Fragment, null, getInspectorControls(imageWidth, imageHeight), createElement(ResizableBox, {
          size: {
            width: width,
            height: height
          },
          minWidth: minWidth,
          maxWidth: maxWidthBuffer,
          minHeight: minHeight,
          maxHeight: maxWidthBuffer / ratio,
          lockAspectRatio: true,
          enable: {
            top: false,
            right: showRightHandle,
            bottom: true,
            left: showLeftHandle
          },
          onResizeStart: onResizeStart,
          onResizeStop: function onResizeStop(event, direction, elt, delta) {
            _onResizeStop();

            setAttributes({
              width: parseInt(currentWidth + delta.width, 10),
              height: parseInt(currentHeight + delta.height, 10)
            });
          }
        }, img));
      }), (!RichText.isEmpty(caption) || isSelected) && createElement(RichText, {
        tagName: "figcaption",
        placeholder: __('Write caption…'),
        value: caption,
        unstableOnFocus: this.onFocusCaption,
        onChange: function onChange(value) {
          return setAttributes({
            caption: value
          });
        },
        isSelected: this.state.captionFocused,
        inlineToolbar: true
      })), mediaPlaceholder);
      /* eslint-enable jsx-a11y/click-events-have-key-events */
    }
  }]);

  return ImageEdit;
}(Component);
export default compose([withDispatch(function (dispatch) {
  var _dispatch = dispatch('core/block-editor'),
      toggleSelection = _dispatch.toggleSelection;

  return {
    onResizeStart: function onResizeStart() {
      return toggleSelection(false);
    },
    onResizeStop: function onResizeStop() {
      return toggleSelection(true);
    }
  };
}), withSelect(function (select, props) {
  var _select = select('core'),
      getMedia = _select.getMedia;

  var _select2 = select('core/block-editor'),
      getSettings = _select2.getSettings;

  var id = props.attributes.id,
      isSelected = props.isSelected;

  var _getSettings = getSettings(),
      __experimentalMediaUpload = _getSettings.__experimentalMediaUpload,
      imageSizes = _getSettings.imageSizes,
      isRTL = _getSettings.isRTL,
      maxWidth = _getSettings.maxWidth;

  return {
    image: id && isSelected ? getMedia(id) : null,
    maxWidth: maxWidth,
    isRTL: isRTL,
    imageSizes: imageSizes,
    mediaUpload: __experimentalMediaUpload
  };
}), withViewportMatch({
  isLargeViewport: 'medium'
}), withNotices])(ImageEdit);
//# sourceMappingURL=edit.js.map