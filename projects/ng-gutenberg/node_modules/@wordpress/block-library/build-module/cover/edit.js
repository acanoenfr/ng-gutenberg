import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
import FastAverageColor from 'fast-average-color';
import tinycolor from 'tinycolor2';
/**
 * WordPress dependencies
 */

import { Component, createRef, useCallback, useState } from '@wordpress/element';
import { FocalPointPicker, IconButton, PanelBody, PanelRow, RangeControl, ToggleControl, Toolbar, withNotices, ResizableBox, BaseControl, Button } from '@wordpress/components';
import { compose, withInstanceId } from '@wordpress/compose';
import { BlockControls, BlockIcon, InnerBlocks, InspectorControls, MediaPlaceholder, MediaUpload, MediaUploadCheck, PanelColorSettings, withColors, ColorPalette } from '@wordpress/block-editor';
import { __ } from '@wordpress/i18n';
import { withDispatch } from '@wordpress/data';
/**
 * Internal dependencies
 */

import icon from './icon';
import { IMAGE_BACKGROUND_TYPE, VIDEO_BACKGROUND_TYPE, COVER_MIN_HEIGHT, backgroundImageStyles, dimRatioToClass } from './shared';
/**
 * Module Constants
 */

var ALLOWED_MEDIA_TYPES = ['image', 'video'];
var INNER_BLOCKS_TEMPLATE = [['core/paragraph', {
  align: 'center',
  fontSize: 'large',
  placeholder: __('Write titleâ€¦')
}]];

function retrieveFastAverageColor() {
  if (!retrieveFastAverageColor.fastAverageColor) {
    retrieveFastAverageColor.fastAverageColor = new FastAverageColor();
  }

  return retrieveFastAverageColor.fastAverageColor;
}

var CoverHeightInput = withInstanceId(function (_ref) {
  var _ref$value = _ref.value,
      value = _ref$value === void 0 ? '' : _ref$value,
      instanceId = _ref.instanceId,
      onChange = _ref.onChange;

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      temporaryInput = _useState2[0],
      setTemporaryInput = _useState2[1];

  var onChangeEvent = useCallback(function (event) {
    var unprocessedValue = event.target.value;
    var inputValue = unprocessedValue !== '' ? parseInt(event.target.value, 10) : undefined;

    if ((isNaN(inputValue) || inputValue < COVER_MIN_HEIGHT) && inputValue !== undefined) {
      setTemporaryInput(event.target.value);
      return;
    }

    setTemporaryInput(null);
    onChange(inputValue);
  }, [onChange, setTemporaryInput]);
  var onBlurEvent = useCallback(function () {
    if (temporaryInput !== null) {
      setTemporaryInput(null);
    }
  }, [temporaryInput, setTemporaryInput]);
  var inputId = "block-cover-height-input-".concat(instanceId);
  return createElement(BaseControl, {
    label: __('Minimum height in pixels'),
    id: inputId
  }, createElement("input", {
    type: "number",
    id: inputId,
    onChange: onChangeEvent,
    onBlur: onBlurEvent,
    value: temporaryInput !== null ? temporaryInput : value,
    min: COVER_MIN_HEIGHT,
    step: "10"
  }));
});
var RESIZABLE_BOX_ENABLE_OPTION = {
  top: false,
  right: false,
  bottom: true,
  left: false,
  topRight: false,
  bottomRight: false,
  bottomLeft: false,
  topLeft: false
};

function ResizableCover(_ref2) {
  var className = _ref2.className,
      children = _ref2.children,
      onResizeStart = _ref2.onResizeStart,
      onResize = _ref2.onResize,
      onResizeStop = _ref2.onResizeStop;

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isResizing = _useState4[0],
      setIsResizing = _useState4[1];

  var onResizeEvent = useCallback(function (event, direction, elt) {
    onResize(elt.clientHeight);

    if (!isResizing) {
      setIsResizing(true);
    }
  }, [onResize, setIsResizing]);
  var onResizeStartEvent = useCallback(function (event, direction, elt) {
    onResizeStart(elt.clientHeight);
    onResize(elt.clientHeight);
  }, [onResizeStart, onResize]);
  var onResizeStopEvent = useCallback(function (event, direction, elt) {
    onResizeStop(elt.clientHeight);
    setIsResizing(false);
  }, [onResizeStop, setIsResizing]);
  return createElement(ResizableBox, {
    className: classnames(className, {
      'is-resizing': isResizing
    }),
    enable: RESIZABLE_BOX_ENABLE_OPTION,
    onResizeStart: onResizeStartEvent,
    onResize: onResizeEvent,
    onResizeStop: onResizeStopEvent,
    minHeight: COVER_MIN_HEIGHT
  }, children);
}

var CoverEdit =
/*#__PURE__*/
function (_Component) {
  _inherits(CoverEdit, _Component);

  function CoverEdit() {
    var _this;

    _classCallCheck(this, CoverEdit);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CoverEdit).apply(this, arguments));
    _this.state = {
      isDark: false,
      temporaryMinHeight: null
    };
    _this.imageRef = createRef();
    _this.videoRef = createRef();
    _this.changeIsDarkIfRequired = _this.changeIsDarkIfRequired.bind(_assertThisInitialized(_this));
    _this.onUploadError = _this.onUploadError.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(CoverEdit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.handleBackgroundMode();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this.handleBackgroundMode(prevProps);
    }
  }, {
    key: "onUploadError",
    value: function onUploadError(message) {
      var noticeOperations = this.props.noticeOperations;
      noticeOperations.removeAllNotices();
      noticeOperations.createErrorNotice(message);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          attributes = _this$props.attributes,
          setAttributes = _this$props.setAttributes,
          isSelected = _this$props.isSelected,
          className = _this$props.className,
          noticeUI = _this$props.noticeUI,
          overlayColor = _this$props.overlayColor,
          setOverlayColor = _this$props.setOverlayColor,
          toggleSelection = _this$props.toggleSelection;
      var backgroundType = attributes.backgroundType,
          dimRatio = attributes.dimRatio,
          focalPoint = attributes.focalPoint,
          hasParallax = attributes.hasParallax,
          id = attributes.id,
          url = attributes.url,
          minHeight = attributes.minHeight;

      var onSelectMedia = function onSelectMedia(media) {
        if (!media || !media.url) {
          setAttributes({
            url: undefined,
            id: undefined
          });
          return;
        }

        var mediaType; // for media selections originated from a file upload.

        if (media.media_type) {
          if (media.media_type === IMAGE_BACKGROUND_TYPE) {
            mediaType = IMAGE_BACKGROUND_TYPE;
          } else {
            // only images and videos are accepted so if the media_type is not an image we can assume it is a video.
            // Videos contain the media type of 'file' in the object returned from the rest api.
            mediaType = VIDEO_BACKGROUND_TYPE;
          }
        } else {
          // for media selections originated from existing files in the media library.
          if (media.type !== IMAGE_BACKGROUND_TYPE && media.type !== VIDEO_BACKGROUND_TYPE) {
            return;
          }

          mediaType = media.type;
        }

        setAttributes(_objectSpread({
          url: media.url,
          id: media.id,
          backgroundType: mediaType
        }, mediaType === VIDEO_BACKGROUND_TYPE ? {
          focalPoint: undefined,
          hasParallax: undefined
        } : {}));
      };

      var toggleParallax = function toggleParallax() {
        setAttributes(_objectSpread({
          hasParallax: !hasParallax
        }, !hasParallax ? {
          focalPoint: undefined
        } : {}));
      };

      var setDimRatio = function setDimRatio(ratio) {
        return setAttributes({
          dimRatio: ratio
        });
      };

      var temporaryMinHeight = this.state.temporaryMinHeight;

      var style = _objectSpread({}, backgroundType === IMAGE_BACKGROUND_TYPE ? backgroundImageStyles(url) : {}, {
        backgroundColor: overlayColor.color,
        minHeight: temporaryMinHeight || minHeight
      });

      if (focalPoint) {
        style.backgroundPosition = "".concat(focalPoint.x * 100, "% ").concat(focalPoint.y * 100, "%");
      }

      var controls = createElement(Fragment, null, createElement(BlockControls, null, !!(url || overlayColor.color) && createElement(Fragment, null, createElement(MediaUploadCheck, null, createElement(Toolbar, null, createElement(MediaUpload, {
        onSelect: onSelectMedia,
        allowedTypes: ALLOWED_MEDIA_TYPES,
        value: id,
        render: function render(_ref3) {
          var open = _ref3.open;
          return createElement(IconButton, {
            className: "components-toolbar__control",
            label: __('Edit media'),
            icon: "edit",
            onClick: open
          });
        }
      }))))), createElement(InspectorControls, null, !!url && createElement(PanelBody, {
        title: __('Media Settings')
      }, IMAGE_BACKGROUND_TYPE === backgroundType && createElement(ToggleControl, {
        label: __('Fixed Background'),
        checked: hasParallax,
        onChange: toggleParallax
      }), IMAGE_BACKGROUND_TYPE === backgroundType && !hasParallax && createElement(FocalPointPicker, {
        label: __('Focal Point Picker'),
        url: url,
        value: focalPoint,
        onChange: function onChange(value) {
          return setAttributes({
            focalPoint: value
          });
        }
      }), createElement(PanelRow, null, createElement(Button, {
        isDefault: true,
        isSmall: true,
        className: "block-library-cover__reset-button",
        onClick: function onClick() {
          return setAttributes({
            url: undefined,
            id: undefined,
            backgroundType: undefined,
            dimRatio: undefined,
            focalPoint: undefined,
            hasParallax: undefined
          });
        }
      }, __('Clear Media')))), (url || overlayColor.color) && createElement(Fragment, null, createElement(PanelBody, {
        title: __('Dimensions')
      }, createElement(CoverHeightInput, {
        value: temporaryMinHeight || minHeight,
        onChange: function onChange(value) {
          setAttributes({
            minHeight: value
          });
        }
      })), createElement(PanelColorSettings, {
        title: __('Overlay'),
        initialOpen: true,
        colorSettings: [{
          value: overlayColor.color,
          onChange: setOverlayColor,
          label: __('Overlay Color')
        }]
      }, !!url && createElement(RangeControl, {
        label: __('Background Opacity'),
        value: dimRatio,
        onChange: setDimRatio,
        min: 0,
        max: 100,
        step: 10,
        required: true
      })))));

      if (!(url || overlayColor.color)) {
        var placeholderIcon = createElement(BlockIcon, {
          icon: icon
        });

        var label = __('Cover');

        return createElement(Fragment, null, controls, createElement(MediaPlaceholder, {
          icon: placeholderIcon,
          className: className,
          labels: {
            title: label,
            instructions: __('Upload an image or video file, or pick one from your media library.')
          },
          onSelect: onSelectMedia,
          accept: "image/*,video/*",
          allowedTypes: ALLOWED_MEDIA_TYPES,
          notices: noticeUI,
          onError: this.onUploadError
        }, createElement(ColorPalette, {
          disableCustomColors: true,
          value: overlayColor.color,
          onChange: setOverlayColor,
          clearable: false,
          className: "wp-block-cover__placeholder-color-palette"
        })));
      }

      var classes = classnames(className, dimRatioToClass(dimRatio), _defineProperty({
        'is-dark-theme': this.state.isDark,
        'has-background-dim': dimRatio !== 0,
        'has-parallax': hasParallax
      }, overlayColor.class, overlayColor.class));
      return createElement(Fragment, null, controls, createElement(ResizableCover, {
        className: classnames('block-library-cover__resize-container', {
          'is-selected': isSelected
        }),
        onResizeStart: function onResizeStart() {
          return toggleSelection(false);
        },
        onResize: function onResize(newMinHeight) {
          _this2.setState({
            temporaryMinHeight: newMinHeight
          });
        },
        onResizeStop: function onResizeStop(newMinHeight) {
          toggleSelection(true);
          setAttributes({
            minHeight: newMinHeight
          });

          _this2.setState({
            temporaryMinHeight: null
          });
        }
      }, createElement("div", {
        "data-url": url,
        style: style,
        className: classes
      }, IMAGE_BACKGROUND_TYPE === backgroundType && // Used only to programmatically check if the image is dark or not
      createElement("img", {
        ref: this.imageRef,
        "aria-hidden": true,
        alt: "",
        style: {
          display: 'none'
        },
        src: url
      }), VIDEO_BACKGROUND_TYPE === backgroundType && createElement("video", {
        ref: this.videoRef,
        className: "wp-block-cover__video-background",
        autoPlay: true,
        muted: true,
        loop: true,
        src: url
      }), createElement("div", {
        className: "wp-block-cover__inner-container"
      }, createElement(InnerBlocks, {
        template: INNER_BLOCKS_TEMPLATE
      })))));
    }
  }, {
    key: "handleBackgroundMode",
    value: function handleBackgroundMode(prevProps) {
      var _this3 = this;

      var _this$props2 = this.props,
          attributes = _this$props2.attributes,
          overlayColor = _this$props2.overlayColor;
      var dimRatio = attributes.dimRatio,
          url = attributes.url; // If opacity is greater than 50 the dominant color is the overlay color,
      // so use that color for the dark mode computation.

      if (dimRatio > 50) {
        if (prevProps && prevProps.attributes.dimRatio > 50 && prevProps.overlayColor.color === overlayColor.color) {
          // No relevant prop changes happened there is no need to apply any change.
          return;
        }

        if (!overlayColor.color) {
          // If no overlay color exists the overlay color is black (isDark )
          this.changeIsDarkIfRequired(true);
          return;
        }

        this.changeIsDarkIfRequired(tinycolor(overlayColor.color).isDark());
        return;
      } // If opacity is lower than 50 the dominant color is the image or video color,
      // so use that color for the dark mode computation.


      if (prevProps && prevProps.attributes.dimRatio <= 50 && prevProps.attributes.url === url) {
        // No relevant prop changes happened there is no need to apply any change.
        return;
      }

      var backgroundType = attributes.backgroundType;
      var element;

      switch (backgroundType) {
        case IMAGE_BACKGROUND_TYPE:
          element = this.imageRef.current;
          break;

        case VIDEO_BACKGROUND_TYPE:
          element = this.videoRef.current;
          break;
      }

      if (!element) {
        return;
      }

      retrieveFastAverageColor().getColorAsync(element, function (color) {
        _this3.changeIsDarkIfRequired(color.isDark);
      });
    }
  }, {
    key: "changeIsDarkIfRequired",
    value: function changeIsDarkIfRequired(newIsDark) {
      if (this.state.isDark !== newIsDark) {
        this.setState({
          isDark: newIsDark
        });
      }
    }
  }]);

  return CoverEdit;
}(Component);

export default compose([withDispatch(function (dispatch) {
  var _dispatch = dispatch('core/block-editor'),
      toggleSelection = _dispatch.toggleSelection;

  return {
    toggleSelection: toggleSelection
  };
}), withColors({
  overlayColor: 'background-color'
}), withNotices, withInstanceId])(CoverEdit);
//# sourceMappingURL=edit.js.map