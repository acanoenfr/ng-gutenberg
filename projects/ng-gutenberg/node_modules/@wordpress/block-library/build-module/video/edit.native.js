import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import React from 'react';
import { View, TouchableWithoutFeedback, Text } from 'react-native';
/**
 * Internal dependencies
 */

import Video from './video-player';
import { mediaUploadSync, requestImageFailedRetryDialog, requestImageUploadCancelDialog } from 'react-native-gutenberg-bridge';
/**
 * WordPress dependencies
 */

import { Icon, Toolbar, ToolbarButton } from '@wordpress/components';
import { Caption, MediaPlaceholder, MediaUpload, MEDIA_TYPE_VIDEO, BlockControls, InspectorControls } from '@wordpress/block-editor';
import { __ } from '@wordpress/i18n';
import { isURL } from '@wordpress/url';
import { doAction, hasAction } from '@wordpress/hooks';
/**
 * Internal dependencies
 */

import MediaUploadProgress from '../image/media-upload-progress';
import style from './style.scss';
import SvgIcon from './icon';
import SvgIconRetry from './icon-retry';
var VIDEO_ASPECT_RATIO = 1.7;

var VideoEdit =
/*#__PURE__*/
function (_React$Component) {
  _inherits(VideoEdit, _React$Component);

  function VideoEdit(props) {
    var _this;

    _classCallCheck(this, VideoEdit);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VideoEdit).call(this, props));
    _this.state = {
      isCaptionSelected: false,
      showSettings: false,
      videoContainerHeight: 0
    };
    _this.mediaUploadStateReset = _this.mediaUploadStateReset.bind(_assertThisInitialized(_this));
    _this.onSelectMediaUploadOption = _this.onSelectMediaUploadOption.bind(_assertThisInitialized(_this));
    _this.finishMediaUploadWithSuccess = _this.finishMediaUploadWithSuccess.bind(_assertThisInitialized(_this));
    _this.finishMediaUploadWithFailure = _this.finishMediaUploadWithFailure.bind(_assertThisInitialized(_this));
    _this.updateMediaProgress = _this.updateMediaProgress.bind(_assertThisInitialized(_this));
    _this.onVideoPressed = _this.onVideoPressed.bind(_assertThisInitialized(_this));
    _this.onVideoContanerLayout = _this.onVideoContanerLayout.bind(_assertThisInitialized(_this));
    _this.onFocusCaption = _this.onFocusCaption.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(VideoEdit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var attributes = this.props.attributes;

      if (attributes.id && !isURL(attributes.src)) {
        mediaUploadSync();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // this action will only exist if the user pressed the trash button on the block holder
      if (hasAction('blocks.onRemoveBlockCheckUpload') && this.state.isUploadInProgress) {
        doAction('blocks.onRemoveBlockCheckUpload', this.props.attributes.id);
      }
    }
  }, {
    key: "onVideoPressed",
    value: function onVideoPressed() {
      var attributes = this.props.attributes;

      if (this.state.isUploadInProgress) {
        requestImageUploadCancelDialog(attributes.id);
      } else if (attributes.id && !isURL(attributes.src)) {
        requestImageFailedRetryDialog(attributes.id);
      }

      this.setState({
        isCaptionSelected: false
      });
    }
  }, {
    key: "onFocusCaption",
    value: function onFocusCaption() {
      if (!this.state.isCaptionSelected) {
        this.setState({
          isCaptionSelected: true
        });
      }
    }
  }, {
    key: "updateMediaProgress",
    value: function updateMediaProgress(payload) {
      var setAttributes = this.props.setAttributes;

      if (payload.mediaUrl) {
        setAttributes({
          url: payload.mediaUrl
        });
      }

      if (!this.state.isUploadInProgress) {
        this.setState({
          isUploadInProgress: true
        });
      }
    }
  }, {
    key: "finishMediaUploadWithSuccess",
    value: function finishMediaUploadWithSuccess(payload) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        src: payload.mediaUrl,
        id: payload.mediaServerId
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "finishMediaUploadWithFailure",
    value: function finishMediaUploadWithFailure(payload) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        id: payload.mediaId
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "mediaUploadStateReset",
    value: function mediaUploadStateReset() {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        id: null,
        src: null
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "onSelectMediaUploadOption",
    value: function onSelectMediaUploadOption(mediaId, mediaUrl) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        id: mediaId,
        src: mediaUrl
      });
    }
  }, {
    key: "onVideoContanerLayout",
    value: function onVideoContanerLayout(event) {
      var width = event.nativeEvent.layout.width;
      var height = width / VIDEO_ASPECT_RATIO;

      if (height !== this.state.videoContainerHeight) {
        this.setState({
          videoContainerHeight: height
        });
      }
    }
  }, {
    key: "getIcon",
    value: function getIcon(isRetryIcon, isMediaPlaceholder) {
      if (isRetryIcon) {
        return createElement(Icon, _extends({
          icon: SvgIconRetry
        }, style.icon));
      }

      return createElement(Icon, _extends({
        icon: SvgIcon
      }, !isMediaPlaceholder ? style.iconUploading : style.icon));
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          attributes = _this$props.attributes,
          isSelected = _this$props.isSelected;
      var id = attributes.id,
          src = attributes.src;
      var videoContainerHeight = this.state.videoContainerHeight;
      var toolbarEditButton = createElement(MediaUpload, {
        mediaType: MEDIA_TYPE_VIDEO,
        onSelectURL: this.onSelectMediaUploadOption,
        render: function render(_ref) {
          var open = _ref.open,
              getMediaOptions = _ref.getMediaOptions;
          return createElement(Toolbar, null, getMediaOptions(), createElement(ToolbarButton, {
            label: __('Edit video'),
            icon: "edit",
            onClick: open
          }));
        }
      });

      if (!id) {
        return createElement(View, {
          style: {
            flex: 1
          }
        }, createElement(MediaPlaceholder, {
          mediaType: MEDIA_TYPE_VIDEO,
          onSelectURL: this.onSelectMediaUploadOption,
          icon: this.getIcon(false, true),
          onFocus: this.props.onFocus
        }));
      }

      return createElement(TouchableWithoutFeedback, {
        onPress: this.onVideoPressed,
        disabled: !isSelected
      }, createElement(View, {
        style: {
          flex: 1
        }
      }, !this.state.isCaptionSelected && createElement(BlockControls, null, toolbarEditButton), createElement(InspectorControls, null, false && createElement(ToolbarButton //Not rendering settings button until it has an action
      , {
        label: __('Video Settings'),
        icon: "admin-generic",
        onClick: function onClick() {
          return null;
        }
      })), createElement(MediaUploadProgress, {
        mediaId: id,
        onFinishMediaUploadWithSuccess: this.finishMediaUploadWithSuccess,
        onFinishMediaUploadWithFailure: this.finishMediaUploadWithFailure,
        onUpdateMediaProgress: this.updateMediaProgress,
        onMediaUploadStateReset: this.mediaUploadStateReset,
        renderContent: function renderContent(_ref2) {
          var isUploadInProgress = _ref2.isUploadInProgress,
              isUploadFailed = _ref2.isUploadFailed,
              retryMessage = _ref2.retryMessage;
          var showVideo = isURL(src) && !isUploadInProgress && !isUploadFailed;

          var icon = _this2.getIcon(isUploadFailed, false);

          var styleIconContainer = isUploadFailed ? style.modalIconRetry : style.modalIcon;
          var iconContainer = createElement(View, {
            style: styleIconContainer
          }, icon);

          var videoStyle = _objectSpread({
            height: videoContainerHeight
          }, style.video);

          var containerStyle = showVideo && isSelected ? style.containerFocused : style.container;
          return createElement(View, {
            onLayout: _this2.onVideoContanerLayout,
            style: containerStyle
          }, showVideo && createElement(View, {
            style: style.videoContainer
          }, createElement(Video, {
            isSelected: isSelected && !_this2.state.isCaptionSelected,
            style: videoStyle,
            source: {
              uri: src
            },
            paused: true
          })), !showVideo && createElement(View, {
            style: _objectSpread({
              height: videoContainerHeight,
              width: '100%'
            }, style.placeholder)
          }, videoContainerHeight > 0 && iconContainer, isUploadFailed && createElement(Text, {
            style: style.uploadFailedText
          }, retryMessage)));
        }
      }), createElement(Caption, {
        clientId: this.props.clientId,
        isSelected: this.state.isCaptionSelected,
        onFocus: this.onFocusCaption,
        onBlur: this.props.onBlur // always assign onBlur as props

      })));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      // Avoid a UI flicker in the toolbar by insuring that isCaptionSelected
      // is updated immediately any time the isSelected prop becomes false
      return {
        isCaptionSelected: props.isSelected && state.isCaptionSelected
      };
    }
  }]);

  return VideoEdit;
}(React.Component);

export default VideoEdit;
//# sourceMappingURL=edit.native.js.map