"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classnames2 = _interopRequireDefault(require("classnames"));

var _fastAverageColor = _interopRequireDefault(require("fast-average-color"));

var _tinycolor = _interopRequireDefault(require("tinycolor2"));

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _blockEditor = require("@wordpress/block-editor");

var _i18n = require("@wordpress/i18n");

var _data = require("@wordpress/data");

var _icon = _interopRequireDefault(require("./icon"));

var _shared = require("./shared");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Module Constants
 */
var ALLOWED_MEDIA_TYPES = ['image', 'video'];
var INNER_BLOCKS_TEMPLATE = [['core/paragraph', {
  align: 'center',
  fontSize: 'large',
  placeholder: (0, _i18n.__)('Write titleâ€¦')
}]];

function retrieveFastAverageColor() {
  if (!retrieveFastAverageColor.fastAverageColor) {
    retrieveFastAverageColor.fastAverageColor = new _fastAverageColor.default();
  }

  return retrieveFastAverageColor.fastAverageColor;
}

var CoverHeightInput = (0, _compose.withInstanceId)(function (_ref) {
  var _ref$value = _ref.value,
      value = _ref$value === void 0 ? '' : _ref$value,
      instanceId = _ref.instanceId,
      onChange = _ref.onChange;

  var _useState = (0, _element.useState)(null),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      temporaryInput = _useState2[0],
      setTemporaryInput = _useState2[1];

  var onChangeEvent = (0, _element.useCallback)(function (event) {
    var unprocessedValue = event.target.value;
    var inputValue = unprocessedValue !== '' ? parseInt(event.target.value, 10) : undefined;

    if ((isNaN(inputValue) || inputValue < _shared.COVER_MIN_HEIGHT) && inputValue !== undefined) {
      setTemporaryInput(event.target.value);
      return;
    }

    setTemporaryInput(null);
    onChange(inputValue);
  }, [onChange, setTemporaryInput]);
  var onBlurEvent = (0, _element.useCallback)(function () {
    if (temporaryInput !== null) {
      setTemporaryInput(null);
    }
  }, [temporaryInput, setTemporaryInput]);
  var inputId = "block-cover-height-input-".concat(instanceId);
  return (0, _element.createElement)(_components.BaseControl, {
    label: (0, _i18n.__)('Minimum height in pixels'),
    id: inputId
  }, (0, _element.createElement)("input", {
    type: "number",
    id: inputId,
    onChange: onChangeEvent,
    onBlur: onBlurEvent,
    value: temporaryInput !== null ? temporaryInput : value,
    min: _shared.COVER_MIN_HEIGHT,
    step: "10"
  }));
});
var RESIZABLE_BOX_ENABLE_OPTION = {
  top: false,
  right: false,
  bottom: true,
  left: false,
  topRight: false,
  bottomRight: false,
  bottomLeft: false,
  topLeft: false
};

function ResizableCover(_ref2) {
  var className = _ref2.className,
      children = _ref2.children,
      onResizeStart = _ref2.onResizeStart,
      onResize = _ref2.onResize,
      onResizeStop = _ref2.onResizeStop;

  var _useState3 = (0, _element.useState)(false),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      isResizing = _useState4[0],
      setIsResizing = _useState4[1];

  var onResizeEvent = (0, _element.useCallback)(function (event, direction, elt) {
    onResize(elt.clientHeight);

    if (!isResizing) {
      setIsResizing(true);
    }
  }, [onResize, setIsResizing]);
  var onResizeStartEvent = (0, _element.useCallback)(function (event, direction, elt) {
    onResizeStart(elt.clientHeight);
    onResize(elt.clientHeight);
  }, [onResizeStart, onResize]);
  var onResizeStopEvent = (0, _element.useCallback)(function (event, direction, elt) {
    onResizeStop(elt.clientHeight);
    setIsResizing(false);
  }, [onResizeStop, setIsResizing]);
  return (0, _element.createElement)(_components.ResizableBox, {
    className: (0, _classnames2.default)(className, {
      'is-resizing': isResizing
    }),
    enable: RESIZABLE_BOX_ENABLE_OPTION,
    onResizeStart: onResizeStartEvent,
    onResize: onResizeEvent,
    onResizeStop: onResizeStopEvent,
    minHeight: _shared.COVER_MIN_HEIGHT
  }, children);
}

var CoverEdit =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(CoverEdit, _Component);

  function CoverEdit() {
    var _this;

    (0, _classCallCheck2.default)(this, CoverEdit);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CoverEdit).apply(this, arguments));
    _this.state = {
      isDark: false,
      temporaryMinHeight: null
    };
    _this.imageRef = (0, _element.createRef)();
    _this.videoRef = (0, _element.createRef)();
    _this.changeIsDarkIfRequired = _this.changeIsDarkIfRequired.bind((0, _assertThisInitialized2.default)(_this));
    _this.onUploadError = _this.onUploadError.bind((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(CoverEdit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.handleBackgroundMode();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this.handleBackgroundMode(prevProps);
    }
  }, {
    key: "onUploadError",
    value: function onUploadError(message) {
      var noticeOperations = this.props.noticeOperations;
      noticeOperations.removeAllNotices();
      noticeOperations.createErrorNotice(message);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          attributes = _this$props.attributes,
          setAttributes = _this$props.setAttributes,
          isSelected = _this$props.isSelected,
          className = _this$props.className,
          noticeUI = _this$props.noticeUI,
          overlayColor = _this$props.overlayColor,
          setOverlayColor = _this$props.setOverlayColor,
          toggleSelection = _this$props.toggleSelection;
      var backgroundType = attributes.backgroundType,
          dimRatio = attributes.dimRatio,
          focalPoint = attributes.focalPoint,
          hasParallax = attributes.hasParallax,
          id = attributes.id,
          url = attributes.url,
          minHeight = attributes.minHeight;

      var onSelectMedia = function onSelectMedia(media) {
        if (!media || !media.url) {
          setAttributes({
            url: undefined,
            id: undefined
          });
          return;
        }

        var mediaType; // for media selections originated from a file upload.

        if (media.media_type) {
          if (media.media_type === _shared.IMAGE_BACKGROUND_TYPE) {
            mediaType = _shared.IMAGE_BACKGROUND_TYPE;
          } else {
            // only images and videos are accepted so if the media_type is not an image we can assume it is a video.
            // Videos contain the media type of 'file' in the object returned from the rest api.
            mediaType = _shared.VIDEO_BACKGROUND_TYPE;
          }
        } else {
          // for media selections originated from existing files in the media library.
          if (media.type !== _shared.IMAGE_BACKGROUND_TYPE && media.type !== _shared.VIDEO_BACKGROUND_TYPE) {
            return;
          }

          mediaType = media.type;
        }

        setAttributes((0, _objectSpread2.default)({
          url: media.url,
          id: media.id,
          backgroundType: mediaType
        }, mediaType === _shared.VIDEO_BACKGROUND_TYPE ? {
          focalPoint: undefined,
          hasParallax: undefined
        } : {}));
      };

      var toggleParallax = function toggleParallax() {
        setAttributes((0, _objectSpread2.default)({
          hasParallax: !hasParallax
        }, !hasParallax ? {
          focalPoint: undefined
        } : {}));
      };

      var setDimRatio = function setDimRatio(ratio) {
        return setAttributes({
          dimRatio: ratio
        });
      };

      var temporaryMinHeight = this.state.temporaryMinHeight;
      var style = (0, _objectSpread2.default)({}, backgroundType === _shared.IMAGE_BACKGROUND_TYPE ? (0, _shared.backgroundImageStyles)(url) : {}, {
        backgroundColor: overlayColor.color,
        minHeight: temporaryMinHeight || minHeight
      });

      if (focalPoint) {
        style.backgroundPosition = "".concat(focalPoint.x * 100, "% ").concat(focalPoint.y * 100, "%");
      }

      var controls = (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.BlockControls, null, !!(url || overlayColor.color) && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.MediaUploadCheck, null, (0, _element.createElement)(_components.Toolbar, null, (0, _element.createElement)(_blockEditor.MediaUpload, {
        onSelect: onSelectMedia,
        allowedTypes: ALLOWED_MEDIA_TYPES,
        value: id,
        render: function render(_ref3) {
          var open = _ref3.open;
          return (0, _element.createElement)(_components.IconButton, {
            className: "components-toolbar__control",
            label: (0, _i18n.__)('Edit media'),
            icon: "edit",
            onClick: open
          });
        }
      }))))), (0, _element.createElement)(_blockEditor.InspectorControls, null, !!url && (0, _element.createElement)(_components.PanelBody, {
        title: (0, _i18n.__)('Media Settings')
      }, _shared.IMAGE_BACKGROUND_TYPE === backgroundType && (0, _element.createElement)(_components.ToggleControl, {
        label: (0, _i18n.__)('Fixed Background'),
        checked: hasParallax,
        onChange: toggleParallax
      }), _shared.IMAGE_BACKGROUND_TYPE === backgroundType && !hasParallax && (0, _element.createElement)(_components.FocalPointPicker, {
        label: (0, _i18n.__)('Focal Point Picker'),
        url: url,
        value: focalPoint,
        onChange: function onChange(value) {
          return setAttributes({
            focalPoint: value
          });
        }
      }), (0, _element.createElement)(_components.PanelRow, null, (0, _element.createElement)(_components.Button, {
        isDefault: true,
        isSmall: true,
        className: "block-library-cover__reset-button",
        onClick: function onClick() {
          return setAttributes({
            url: undefined,
            id: undefined,
            backgroundType: undefined,
            dimRatio: undefined,
            focalPoint: undefined,
            hasParallax: undefined
          });
        }
      }, (0, _i18n.__)('Clear Media')))), (url || overlayColor.color) && (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.PanelBody, {
        title: (0, _i18n.__)('Dimensions')
      }, (0, _element.createElement)(CoverHeightInput, {
        value: temporaryMinHeight || minHeight,
        onChange: function onChange(value) {
          setAttributes({
            minHeight: value
          });
        }
      })), (0, _element.createElement)(_blockEditor.PanelColorSettings, {
        title: (0, _i18n.__)('Overlay'),
        initialOpen: true,
        colorSettings: [{
          value: overlayColor.color,
          onChange: setOverlayColor,
          label: (0, _i18n.__)('Overlay Color')
        }]
      }, !!url && (0, _element.createElement)(_components.RangeControl, {
        label: (0, _i18n.__)('Background Opacity'),
        value: dimRatio,
        onChange: setDimRatio,
        min: 0,
        max: 100,
        step: 10,
        required: true
      })))));

      if (!(url || overlayColor.color)) {
        var placeholderIcon = (0, _element.createElement)(_blockEditor.BlockIcon, {
          icon: _icon.default
        });
        var label = (0, _i18n.__)('Cover');
        return (0, _element.createElement)(_element.Fragment, null, controls, (0, _element.createElement)(_blockEditor.MediaPlaceholder, {
          icon: placeholderIcon,
          className: className,
          labels: {
            title: label,
            instructions: (0, _i18n.__)('Upload an image or video file, or pick one from your media library.')
          },
          onSelect: onSelectMedia,
          accept: "image/*,video/*",
          allowedTypes: ALLOWED_MEDIA_TYPES,
          notices: noticeUI,
          onError: this.onUploadError
        }, (0, _element.createElement)(_blockEditor.ColorPalette, {
          disableCustomColors: true,
          value: overlayColor.color,
          onChange: setOverlayColor,
          clearable: false,
          className: "wp-block-cover__placeholder-color-palette"
        })));
      }

      var classes = (0, _classnames2.default)(className, (0, _shared.dimRatioToClass)(dimRatio), (0, _defineProperty2.default)({
        'is-dark-theme': this.state.isDark,
        'has-background-dim': dimRatio !== 0,
        'has-parallax': hasParallax
      }, overlayColor.class, overlayColor.class));
      return (0, _element.createElement)(_element.Fragment, null, controls, (0, _element.createElement)(ResizableCover, {
        className: (0, _classnames2.default)('block-library-cover__resize-container', {
          'is-selected': isSelected
        }),
        onResizeStart: function onResizeStart() {
          return toggleSelection(false);
        },
        onResize: function onResize(newMinHeight) {
          _this2.setState({
            temporaryMinHeight: newMinHeight
          });
        },
        onResizeStop: function onResizeStop(newMinHeight) {
          toggleSelection(true);
          setAttributes({
            minHeight: newMinHeight
          });

          _this2.setState({
            temporaryMinHeight: null
          });
        }
      }, (0, _element.createElement)("div", {
        "data-url": url,
        style: style,
        className: classes
      }, _shared.IMAGE_BACKGROUND_TYPE === backgroundType && // Used only to programmatically check if the image is dark or not
      (0, _element.createElement)("img", {
        ref: this.imageRef,
        "aria-hidden": true,
        alt: "",
        style: {
          display: 'none'
        },
        src: url
      }), _shared.VIDEO_BACKGROUND_TYPE === backgroundType && (0, _element.createElement)("video", {
        ref: this.videoRef,
        className: "wp-block-cover__video-background",
        autoPlay: true,
        muted: true,
        loop: true,
        src: url
      }), (0, _element.createElement)("div", {
        className: "wp-block-cover__inner-container"
      }, (0, _element.createElement)(_blockEditor.InnerBlocks, {
        template: INNER_BLOCKS_TEMPLATE
      })))));
    }
  }, {
    key: "handleBackgroundMode",
    value: function handleBackgroundMode(prevProps) {
      var _this3 = this;

      var _this$props2 = this.props,
          attributes = _this$props2.attributes,
          overlayColor = _this$props2.overlayColor;
      var dimRatio = attributes.dimRatio,
          url = attributes.url; // If opacity is greater than 50 the dominant color is the overlay color,
      // so use that color for the dark mode computation.

      if (dimRatio > 50) {
        if (prevProps && prevProps.attributes.dimRatio > 50 && prevProps.overlayColor.color === overlayColor.color) {
          // No relevant prop changes happened there is no need to apply any change.
          return;
        }

        if (!overlayColor.color) {
          // If no overlay color exists the overlay color is black (isDark )
          this.changeIsDarkIfRequired(true);
          return;
        }

        this.changeIsDarkIfRequired((0, _tinycolor.default)(overlayColor.color).isDark());
        return;
      } // If opacity is lower than 50 the dominant color is the image or video color,
      // so use that color for the dark mode computation.


      if (prevProps && prevProps.attributes.dimRatio <= 50 && prevProps.attributes.url === url) {
        // No relevant prop changes happened there is no need to apply any change.
        return;
      }

      var backgroundType = attributes.backgroundType;
      var element;

      switch (backgroundType) {
        case _shared.IMAGE_BACKGROUND_TYPE:
          element = this.imageRef.current;
          break;

        case _shared.VIDEO_BACKGROUND_TYPE:
          element = this.videoRef.current;
          break;
      }

      if (!element) {
        return;
      }

      retrieveFastAverageColor().getColorAsync(element, function (color) {
        _this3.changeIsDarkIfRequired(color.isDark);
      });
    }
  }, {
    key: "changeIsDarkIfRequired",
    value: function changeIsDarkIfRequired(newIsDark) {
      if (this.state.isDark !== newIsDark) {
        this.setState({
          isDark: newIsDark
        });
      }
    }
  }]);
  return CoverEdit;
}(_element.Component);

var _default = (0, _compose.compose)([(0, _data.withDispatch)(function (dispatch) {
  var _dispatch = dispatch('core/block-editor'),
      toggleSelection = _dispatch.toggleSelection;

  return {
    toggleSelection: toggleSelection
  };
}), (0, _blockEditor.withColors)({
  overlayColor: 'background-color'
}), _components.withNotices, _compose.withInstanceId])(CoverEdit);

exports.default = _default;
//# sourceMappingURL=edit.js.map