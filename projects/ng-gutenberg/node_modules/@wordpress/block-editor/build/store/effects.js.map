{"version":3,"sources":["@wordpress/block-editor/src/store/effects.js"],"names":["validateBlocksToTemplate","action","store","state","getState","template","templateLock","isBlocksValidToTemplate","blocks","MERGE_BLOCKS","dispatch","clientIdA","clientIdB","blockA","blockAType","name","merge","clientId","blockB","blockBType","attributeKey","offset","hasTextSelection","undefined","START_OF_SELECTED_AREA","cloneA","cloneB","selectedBlock","html","attributes","selectedBlockType","multilineTag","multiline","multilineWrapperTags","__unstableMultilineWrapperTags","value","blocksWithTheSameType","length","updatedAttributes","newAttributeKey","v","indexOf","convertedHtml","convertedValue","newOffset","text","newValue","newHtml","slice","RESET_BLOCKS","MULTI_SELECT","blockCount","SYNCHRONIZE_TEMPLATE","updatedBlockList"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { findKey } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { speak } from '@wordpress/a11y';\nimport {\n\tgetBlockType,\n\tdoBlocksMatchTemplate,\n\tswitchToBlockType,\n\tsynchronizeBlocksWithTemplate,\n\tcloneBlock,\n} from '@wordpress/blocks';\nimport { _n, sprintf } from '@wordpress/i18n';\nimport { create, toHTMLString, insert, remove } from '@wordpress/rich-text';\n\n/**\n * Internal dependencies\n */\nimport {\n\treplaceBlocks,\n\tselectBlock,\n\tsetTemplateValidity,\n\tresetBlocks,\n\tselectionChange,\n} from './actions';\nimport {\n\tgetBlock,\n\tgetBlocks,\n\tgetSelectedBlockCount,\n\tgetTemplateLock,\n\tgetTemplate,\n\tisValidTemplate,\n\tgetSelectionStart,\n} from './selectors';\n\n/**\n * Block validity is a function of blocks state (at the point of a\n * reset) and the template setting. As a compromise to its placement\n * across distinct parts of state, it is implemented here as a side-\n * effect of the block reset action.\n *\n * @param {Object} action RESET_BLOCKS action.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} New validity set action if validity has changed.\n */\nexport function validateBlocksToTemplate( action, store ) {\n\tconst state = store.getState();\n\tconst template = getTemplate( state );\n\tconst templateLock = getTemplateLock( state );\n\n\t// Unlocked templates are considered always valid because they act\n\t// as default values only.\n\tconst isBlocksValidToTemplate = (\n\t\t! template ||\n\t\ttemplateLock !== 'all' ||\n\t\tdoBlocksMatchTemplate( action.blocks, template )\n\t);\n\n\t// Update if validity has changed.\n\tif ( isBlocksValidToTemplate !== isValidTemplate( state ) ) {\n\t\treturn setTemplateValidity( isBlocksValidToTemplate );\n\t}\n}\n\nexport default {\n\tMERGE_BLOCKS( action, store ) {\n\t\tconst { dispatch } = store;\n\t\tconst state = store.getState();\n\t\tconst [ clientIdA, clientIdB ] = action.blocks;\n\t\tconst blockA = getBlock( state, clientIdA );\n\t\tconst blockAType = getBlockType( blockA.name );\n\n\t\t// Only focus the previous block if it's not mergeable\n\t\tif ( ! blockAType.merge ) {\n\t\t\tdispatch( selectBlock( blockA.clientId ) );\n\t\t\treturn;\n\t\t}\n\n\t\tconst blockB = getBlock( state, clientIdB );\n\t\tconst blockBType = getBlockType( blockB.name );\n\t\tconst { clientId, attributeKey, offset } = getSelectionStart( state );\n\t\tconst hasTextSelection = (\n\t\t\t( clientId === clientIdA || clientId === clientIdB ) &&\n\t\t\tattributeKey !== undefined &&\n\t\t\toffset !== undefined\n\t\t);\n\n\t\t// A robust way to retain selection position through various transforms\n\t\t// is to insert a special character at the position and then recover it.\n\t\tconst START_OF_SELECTED_AREA = '\\u0086';\n\n\t\t// Clone the blocks so we don't insert the character in a \"live\" block.\n\t\tconst cloneA = cloneBlock( blockA );\n\t\tconst cloneB = cloneBlock( blockB );\n\n\t\tif ( hasTextSelection ) {\n\t\t\tconst selectedBlock = clientId === clientIdA ? cloneA : cloneB;\n\t\t\tconst html = selectedBlock.attributes[ attributeKey ];\n\t\t\tconst selectedBlockType = clientId === clientIdA ? blockAType : blockBType;\n\t\t\tconst {\n\t\t\t\tmultiline: multilineTag,\n\t\t\t\t__unstableMultilineWrapperTags: multilineWrapperTags,\n\t\t\t} = selectedBlockType.attributes[ attributeKey ];\n\t\t\tconst value = insert( create( {\n\t\t\t\thtml,\n\t\t\t\tmultilineTag,\n\t\t\t\tmultilineWrapperTags,\n\t\t\t} ), START_OF_SELECTED_AREA, offset, offset );\n\n\t\t\tselectedBlock.attributes[ attributeKey ] = toHTMLString( {\n\t\t\t\tvalue,\n\t\t\t\tmultilineTag,\n\t\t\t} );\n\t\t}\n\n\t\t// We can only merge blocks with similar types\n\t\t// thus, we transform the block to merge first\n\t\tconst blocksWithTheSameType = blockA.name === blockB.name ?\n\t\t\t[ cloneB ] :\n\t\t\tswitchToBlockType( cloneB, blockA.name );\n\n\t\t// If the block types can not match, do nothing\n\t\tif ( ! blocksWithTheSameType || ! blocksWithTheSameType.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calling the merge to update the attributes and remove the block to be merged\n\t\tconst updatedAttributes = blockAType.merge(\n\t\t\tcloneA.attributes,\n\t\t\tblocksWithTheSameType[ 0 ].attributes\n\t\t);\n\n\t\tif ( hasTextSelection ) {\n\t\t\tconst newAttributeKey = findKey( updatedAttributes, ( v ) =>\n\t\t\t\ttypeof v === 'string' && v.indexOf( START_OF_SELECTED_AREA ) !== -1\n\t\t\t);\n\t\t\tconst convertedHtml = updatedAttributes[ newAttributeKey ];\n\t\t\tconst {\n\t\t\t\tmultiline: multilineTag,\n\t\t\t\t__unstableMultilineWrapperTags: multilineWrapperTags,\n\t\t\t} = blockAType.attributes[ newAttributeKey ];\n\t\t\tconst convertedValue = create( {\n\t\t\t\thtml: convertedHtml,\n\t\t\t\tmultilineTag,\n\t\t\t\tmultilineWrapperTags,\n\t\t\t} );\n\t\t\tconst newOffset = convertedValue.text.indexOf( START_OF_SELECTED_AREA );\n\t\t\tconst newValue = remove( convertedValue, newOffset, newOffset + 1 );\n\t\t\tconst newHtml = toHTMLString( { value: newValue, multilineTag } );\n\n\t\t\tupdatedAttributes[ newAttributeKey ] = newHtml;\n\n\t\t\tdispatch( selectionChange(\n\t\t\t\tblockA.clientId,\n\t\t\t\tnewAttributeKey,\n\t\t\t\tnewOffset,\n\t\t\t\tnewOffset\n\t\t\t) );\n\t\t}\n\n\t\tdispatch( replaceBlocks(\n\t\t\t[ blockA.clientId, blockB.clientId ],\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t...blockA,\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t...blockA.attributes,\n\t\t\t\t\t\t...updatedAttributes,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...blocksWithTheSameType.slice( 1 ),\n\t\t\t]\n\t\t) );\n\t},\n\tRESET_BLOCKS: [\n\t\tvalidateBlocksToTemplate,\n\t],\n\tMULTI_SELECT: ( action, { getState } ) => {\n\t\tconst blockCount = getSelectedBlockCount( getState() );\n\n\t\t/* translators: %s: number of selected blocks */\n\t\tspeak( sprintf( _n( '%s block selected.', '%s blocks selected.', blockCount ), blockCount ), 'assertive' );\n\t},\n\tSYNCHRONIZE_TEMPLATE( action, { getState } ) {\n\t\tconst state = getState();\n\t\tconst blocks = getBlocks( state );\n\t\tconst template = getTemplate( state );\n\t\tconst updatedBlockList = synchronizeBlocksWithTemplate( blocks, template );\n\n\t\treturn resetBlocks( updatedBlockList );\n\t},\n};\n"]}