"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "RichTextShortcut", {
  enumerable: true,
  get: function get() {
    return _shortcut.RichTextShortcut;
  }
});
Object.defineProperty(exports, "RichTextToolbarButton", {
  enumerable: true,
  get: function get() {
    return _toolbarButton.RichTextToolbarButton;
  }
});
Object.defineProperty(exports, "__unstableRichTextInputEvent", {
  enumerable: true,
  get: function get() {
    return _inputEvent.__unstableRichTextInputEvent;
  }
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _classnames = _interopRequireDefault(require("classnames"));

var _lodash = require("lodash");

var _data = require("@wordpress/data");

var _blocks = require("@wordpress/blocks");

var _compose = require("@wordpress/compose");

var _richText = require("@wordpress/rich-text");

var _components = require("@wordpress/components");

var _blob = require("@wordpress/blob");

var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));

var _url = require("@wordpress/url");

var _autocomplete = _interopRequireDefault(require("../autocomplete"));

var _blockFormatControls = _interopRequireDefault(require("../block-format-controls"));

var _formatToolbar = _interopRequireDefault(require("./format-toolbar"));

var _context = require("../block-edit/context");

var _removeBrowserShortcuts = require("./remove-browser-shortcuts");

var _shortcut = require("./shortcut");

var _toolbarButton = require("./toolbar-button");

var _inputEvent = require("./input-event");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
var requestIdleCallback = window.requestIdleCallback || function fallbackRequestIdleCallback(fn) {
  window.setTimeout(fn, 100);
};

var wrapperClasses = 'editor-rich-text block-editor-rich-text';
var classes = 'editor-rich-text__editable block-editor-rich-text__editable';
/**
 * Get the multiline tag based on the multiline prop.
 *
 * @param {?(string|boolean)} multiline The multiline prop.
 *
 * @return {?string} The multiline tag.
 */

function getMultilineTag(multiline) {
  if (multiline !== true && multiline !== 'p' && multiline !== 'li') {
    return;
  }

  return multiline === true ? 'p' : multiline;
}

var RichTextWrapper =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(RichTextWrapper, _Component);

  function RichTextWrapper() {
    var _this;

    (0, _classCallCheck2.default)(this, RichTextWrapper);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(RichTextWrapper).apply(this, arguments));
    _this.onEnter = _this.onEnter.bind((0, _assertThisInitialized2.default)(_this));
    _this.onSplit = _this.onSplit.bind((0, _assertThisInitialized2.default)(_this));
    _this.onPaste = _this.onPaste.bind((0, _assertThisInitialized2.default)(_this));
    _this.onDelete = _this.onDelete.bind((0, _assertThisInitialized2.default)(_this));
    _this.inputRule = _this.inputRule.bind((0, _assertThisInitialized2.default)(_this));
    _this.markAutomaticChange = _this.markAutomaticChange.bind((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(RichTextWrapper, [{
    key: "onEnter",
    value: function onEnter(_ref) {
      var value = _ref.value,
          onChange = _ref.onChange,
          shiftKey = _ref.shiftKey;
      var _this$props = this.props,
          onReplace = _this$props.onReplace,
          onSplit = _this$props.onSplit,
          multiline = _this$props.multiline;
      var canSplit = onReplace && onSplit;

      if (onReplace) {
        var transforms = (0, _blocks.getBlockTransforms)('from').filter(function (_ref2) {
          var type = _ref2.type;
          return type === 'enter';
        });
        var transformation = (0, _blocks.findTransform)(transforms, function (item) {
          return item.regExp.test(value.text);
        });

        if (transformation) {
          onReplace([transformation.transform({
            content: value.text
          })]);
          this.markAutomaticChange();
        }
      }

      if (multiline) {
        if (shiftKey) {
          onChange((0, _richText.insert)(value, '\n'));
        } else if (canSplit && (0, _richText.__unstableIsEmptyLine)(value)) {
          this.onSplit(value);
        } else {
          onChange((0, _richText.__unstableInsertLineSeparator)(value));
        }
      } else if (shiftKey || !canSplit) {
        onChange((0, _richText.insert)(value, '\n'));
      } else {
        this.onSplit(value);
      }
    }
  }, {
    key: "onDelete",
    value: function onDelete(_ref3) {
      var value = _ref3.value,
          isReverse = _ref3.isReverse;
      var _this$props2 = this.props,
          onMerge = _this$props2.onMerge,
          onRemove = _this$props2.onRemove;

      if (onMerge) {
        onMerge(!isReverse);
      } // Only handle remove on Backspace. This serves dual-purpose of being
      // an intentional user interaction distinguishing between Backspace and
      // Delete to remove the empty field, but also to avoid merge & remove
      // causing destruction of two fields (merge, then removed merged).


      if (onRemove && (0, _richText.isEmpty)(value) && isReverse) {
        onRemove(!isReverse);
      }
    }
  }, {
    key: "onPaste",
    value: function onPaste(_ref4) {
      var value = _ref4.value,
          onChange = _ref4.onChange,
          html = _ref4.html,
          plainText = _ref4.plainText,
          image = _ref4.image;
      var _this$props3 = this.props,
          onReplace = _this$props3.onReplace,
          onSplit = _this$props3.onSplit,
          tagName = _this$props3.tagName,
          canUserUseUnfilteredHTML = _this$props3.canUserUseUnfilteredHTML,
          multiline = _this$props3.multiline,
          __unstableEmbedURLOnPaste = _this$props3.__unstableEmbedURLOnPaste;

      if (image && !html) {
        var file = image.getAsFile ? image.getAsFile() : image;

        var _content = (0, _blocks.pasteHandler)({
          HTML: "<img src=\"".concat((0, _blob.createBlobURL)(file), "\">"),
          mode: 'BLOCKS',
          tagName: tagName
        }); // Allows us to ask for this information when we get a report.


        window.console.log('Received item:\n\n', file);

        if (onReplace && (0, _richText.isEmpty)(value)) {
          onReplace(_content);
        } else {
          this.onSplit(value, _content);
        }

        return;
      }

      var mode = onReplace && onSplit ? 'AUTO' : 'INLINE';

      if (__unstableEmbedURLOnPaste && (0, _richText.isEmpty)(value) && (0, _url.isURL)(plainText.trim())) {
        mode = 'BLOCKS';
      }

      var content = (0, _blocks.pasteHandler)({
        HTML: html,
        plainText: plainText,
        mode: mode,
        tagName: tagName,
        canUserUseUnfilteredHTML: canUserUseUnfilteredHTML
      });

      if (typeof content === 'string') {
        var valueToInsert = (0, _richText.create)({
          html: content
        }); // If the content should be multiline, we should process text
        // separated by a line break as separate lines.

        if (multiline) {
          valueToInsert = (0, _richText.replace)(valueToInsert, /\n+/g, _richText.__UNSTABLE_LINE_SEPARATOR);
        }

        onChange((0, _richText.insert)(value, valueToInsert));
      } else if (content.length > 0) {
        if (onReplace && (0, _richText.isEmpty)(value)) {
          onReplace(content);
        } else {
          this.onSplit(value, content);
        }
      }
    }
    /**
     * Signals to the RichText owner that the block can be replaced with two
     * blocks as a result of splitting the block by pressing enter, or with
     * blocks as a result of splitting the block by pasting block content in the
     * instance.
     *
     * @param  {Object} record       The rich text value to split.
     * @param  {Array}  pastedBlocks The pasted blocks to insert, if any.
     */

  }, {
    key: "onSplit",
    value: function onSplit(record) {
      var pastedBlocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var _this$props4 = this.props,
          onReplace = _this$props4.onReplace,
          onSplit = _this$props4.onSplit,
          onSplitMiddle = _this$props4.__unstableOnSplitMiddle,
          multiline = _this$props4.multiline;

      if (!onReplace || !onSplit) {
        return;
      }

      var blocks = [];

      var _split = (0, _richText.split)(record),
          _split2 = (0, _slicedToArray2.default)(_split, 2),
          before = _split2[0],
          after = _split2[1];

      var hasPastedBlocks = pastedBlocks.length > 0;
      var multilineTag = getMultilineTag(multiline); // Create a block with the content before the caret if there's no pasted
      // blocks, or if there are pasted blocks and the value is not empty.
      // We do not want a leading empty block on paste, but we do if split
      // with e.g. the enter key.

      if (!hasPastedBlocks || !(0, _richText.isEmpty)(before)) {
        blocks.push(onSplit((0, _richText.toHTMLString)({
          value: before,
          multilineTag: multilineTag
        })));
      }

      if (hasPastedBlocks) {
        blocks.push.apply(blocks, (0, _toConsumableArray2.default)(pastedBlocks));
      } else if (onSplitMiddle) {
        blocks.push(onSplitMiddle());
      } // If there's pasted blocks, append a block with the content after the
      // caret. Otherwise, do append and empty block if there is no
      // `onSplitMiddle` prop, but if there is and the content is empty, the
      // middle block is enough to set focus in.


      if (hasPastedBlocks || !onSplitMiddle || !(0, _richText.isEmpty)(after)) {
        blocks.push(onSplit((0, _richText.toHTMLString)({
          value: after,
          multilineTag: multilineTag
        })));
      } // If there are pasted blocks, set the selection to the last one.
      // Otherwise, set the selection to the second block.


      var indexToSelect = hasPastedBlocks ? blocks.length - 1 : 1;
      onReplace(blocks, indexToSelect);
    }
  }, {
    key: "inputRule",
    value: function inputRule(value, valueToFormat) {
      var onReplace = this.props.onReplace;

      if (!onReplace) {
        return;
      }

      var start = value.start,
          text = value.text;
      var characterBefore = text.slice(start - 1, start); // The character right before the caret must be a plain space.

      if (characterBefore !== ' ') {
        return;
      }

      var trimmedTextBefore = text.slice(0, start).trim();
      var prefixTransforms = (0, _blocks.getBlockTransforms)('from').filter(function (_ref5) {
        var type = _ref5.type;
        return type === 'prefix';
      });
      var transformation = (0, _blocks.findTransform)(prefixTransforms, function (_ref6) {
        var prefix = _ref6.prefix;
        return trimmedTextBefore === prefix;
      });

      if (!transformation) {
        return;
      }

      var content = valueToFormat((0, _richText.slice)(value, start, text.length));
      var block = transformation.transform(content);
      onReplace([block]);
      this.markAutomaticChange();
    }
  }, {
    key: "getAllowedFormats",
    value: function getAllowedFormats() {
      var _this$props5 = this.props,
          allowedFormats = _this$props5.allowedFormats,
          formattingControls = _this$props5.formattingControls;

      if (!allowedFormats && !formattingControls) {
        return;
      }

      if (allowedFormats) {
        return allowedFormats;
      }

      (0, _deprecated.default)('wp.blockEditor.RichText formattingControls prop', {
        alternative: 'allowedFormats'
      });
      return formattingControls.map(function (name) {
        return "core/".concat(name);
      });
    }
    /**
     * Marks the last change as an automatic change at the next idle period to
     * ensure all selection changes have been recorded.
     */

  }, {
    key: "markAutomaticChange",
    value: function markAutomaticChange() {
      var _this2 = this;

      requestIdleCallback(function () {
        _this2.props.markAutomaticChange();
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props,
          children = _this$props6.children,
          tagName = _this$props6.tagName,
          originalValue = _this$props6.value,
          originalOnChange = _this$props6.onChange,
          selectionStart = _this$props6.selectionStart,
          selectionEnd = _this$props6.selectionEnd,
          onSelectionChange = _this$props6.onSelectionChange,
          multiline = _this$props6.multiline,
          inlineToolbar = _this$props6.inlineToolbar,
          wrapperClassName = _this$props6.wrapperClassName,
          className = _this$props6.className,
          autocompleters = _this$props6.autocompleters,
          onReplace = _this$props6.onReplace,
          isCaretWithinFormattedText = _this$props6.isCaretWithinFormattedText,
          onEnterFormattedText = _this$props6.onEnterFormattedText,
          onExitFormattedText = _this$props6.onExitFormattedText,
          originalIsSelected = _this$props6.isSelected,
          onCreateUndoLevel = _this$props6.onCreateUndoLevel,
          markAutomaticChange = _this$props6.markAutomaticChange,
          didAutomaticChange = _this$props6.didAutomaticChange,
          undo = _this$props6.undo,
          placeholder = _this$props6.placeholder,
          keepPlaceholderOnFocus = _this$props6.keepPlaceholderOnFocus,
          allowedFormats = _this$props6.allowedFormats,
          withoutInteractiveFormatting = _this$props6.withoutInteractiveFormatting,
          onRemove = _this$props6.onRemove,
          onMerge = _this$props6.onMerge,
          onSplit = _this$props6.onSplit,
          canUserUseUnfilteredHTML = _this$props6.canUserUseUnfilteredHTML,
          clientId = _this$props6.clientId,
          identifier = _this$props6.identifier,
          instanceId = _this$props6.instanceId,
          start = _this$props6.start,
          reversed = _this$props6.reversed,
          experimentalProps = (0, _objectWithoutProperties2.default)(_this$props6, ["children", "tagName", "value", "onChange", "selectionStart", "selectionEnd", "onSelectionChange", "multiline", "inlineToolbar", "wrapperClassName", "className", "autocompleters", "onReplace", "isCaretWithinFormattedText", "onEnterFormattedText", "onExitFormattedText", "isSelected", "onCreateUndoLevel", "markAutomaticChange", "didAutomaticChange", "undo", "placeholder", "keepPlaceholderOnFocus", "allowedFormats", "withoutInteractiveFormatting", "onRemove", "onMerge", "onSplit", "canUserUseUnfilteredHTML", "clientId", "identifier", "instanceId", "start", "reversed"]);
      var multilineTag = getMultilineTag(multiline);
      var adjustedAllowedFormats = this.getAllowedFormats();
      var hasFormats = !adjustedAllowedFormats || adjustedAllowedFormats.length > 0;
      var adjustedValue = originalValue;
      var adjustedOnChange = originalOnChange; // Handle deprecated format.

      if (Array.isArray(originalValue)) {
        adjustedValue = _blocks.children.toHTML(originalValue);

        adjustedOnChange = function adjustedOnChange(newValue) {
          return originalOnChange(_blocks.children.fromDOM((0, _richText.__unstableCreateElement)(document, newValue).childNodes));
        };
      }

      var content = (0, _element.createElement)(_richText.__experimentalRichText, (0, _extends2.default)({}, experimentalProps, {
        value: adjustedValue,
        onChange: adjustedOnChange,
        selectionStart: selectionStart,
        selectionEnd: selectionEnd,
        onSelectionChange: onSelectionChange,
        tagName: tagName,
        className: (0, _classnames.default)(classes, className, {
          'is-selected': originalIsSelected,
          'keep-placeholder-on-focus': keepPlaceholderOnFocus
        }),
        placeholder: placeholder,
        allowedFormats: adjustedAllowedFormats,
        withoutInteractiveFormatting: withoutInteractiveFormatting,
        onEnter: this.onEnter,
        onDelete: this.onDelete,
        onPaste: this.onPaste,
        __unstableIsSelected: originalIsSelected,
        __unstableInputRule: this.inputRule,
        __unstableMultilineTag: multilineTag,
        __unstableIsCaretWithinFormattedText: isCaretWithinFormattedText,
        __unstableOnEnterFormattedText: onEnterFormattedText,
        __unstableOnExitFormattedText: onExitFormattedText,
        __unstableOnCreateUndoLevel: onCreateUndoLevel,
        __unstableMarkAutomaticChange: this.markAutomaticChange,
        __unstableDidAutomaticChange: didAutomaticChange,
        __unstableUndo: undo
      }), function (_ref7) {
        var isSelected = _ref7.isSelected,
            value = _ref7.value,
            onChange = _ref7.onChange,
            Editable = _ref7.Editable;
        return (0, _element.createElement)(_element.Fragment, null, children && children({
          value: value,
          onChange: onChange
        }), isSelected && !inlineToolbar && hasFormats && (0, _element.createElement)(_blockFormatControls.default, null, (0, _element.createElement)(_formatToolbar.default, null)), isSelected && inlineToolbar && hasFormats && (0, _element.createElement)(_components.IsolatedEventContainer, {
          className: "editor-rich-text__inline-toolbar block-editor-rich-text__inline-toolbar"
        }, (0, _element.createElement)(_formatToolbar.default, null)), isSelected && (0, _element.createElement)(_removeBrowserShortcuts.RemoveBrowserShortcuts, null), (0, _element.createElement)(_autocomplete.default, {
          onReplace: onReplace,
          completers: autocompleters,
          record: value,
          onChange: onChange,
          isSelected: isSelected
        }, function (_ref8) {
          var listBoxId = _ref8.listBoxId,
              activeId = _ref8.activeId,
              onKeyDown = _ref8.onKeyDown;
          return (0, _element.createElement)(Editable, {
            "aria-autocomplete": listBoxId ? 'list' : undefined,
            "aria-owns": listBoxId,
            "aria-activedescendant": activeId,
            start: start,
            reversed: reversed,
            onKeyDown: onKeyDown
          });
        }));
      });
      return (0, _element.createElement)("div", {
        className: (0, _classnames.default)(wrapperClasses, wrapperClassName)
      }, content);
    }
  }]);
  return RichTextWrapper;
}(_element.Component);

var RichTextContainer = (0, _compose.compose)([_compose.withInstanceId, (0, _context.withBlockEditContext)(function (_ref9) {
  var clientId = _ref9.clientId;
  return {
    clientId: clientId
  };
}), (0, _data.withSelect)(function (select, _ref10) {
  var clientId = _ref10.clientId,
      instanceId = _ref10.instanceId,
      _ref10$identifier = _ref10.identifier,
      identifier = _ref10$identifier === void 0 ? instanceId : _ref10$identifier,
      isSelected = _ref10.isSelected;

  var _select = select('core/block-editor'),
      isCaretWithinFormattedText = _select.isCaretWithinFormattedText,
      getSelectionStart = _select.getSelectionStart,
      getSelectionEnd = _select.getSelectionEnd,
      getSettings = _select.getSettings,
      didAutomaticChange = _select.didAutomaticChange;

  var selectionStart = getSelectionStart();
  var selectionEnd = getSelectionEnd();

  var _getSettings = getSettings(),
      __experimentalCanUserUseUnfilteredHTML = _getSettings.__experimentalCanUserUseUnfilteredHTML;

  if (isSelected === undefined) {
    isSelected = selectionStart.clientId === clientId && selectionStart.attributeKey === identifier;
  } else if (isSelected) {
    isSelected = selectionStart.clientId === clientId;
  }

  return {
    canUserUseUnfilteredHTML: __experimentalCanUserUseUnfilteredHTML,
    isCaretWithinFormattedText: isCaretWithinFormattedText(),
    selectionStart: isSelected ? selectionStart.offset : undefined,
    selectionEnd: isSelected ? selectionEnd.offset : undefined,
    isSelected: isSelected,
    didAutomaticChange: didAutomaticChange()
  };
}), (0, _data.withDispatch)(function (dispatch, _ref11) {
  var clientId = _ref11.clientId,
      instanceId = _ref11.instanceId,
      _ref11$identifier = _ref11.identifier,
      identifier = _ref11$identifier === void 0 ? instanceId : _ref11$identifier;

  var _dispatch = dispatch('core/block-editor'),
      __unstableMarkLastChangeAsPersistent = _dispatch.__unstableMarkLastChangeAsPersistent,
      enterFormattedText = _dispatch.enterFormattedText,
      exitFormattedText = _dispatch.exitFormattedText,
      selectionChange = _dispatch.selectionChange,
      __unstableMarkAutomaticChange = _dispatch.__unstableMarkAutomaticChange;

  var _dispatch2 = dispatch('core/editor'),
      undo = _dispatch2.undo;

  return {
    onCreateUndoLevel: __unstableMarkLastChangeAsPersistent,
    onEnterFormattedText: enterFormattedText,
    onExitFormattedText: exitFormattedText,
    onSelectionChange: function onSelectionChange(start, end) {
      selectionChange(clientId, identifier, start, end);
    },
    markAutomaticChange: __unstableMarkAutomaticChange,
    undo: undo
  };
}), (0, _components.withFilters)('experimentalRichText')])(RichTextWrapper);

RichTextContainer.Content = function (_ref12) {
  var value = _ref12.value,
      Tag = _ref12.tagName,
      multiline = _ref12.multiline,
      props = (0, _objectWithoutProperties2.default)(_ref12, ["value", "tagName", "multiline"]);

  // Handle deprecated `children` and `node` sources.
  if (Array.isArray(value)) {
    value = _blocks.children.toHTML(value);
  }

  var MultilineTag = getMultilineTag(multiline);

  if (!value && MultilineTag) {
    value = "<".concat(MultilineTag, "></").concat(MultilineTag, ">");
  }

  var content = (0, _element.createElement)(_element.RawHTML, null, value);

  if (Tag) {
    return (0, _element.createElement)(Tag, (0, _lodash.omit)(props, ['format']), content);
  }

  return content;
};

RichTextContainer.isEmpty = function (value) {
  return !value || value.length === 0;
};

RichTextContainer.Content.defaultProps = {
  format: 'string',
  value: ''
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/master/packages/block-editor/src/components/rich-text/README.md
 */

var _default = RichTextContainer;
exports.default = _default;
//# sourceMappingURL=index.js.map