{"version":3,"sources":["@wordpress/block-editor/src/components/writing-flow/index.js"],"names":["window","getSelection","getComputedStyle","isTabbableTextField","isTextField","focus","tabbable","isTabbableIndex","isNavigationCandidate","element","keyCode","hasModifier","isVertical","UP","DOWN","tagName","WritingFlow","arguments","onKeyDown","bind","bindContainer","onMouseDown","focusLastTextField","verticalRect","appender","ref","container","disableNavigationMode","props","isNavigationMode","target","isReverse","focusableNodes","focusable","find","slice","indexOf","isTabCandidate","node","i","array","contains","offset","nextNode","selectedBlockClientId","selectionStartClientId","selectionBeforeEndClientId","selectionAfterEndClientId","nextSelectionEndClientId","onMultiSelect","selectedFirstClientId","selectedLastClientId","focusedBlockClientId","onSelectBlock","closestTabbable","getClosestTabbable","event","hasMultiSelection","blocks","isUp","isDown","isLeft","LEFT","isRight","RIGHT","isTab","TAB","isHorizontal","isNav","isShift","shiftKey","ctrlKey","altKey","metaKey","isNavEdge","isVerticalEdge","isHorizontalEdge","navigateUp","navigateDown","focusedBlockUid","preventDefault","clearSelectedBlock","current","isKeyboardEvent","primary","isEntirelySelected","isContentEditable","nativeEvent","defaultPrevented","direction","isReverseDir","isTabbableEdge","expandSelection","moveSelection","isCollapsed","children","Component","select","getSelectedBlockClientId","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getPreviousBlockClientId","getNextBlockClientId","getFirstMultiSelectedBlockClientId","getLastMultiSelectedBlockClientId","getBlockOrder","selectionEndClientId","dispatch","multiSelect","selectBlock","setNavigationMode"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { overEvery, find, findLast, reverse, first, last } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { Component, createRef } from '@wordpress/element';\nimport {\n\tcomputeCaretRect,\n\tfocus,\n\tisHorizontalEdge,\n\tisTextField,\n\tisVerticalEdge,\n\tplaceCaretAtHorizontalEdge,\n\tplaceCaretAtVerticalEdge,\n\tisEntirelySelected,\n} from '@wordpress/dom';\nimport { UP, DOWN, LEFT, RIGHT, TAB, isKeyboardEvent } from '@wordpress/keycodes';\nimport { withSelect, withDispatch } from '@wordpress/data';\nimport { compose } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport {\n\tisBlockFocusStop,\n\tisInSameBlock,\n\thasInnerBlocksContext,\n} from '../../utils/dom';\n\n/**\n * Browser constants\n */\n\nconst { getSelection, getComputedStyle } = window;\n\n/**\n * Given an element, returns true if the element is a tabbable text field, or\n * false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is a tabbable text field.\n */\nconst isTabbableTextField = overEvery( [\n\tisTextField,\n\tfocus.tabbable.isTabbableIndex,\n] );\n\n/**\n * Returns true if the element should consider edge navigation upon a keyboard\n * event of the given directional key code, or false otherwise.\n *\n * @param {Element} element     HTML element to test.\n * @param {number}  keyCode     KeyboardEvent keyCode to test.\n * @param {boolean} hasModifier Whether a modifier is pressed.\n *\n * @return {boolean} Whether element should consider edge navigation.\n */\nexport function isNavigationCandidate( element, keyCode, hasModifier ) {\n\tconst isVertical = ( keyCode === UP || keyCode === DOWN );\n\n\t// Currently, all elements support unmodified vertical navigation.\n\tif ( isVertical && ! hasModifier ) {\n\t\treturn true;\n\t}\n\n\t// Native inputs should not navigate horizontally.\n\tconst { tagName } = element;\n\treturn tagName !== 'INPUT' && tagName !== 'TEXTAREA';\n}\n\nclass WritingFlow extends Component {\n\tconstructor() {\n\t\tsuper( ...arguments );\n\n\t\tthis.onKeyDown = this.onKeyDown.bind( this );\n\t\tthis.bindContainer = this.bindContainer.bind( this );\n\t\tthis.onMouseDown = this.onMouseDown.bind( this );\n\t\tthis.focusLastTextField = this.focusLastTextField.bind( this );\n\n\t\t/**\n\t\t * Here a rectangle is stored while moving the caret vertically so\n\t\t * vertical position of the start position can be restored.\n\t\t * This is to recreate browser behaviour across blocks.\n\t\t *\n\t\t * @type {?DOMRect}\n\t\t */\n\t\tthis.verticalRect = null;\n\n\t\t/**\n\t\t * Reference of the writing flow appender element.\n\t\t * The reference is used to focus the first tabbable element after the block list\n\t\t * once we hit `tab` on the last block in navigation mode.\n\t\t */\n\t\tthis.appender = createRef();\n\t}\n\n\tbindContainer( ref ) {\n\t\tthis.container = ref;\n\t}\n\n\tonMouseDown() {\n\t\tthis.verticalRect = null;\n\t\tthis.disableNavigationMode();\n\t}\n\n\tdisableNavigationMode() {\n\t\tif ( this.props.isNavigationMode ) {\n\t\t\tthis.props.disableNavigationMode();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the optimal tab target from the given focused element in the\n\t * desired direction. A preference is made toward text fields, falling back\n\t * to the block focus stop if no other candidates exist for the block.\n\t *\n\t * @param {Element} target    Currently focused text field.\n\t * @param {boolean} isReverse True if considering as the first field.\n\t *\n\t * @return {?Element} Optimal tab target, if one exists.\n\t */\n\tgetClosestTabbable( target, isReverse ) {\n\t\t// Since the current focus target is not guaranteed to be a text field,\n\t\t// find all focusables. Tabbability is considered later.\n\t\tlet focusableNodes = focus.focusable.find( this.container );\n\n\t\tif ( isReverse ) {\n\t\t\tfocusableNodes = reverse( focusableNodes );\n\t\t}\n\n\t\t// Consider as candidates those focusables after the current target.\n\t\t// It's assumed this can only be reached if the target is focusable\n\t\t// (on its keydown event), so no need to verify it exists in the set.\n\t\tfocusableNodes = focusableNodes.slice( focusableNodes.indexOf( target ) + 1 );\n\n\t\tfunction isTabCandidate( node, i, array ) {\n\t\t\t// Not a candidate if the node is not tabbable.\n\t\t\tif ( ! focus.tabbable.isTabbableIndex( node ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Prefer text fields...\n\t\t\tif ( isTextField( node ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// ...but settle for block focus stop.\n\t\t\tif ( ! isBlockFocusStop( node ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If element contains inner blocks, stop immediately at its focus\n\t\t\t// wrapper.\n\t\t\tif ( hasInnerBlocksContext( node ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// If navigating out of a block (in reverse), don't consider its\n\t\t\t// block focus stop.\n\t\t\tif ( node.contains( target ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// In case of block focus stop, check to see if there's a better\n\t\t\t// text field candidate within.\n\t\t\tfor ( let offset = 1, nextNode; ( nextNode = array[ i + offset ] ); offset++ ) {\n\t\t\t\t// Abort if no longer testing descendents of focus stop.\n\t\t\t\tif ( ! node.contains( nextNode ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Apply same tests by recursion. This is important to consider\n\t\t\t\t// nestable blocks where we don't want to settle for the inner\n\t\t\t\t// block focus stop.\n\t\t\t\tif ( isTabCandidate( nextNode, i + offset, array ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn find( focusableNodes, isTabCandidate );\n\t}\n\n\texpandSelection( isReverse ) {\n\t\tconst {\n\t\t\tselectedBlockClientId,\n\t\t\tselectionStartClientId,\n\t\t\tselectionBeforeEndClientId,\n\t\t\tselectionAfterEndClientId,\n\t\t} = this.props;\n\n\t\tconst nextSelectionEndClientId = isReverse ?\n\t\t\tselectionBeforeEndClientId :\n\t\t\tselectionAfterEndClientId;\n\n\t\tif ( nextSelectionEndClientId ) {\n\t\t\tthis.props.onMultiSelect(\n\t\t\t\tselectionStartClientId || selectedBlockClientId,\n\t\t\t\tnextSelectionEndClientId\n\t\t\t);\n\t\t}\n\t}\n\n\tmoveSelection( isReverse ) {\n\t\tconst { selectedFirstClientId, selectedLastClientId } = this.props;\n\n\t\tconst focusedBlockClientId = isReverse ? selectedFirstClientId : selectedLastClientId;\n\n\t\tif ( focusedBlockClientId ) {\n\t\t\tthis.props.onSelectBlock( focusedBlockClientId );\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the given target field is the last in its block which\n\t * can be considered for tab transition. For example, in a block with two\n\t * text fields, this would return true when reversing from the first of the\n\t * two fields, but false when reversing from the second.\n\t *\n\t * @param {Element} target    Currently focused text field.\n\t * @param {boolean} isReverse True if considering as the first field.\n\t *\n\t * @return {boolean} Whether field is at edge for tab transition.\n\t */\n\tisTabbableEdge( target, isReverse ) {\n\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\t\treturn ! closestTabbable || ! isInSameBlock( target, closestTabbable );\n\t}\n\n\tonKeyDown( event ) {\n\t\tconst {\n\t\t\thasMultiSelection,\n\t\t\tonMultiSelect,\n\t\t\tblocks,\n\t\t\tselectedBlockClientId,\n\t\t\tselectionBeforeEndClientId,\n\t\t\tselectionAfterEndClientId,\n\t\t\tisNavigationMode,\n\t\t} = this.props;\n\n\t\tconst { keyCode, target } = event;\n\t\tconst isUp = keyCode === UP;\n\t\tconst isDown = keyCode === DOWN;\n\t\tconst isLeft = keyCode === LEFT;\n\t\tconst isRight = keyCode === RIGHT;\n\t\tconst isTab = keyCode === TAB;\n\t\tconst isReverse = isUp || isLeft;\n\t\tconst isHorizontal = isLeft || isRight;\n\t\tconst isVertical = isUp || isDown;\n\t\tconst isNav = isHorizontal || isVertical;\n\t\tconst isShift = event.shiftKey;\n\t\tconst hasModifier = isShift || event.ctrlKey || event.altKey || event.metaKey;\n\t\tconst isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;\n\n\t\t// In navigation mode, tab and arrows navigate from block to block.\n\t\tif ( isNavigationMode ) {\n\t\t\tconst navigateUp = ( isTab && isShift ) || isUp;\n\t\t\tconst navigateDown = ( isTab && ! isShift ) || isDown;\n\t\t\tconst focusedBlockUid = navigateUp ? selectionBeforeEndClientId : selectionAfterEndClientId;\n\n\t\t\tif (\n\t\t\t\t( navigateDown || navigateUp ) &&\n\t\t\t\tfocusedBlockUid\n\t\t\t) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.props.onSelectBlock( focusedBlockUid );\n\t\t\t}\n\n\t\t\t// Special case when reaching the end of the blocks (navigate to the next tabbable outside of the writing flow)\n\t\t\tif ( navigateDown && selectedBlockClientId && ! selectionAfterEndClientId && [ UP, DOWN ].indexOf( keyCode ) === -1 ) {\n\t\t\t\tthis.props.clearSelectedBlock();\n\t\t\t\tthis.appender.current.focus();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// When presing any key other than up or down, the initial vertical\n\t\t// position must ALWAYS be reset. The vertical position is saved so it\n\t\t// can be restored as well as possible on sebsequent vertical arrow key\n\t\t// presses. It may not always be possible to restore the exact same\n\t\t// position (such as at an empty line), so it wouldn't be good to\n\t\t// compute the position right before any vertical arrow key press.\n\t\tif ( ! isVertical ) {\n\t\t\tthis.verticalRect = null;\n\t\t} else if ( ! this.verticalRect ) {\n\t\t\tthis.verticalRect = computeCaretRect();\n\t\t}\n\n\t\t// This logic inside this condition needs to be checked before\n\t\t// the check for event.nativeEvent.defaultPrevented.\n\t\t// The logic handles meta+a keypress and this event is default prevented\n\t\t// by RichText.\n\t\tif ( ! isNav ) {\n\t\t\t// Set immediately before the meta+a combination can be pressed.\n\t\t\tif ( isKeyboardEvent.primary( event ) ) {\n\t\t\t\tthis.isEntirelySelected = isEntirelySelected( target );\n\t\t\t}\n\n\t\t\tif ( isKeyboardEvent.primary( event, 'a' ) ) {\n\t\t\t\t// When the target is contentEditable, selection will already\n\t\t\t\t// have been set by the browser earlier in this call stack. We\n\t\t\t\t// need check the previous result, otherwise all blocks will be\n\t\t\t\t// selected right away.\n\t\t\t\tif ( target.isContentEditable ? this.isEntirelySelected : isEntirelySelected( target ) ) {\n\t\t\t\t\tonMultiSelect( first( blocks ), last( blocks ) );\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\t// After pressing primary + A we can assume isEntirelySelected is true.\n\t\t\t\t// Calling right away isEntirelySelected after primary + A may still return false on some browsers.\n\t\t\t\tthis.isEntirelySelected = true;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Abort if navigation has already been handled (e.g. RichText inline\n\t\t// boundaries).\n\t\tif ( event.nativeEvent.defaultPrevented ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Abort if our current target is not a candidate for navigation (e.g.\n\t\t// preserve native input behaviors).\n\t\tif ( ! isNavigationCandidate( target, keyCode, hasModifier ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// In the case of RTL scripts, right means previous and left means next,\n\t\t// which is the exact reverse of LTR.\n\t\tconst { direction } = getComputedStyle( target );\n\t\tconst isReverseDir = direction === 'rtl' ? ( ! isReverse ) : isReverse;\n\n\t\tif ( isShift ) {\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\t// Ensure that there is a target block.\n\t\t\t\t\t( isReverse && selectionBeforeEndClientId ) ||\n\t\t\t\t\t( ! isReverse && selectionAfterEndClientId )\n\t\t\t\t) && (\n\t\t\t\t\thasMultiSelection || (\n\t\t\t\t\t\tthis.isTabbableEdge( target, isReverse ) &&\n\t\t\t\t\t\tisNavEdge( target, isReverse )\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Shift key is down, and there is multi selection or we're at\n\t\t\t\t// the end of the current block.\n\t\t\t\tthis.expandSelection( isReverse );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t} else if ( hasMultiSelection ) {\n\t\t\t// Moving from block multi-selection to single block selection\n\t\t\tthis.moveSelection( isReverse );\n\t\t\tevent.preventDefault();\n\t\t} else if ( isVertical && isVerticalEdge( target, isReverse ) ) {\n\t\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\n\t\t\tif ( closestTabbable ) {\n\t\t\t\tplaceCaretAtVerticalEdge( closestTabbable, isReverse, this.verticalRect );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t} else if ( isHorizontal && getSelection().isCollapsed && isHorizontalEdge( target, isReverseDir ) ) {\n\t\t\tconst closestTabbable = this.getClosestTabbable( target, isReverseDir );\n\t\t\tplaceCaretAtHorizontalEdge( closestTabbable, isReverseDir );\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\t/**\n\t * Sets focus to the end of the last tabbable text field, if one exists.\n\t */\n\tfocusLastTextField() {\n\t\tthis.disableNavigationMode();\n\t\tconst focusableNodes = focus.focusable.find( this.container );\n\t\tconst target = findLast( focusableNodes, isTabbableTextField );\n\t\tif ( target ) {\n\t\t\tplaceCaretAtHorizontalEdge( target, true );\n\t\t}\n\t}\n\n\trender() {\n\t\tconst { children } = this.props;\n\n\t\t// Disable reason: Wrapper itself is non-interactive, but must capture\n\t\t// bubbling events from children to determine focus transition intents.\n\t\t/* eslint-disable jsx-a11y/no-static-element-interactions */\n\t\treturn (\n\t\t\t<div className=\"editor-writing-flow block-editor-writing-flow\">\n\t\t\t\t<div\n\t\t\t\t\tref={ this.bindContainer }\n\t\t\t\t\tonKeyDown={ this.onKeyDown }\n\t\t\t\t\tonMouseDown={ this.onMouseDown }\n\t\t\t\t>\n\t\t\t\t\t{ children }\n\t\t\t\t</div>\n\t\t\t\t<div\n\t\t\t\t\tref={ this.appender }\n\t\t\t\t\taria-hidden\n\t\t\t\t\ttabIndex={ -1 }\n\t\t\t\t\tonClick={ this.focusLastTextField }\n\t\t\t\t\tclassName=\"editor-writing-flow__click-redirect block-editor-writing-flow__click-redirect\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t\t/* eslint-enable jsx-a11y/no-static-element-interactions */\n\t}\n}\n\nexport default compose( [\n\twithSelect( ( select ) => {\n\t\tconst {\n\t\t\tgetSelectedBlockClientId,\n\t\t\tgetMultiSelectedBlocksStartClientId,\n\t\t\tgetMultiSelectedBlocksEndClientId,\n\t\t\tgetPreviousBlockClientId,\n\t\t\tgetNextBlockClientId,\n\t\t\tgetFirstMultiSelectedBlockClientId,\n\t\t\tgetLastMultiSelectedBlockClientId,\n\t\t\thasMultiSelection,\n\t\t\tgetBlockOrder,\n\t\t\tisNavigationMode,\n\t\t} = select( 'core/block-editor' );\n\n\t\tconst selectedBlockClientId = getSelectedBlockClientId();\n\t\tconst selectionStartClientId = getMultiSelectedBlocksStartClientId();\n\t\tconst selectionEndClientId = getMultiSelectedBlocksEndClientId();\n\n\t\treturn {\n\t\t\tselectedBlockClientId,\n\t\t\tselectionStartClientId,\n\t\t\tselectionBeforeEndClientId: getPreviousBlockClientId( selectionEndClientId || selectedBlockClientId ),\n\t\t\tselectionAfterEndClientId: getNextBlockClientId( selectionEndClientId || selectedBlockClientId ),\n\t\t\tselectedFirstClientId: getFirstMultiSelectedBlockClientId(),\n\t\t\tselectedLastClientId: getLastMultiSelectedBlockClientId(),\n\t\t\thasMultiSelection: hasMultiSelection(),\n\t\t\tblocks: getBlockOrder(),\n\t\t\tisNavigationMode: isNavigationMode(),\n\t\t};\n\t} ),\n\twithDispatch( ( dispatch ) => {\n\t\tconst { multiSelect, selectBlock, setNavigationMode, clearSelectedBlock } = dispatch( 'core/block-editor' );\n\t\treturn {\n\t\t\tonMultiSelect: multiSelect,\n\t\t\tonSelectBlock: selectBlock,\n\t\t\tdisableNavigationMode: () => setNavigationMode( false ),\n\t\t\tclearSelectedBlock,\n\t\t};\n\t} ),\n] )( WritingFlow );\n"]}