"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.InserterMenu = void 0;

var _element = require("@wordpress/element");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _reactNative = require("react-native");

var _reactNativeGutenbergBridge = require("react-native-gutenberg-bridge");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _components = require("@wordpress/components");

var _style = _interopRequireDefault(require("./style.scss"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
var InserterMenu =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(InserterMenu, _Component);

  function InserterMenu() {
    (0, _classCallCheck2.default)(this, InserterMenu);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(InserterMenu).apply(this, arguments));
  }

  (0, _createClass2.default)(InserterMenu, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this = this;

      this.subscriptionParentMediaAppend = (0, _reactNativeGutenbergBridge.subscribeMediaAppend)(function (payload) {
        _this.props.onSelect({
          name: 'core/' + payload.mediaType,
          initialAttributes: (0, _defineProperty2.default)({
            id: payload.mediaId
          }, payload.mediaType === 'image' ? 'url' : 'src', payload.mediaUrl)
        });
      });
      this.onOpen();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.subscriptionParentMediaAppend) {
        this.subscriptionParentMediaAppend.remove();
      }

      this.onClose();
    }
  }, {
    key: "calculateNumberOfColumns",
    value: function calculateNumberOfColumns() {
      var bottomSheetWidth = _components.BottomSheet.getWidth();

      var _styles$modalItem = _style.default.modalItem,
          itemPaddingLeft = _styles$modalItem.paddingLeft,
          itemPaddingRight = _styles$modalItem.paddingRight;
      var _styles$content = _style.default.content,
          containerPaddingLeft = _styles$content.paddingLeft,
          containerPaddingRight = _styles$content.paddingRight;
      var itemWidth = _style.default.modalIconWrapper.width;
      var itemTotalWidth = itemWidth + itemPaddingLeft + itemPaddingRight;
      var containerTotalWidth = bottomSheetWidth - (containerPaddingLeft + containerPaddingRight);
      return Math.floor(containerTotalWidth / itemTotalWidth);
    }
  }, {
    key: "onOpen",
    value: function onOpen() {
      this.props.showInsertionPoint();
    }
  }, {
    key: "onClose",
    value: function onClose() {
      this.props.hideInsertionPoint();
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var numberOfColumns = this.calculateNumberOfColumns();
      var bottomPadding = _style.default.contentBottomPadding;
      return (0, _element.createElement)(_components.BottomSheet, {
        isVisible: true,
        onClose: this.props.onDismiss,
        contentStyle: [_style.default.content, bottomPadding],
        hideHeader: true
      }, (0, _element.createElement)(_reactNative.FlatList, {
        scrollEnabled: false,
        key: "InserterUI-".concat(numberOfColumns) //re-render when numberOfColumns changes
        ,
        keyboardShouldPersistTaps: "always",
        numColumns: numberOfColumns,
        data: this.props.items,
        ItemSeparatorComponent: function ItemSeparatorComponent() {
          return (0, _element.createElement)(_reactNative.View, {
            style: _style.default.rowSeparator
          });
        },
        keyExtractor: function keyExtractor(item) {
          return item.name;
        },
        renderItem: function renderItem(_ref) {
          var item = _ref.item;
          return (0, _element.createElement)(_reactNative.TouchableHighlight, {
            style: _style.default.touchableArea,
            underlayColor: "transparent",
            activeOpacity: .5,
            accessibilityLabel: item.title,
            onPress: function onPress() {
              return _this2.props.onSelect(item);
            }
          }, (0, _element.createElement)(_reactNative.View, {
            style: _style.default.modalItem
          }, (0, _element.createElement)(_reactNative.View, {
            style: _style.default.modalIconWrapper
          }, (0, _element.createElement)(_reactNative.View, {
            style: _style.default.modalIcon
          }, (0, _element.createElement)(_components.Icon, {
            icon: item.icon.src,
            fill: _style.default.modalIcon.fill,
            size: _style.default.modalIcon.width
          }))), (0, _element.createElement)(_reactNative.Text, {
            style: _style.default.modalItemLabel
          }, item.title)));
        }
      }));
    }
  }]);
  return InserterMenu;
}(_element.Component);

exports.InserterMenu = InserterMenu;

var _default = (0, _compose.compose)((0, _data.withSelect)(function (select, _ref2) {
  var clientId = _ref2.clientId,
      isAppender = _ref2.isAppender,
      rootClientId = _ref2.rootClientId;

  var _select = select('core/block-editor'),
      getInserterItems = _select.getInserterItems,
      getBlockName = _select.getBlockName,
      getBlockRootClientId = _select.getBlockRootClientId,
      getBlockSelectionEnd = _select.getBlockSelectionEnd;

  var _select2 = select('core/blocks'),
      getChildBlockNames = _select2.getChildBlockNames;

  var destinationRootClientId = rootClientId;

  if (!destinationRootClientId && !clientId && !isAppender) {
    var end = getBlockSelectionEnd();

    if (end) {
      destinationRootClientId = getBlockRootClientId(end) || undefined;
    }
  }

  var destinationRootBlockName = getBlockName(destinationRootClientId);
  return {
    rootChildBlocks: getChildBlockNames(destinationRootBlockName),
    items: getInserterItems(destinationRootClientId),
    destinationRootClientId: destinationRootClientId
  };
}), (0, _data.withDispatch)(function (dispatch, ownProps, _ref3) {
  var select = _ref3.select;

  var _dispatch = dispatch('core/block-editor'),
      _showInsertionPoint = _dispatch.showInsertionPoint,
      hideInsertionPoint = _dispatch.hideInsertionPoint; // To avoid duplication, getInsertionIndex is extracted and used in two event handlers
  // This breaks the withDispatch not containing any logic rule.
  // Since it's a function only called when the event handlers are called,
  // it's fine to extract it.
  // eslint-disable-next-line no-restricted-syntax


  function getInsertionIndex() {
    var _select3 = select('core/block-editor'),
        getBlock = _select3.getBlock,
        getBlockIndex = _select3.getBlockIndex,
        getBlockSelectionEnd = _select3.getBlockSelectionEnd,
        getBlockOrder = _select3.getBlockOrder;

    var _select4 = select('core/editor'),
        isPostTitleSelected = _select4.isPostTitleSelected;

    var clientId = ownProps.clientId,
        destinationRootClientId = ownProps.destinationRootClientId,
        isAppender = ownProps.isAppender; // if post title is selected insert as first block

    if (isPostTitleSelected()) {
      return 0;
    } // If the clientId is defined, we insert at the position of the block.


    if (clientId) {
      return getBlockIndex(clientId, destinationRootClientId);
    } // If there a selected block,


    var end = getBlockSelectionEnd();

    if (!isAppender && end) {
      // and the last selected block is unmodified (empty), it will be replaced
      if ((0, _blocks.isUnmodifiedDefaultBlock)(getBlock(end))) {
        return getBlockIndex(end, destinationRootClientId);
      } // we insert after the selected block.


      return getBlockIndex(end, destinationRootClientId) + 1;
    } // Otherwise, we insert at the end of the current rootClientId


    return getBlockOrder(destinationRootClientId).length;
  }

  return {
    showInsertionPoint: function showInsertionPoint() {
      var index = getInsertionIndex();

      _showInsertionPoint(ownProps.destinationRootClientId, index);
    },
    hideInsertionPoint: hideInsertionPoint,
    onSelect: function onSelect(item) {
      var _dispatch2 = dispatch('core/block-editor'),
          replaceBlocks = _dispatch2.replaceBlocks,
          insertBlock = _dispatch2.insertBlock;

      var _select5 = select('core/block-editor'),
          getSelectedBlock = _select5.getSelectedBlock;

      var isAppender = ownProps.isAppender;
      var name = item.name,
          initialAttributes = item.initialAttributes;
      var selectedBlock = getSelectedBlock();
      var insertedBlock = (0, _blocks.createBlock)(name, initialAttributes);

      if (!isAppender && selectedBlock && (0, _blocks.isUnmodifiedDefaultBlock)(selectedBlock)) {
        replaceBlocks(selectedBlock.clientId, insertedBlock);
      } else {
        insertBlock(insertedBlock, getInsertionIndex(), ownProps.destinationRootClientId);
      }

      ownProps.onSelect();
    }
  };
}), _compose.withInstanceId)(InserterMenu);

exports.default = _default;
//# sourceMappingURL=menu.native.js.map