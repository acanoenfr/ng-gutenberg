import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
import { View } from 'react-native';
/**
 * WordPress dependencies
 */

import { RawHTML } from '@wordpress/element';
import { withDispatch, withSelect } from '@wordpress/data';
import { pasteHandler, isUnmodifiedDefaultBlock } from '@wordpress/blocks';
import { withInstanceId, compose } from '@wordpress/compose';
import { RichText } from '@wordpress/rich-text';
/**
 * Internal dependencies
 */

import Autocomplete from '../autocomplete';
import BlockFormatControls from '../block-format-controls';
import FormatToolbar from './format-toolbar';
import { withBlockEditContext } from '../block-edit/context';
var wrapperClasses = 'editor-rich-text block-editor-rich-text';
var classes = 'editor-rich-text__editable block-editor-rich-text__editable';

function RichTextWraper(_ref) {
  var children = _ref.children,
      tagName = _ref.tagName,
      originalValue = _ref.value,
      originalOnChange = _ref.onChange,
      selectionStart = _ref.selectionStart,
      selectionEnd = _ref.selectionEnd,
      onSelectionChange = _ref.onSelectionChange,
      multiline = _ref.multiline,
      inlineToolbar = _ref.inlineToolbar,
      wrapperClassName = _ref.wrapperClassName,
      className = _ref.className,
      autocompleters = _ref.autocompleters,
      onReplace = _ref.onReplace,
      onRemove = _ref.onRemove,
      onMerge = _ref.onMerge,
      onSplit = _ref.onSplit,
      isCaretWithinFormattedText = _ref.isCaretWithinFormattedText,
      onEnterFormattedText = _ref.onEnterFormattedText,
      onExitFormattedText = _ref.onExitFormattedText,
      canUserUseUnfilteredHTML = _ref.canUserUseUnfilteredHTML,
      originalIsSelected = _ref.isSelected,
      onCreateUndoLevel = _ref.onCreateUndoLevel,
      placeholder = _ref.placeholder,
      experimentalProps = _objectWithoutProperties(_ref, ["children", "tagName", "value", "onChange", "selectionStart", "selectionEnd", "onSelectionChange", "multiline", "inlineToolbar", "wrapperClassName", "className", "autocompleters", "onReplace", "onRemove", "onMerge", "onSplit", "isCaretWithinFormattedText", "onEnterFormattedText", "onExitFormattedText", "canUserUseUnfilteredHTML", "isSelected", "onCreateUndoLevel", "placeholder"]);

  var adjustedValue = originalValue;
  var adjustedOnChange = originalOnChange;
  return createElement(RichText, _extends({}, experimentalProps, {
    value: adjustedValue,
    onChange: adjustedOnChange,
    selectionStart: selectionStart,
    selectionEnd: selectionEnd,
    onSelectionChange: onSelectionChange,
    tagName: tagName,
    wrapperClassName: classnames(wrapperClasses, wrapperClassName),
    className: classnames(classes, className),
    placeholder: placeholder,
    __unstableIsSelected: originalIsSelected //__unstablePatterns={ getPatterns() }
    //__unstableEnterPatterns={ getEnterPatterns() }
    ,
    __unstablePasteHandler: pasteHandler,
    __unstableAutocomplete: Autocomplete,
    __unstableAutocompleters: autocompleters,
    __unstableOnReplace: onReplace,
    __unstableOnRemove: onRemove,
    __unstableOnMerge: onMerge,
    __unstableOnSplit: onSplit,
    __unstableMultiline: multiline,
    __unstableIsCaretWithinFormattedText: isCaretWithinFormattedText,
    __unstableOnEnterFormattedText: onEnterFormattedText,
    __unstableOnExitFormattedText: onExitFormattedText,
    __unstableCanUserUseUnfilteredHTML: canUserUseUnfilteredHTML,
    __unstableOnCreateUndoLevel: onCreateUndoLevel
  }), function (_ref2) {
    var isSelected = _ref2.isSelected,
        value = _ref2.value,
        onChange = _ref2.onChange;
    return createElement(View, null, children && children({
      value: value,
      onChange: onChange
    }), isSelected && !inlineToolbar && createElement(BlockFormatControls, null, createElement(FormatToolbar, null)));
  });
}

var RichTextContainer = compose([withInstanceId, withBlockEditContext(function (_ref3, ownProps) {
  var clientId = _ref3.clientId,
      onCaretVerticalPositionChange = _ref3.onCaretVerticalPositionChange,
      isSelected = _ref3.isSelected;
  return {
    clientId: clientId,
    blockIsSelected: ownProps.isSelected !== undefined ? ownProps.isSelected : isSelected,
    onCaretVerticalPositionChange: onCaretVerticalPositionChange
  };
}), withSelect(function (select, _ref4) {
  var clientId = _ref4.clientId,
      instanceId = _ref4.instanceId,
      _ref4$identifier = _ref4.identifier,
      identifier = _ref4$identifier === void 0 ? instanceId : _ref4$identifier,
      isSelected = _ref4.isSelected,
      blockIsSelected = _ref4.blockIsSelected;

  var _select = select('core/rich-text'),
      getFormatTypes = _select.getFormatTypes;

  var _select2 = select('core/block-editor'),
      getSelectionStart = _select2.getSelectionStart,
      getSelectionEnd = _select2.getSelectionEnd,
      __unstableGetBlockWithoutInnerBlocks = _select2.__unstableGetBlockWithoutInnerBlocks;

  var selectionStart = getSelectionStart();
  var selectionEnd = getSelectionEnd();

  if (isSelected === undefined) {
    isSelected = selectionStart.clientId === clientId && selectionStart.attributeKey === identifier;
  } // If the block of this RichText is unmodified then it's a candidate for replacing when adding a new block.
  // In order to fix https://github.com/wordpress-mobile/gutenberg-mobile/issues/1126, let's blur on unmount in that case.
  // This apparently assumes functionality the BlockHlder actually


  var block = clientId && __unstableGetBlockWithoutInnerBlocks(clientId);

  var shouldBlurOnUnmount = block && isSelected && isUnmodifiedDefaultBlock(block);
  return {
    formatTypes: getFormatTypes(),
    selectionStart: isSelected ? selectionStart.offset : undefined,
    selectionEnd: isSelected ? selectionEnd.offset : undefined,
    isSelected: isSelected,
    blockIsSelected: blockIsSelected,
    shouldBlurOnUnmount: shouldBlurOnUnmount
  };
}), withDispatch(function (dispatch, _ref5) {
  var clientId = _ref5.clientId,
      instanceId = _ref5.instanceId,
      _ref5$identifier = _ref5.identifier,
      identifier = _ref5$identifier === void 0 ? instanceId : _ref5$identifier;

  var _dispatch = dispatch('core/block-editor'),
      __unstableMarkLastChangeAsPersistent = _dispatch.__unstableMarkLastChangeAsPersistent,
      selectionChange = _dispatch.selectionChange;

  return {
    onCreateUndoLevel: __unstableMarkLastChangeAsPersistent,
    onSelectionChange: function onSelectionChange(start, end) {
      selectionChange(clientId, identifier, start, end);
    }
  };
})])(RichTextWraper);

RichTextContainer.Content = function (_ref6) {
  var value = _ref6.value,
      format = _ref6.format,
      Tag = _ref6.tagName,
      multiline = _ref6.multiline,
      props = _objectWithoutProperties(_ref6, ["value", "format", "tagName", "multiline"]);

  var content;
  var html = value;
  var MultilineTag;

  if (multiline === true || multiline === 'p' || multiline === 'li') {
    MultilineTag = multiline === true ? 'p' : multiline;
  }

  if (!html && MultilineTag) {
    html = "<".concat(MultilineTag, "></").concat(MultilineTag, ">");
  }

  switch (format) {
    case 'string':
      content = createElement(RawHTML, null, html);
      break;
  }

  if (Tag) {
    return createElement(Tag, props, content);
  }

  return content;
};

RichTextContainer.isEmpty = function () {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  // Handle deprecated `children` and `node` sources.
  if (Array.isArray(value)) {
    return !value || value.length === 0;
  }

  return value.length === 0;
};

RichTextContainer.Content.defaultProps = {
  format: 'string',
  value: ''
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/master/packages/block-editor/src/components/rich-text/README.md
 */

export default RichTextContainer;
export { RichTextShortcut } from './shortcut';
export { RichTextToolbarButton } from './toolbar-button';
export { __unstableRichTextInputEvent } from './input-event';
//# sourceMappingURL=index.native.js.map