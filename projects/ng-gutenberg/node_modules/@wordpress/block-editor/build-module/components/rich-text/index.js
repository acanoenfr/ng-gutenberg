import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
import { omit } from 'lodash';
/**
 * WordPress dependencies
 */

import { RawHTML, Component } from '@wordpress/element';
import { withDispatch, withSelect } from '@wordpress/data';
import { pasteHandler, children as childrenSource, getBlockTransforms, findTransform } from '@wordpress/blocks';
import { withInstanceId, compose } from '@wordpress/compose';
import { __experimentalRichText as RichText, __unstableCreateElement, isEmpty, __unstableIsEmptyLine as isEmptyLine, insert, __unstableInsertLineSeparator as insertLineSeparator, create, replace, split, __UNSTABLE_LINE_SEPARATOR as LINE_SEPARATOR, toHTMLString, slice } from '@wordpress/rich-text';
import { withFilters, IsolatedEventContainer } from '@wordpress/components';
import { createBlobURL } from '@wordpress/blob';
import deprecated from '@wordpress/deprecated';
import { isURL } from '@wordpress/url';
/**
 * Internal dependencies
 */

import Autocomplete from '../autocomplete';
import BlockFormatControls from '../block-format-controls';
import FormatToolbar from './format-toolbar';
import { withBlockEditContext } from '../block-edit/context';
import { RemoveBrowserShortcuts } from './remove-browser-shortcuts';

var requestIdleCallback = window.requestIdleCallback || function fallbackRequestIdleCallback(fn) {
  window.setTimeout(fn, 100);
};

var wrapperClasses = 'editor-rich-text block-editor-rich-text';
var classes = 'editor-rich-text__editable block-editor-rich-text__editable';
/**
 * Get the multiline tag based on the multiline prop.
 *
 * @param {?(string|boolean)} multiline The multiline prop.
 *
 * @return {?string} The multiline tag.
 */

function getMultilineTag(multiline) {
  if (multiline !== true && multiline !== 'p' && multiline !== 'li') {
    return;
  }

  return multiline === true ? 'p' : multiline;
}

var RichTextWrapper =
/*#__PURE__*/
function (_Component) {
  _inherits(RichTextWrapper, _Component);

  function RichTextWrapper() {
    var _this;

    _classCallCheck(this, RichTextWrapper);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RichTextWrapper).apply(this, arguments));
    _this.onEnter = _this.onEnter.bind(_assertThisInitialized(_this));
    _this.onSplit = _this.onSplit.bind(_assertThisInitialized(_this));
    _this.onPaste = _this.onPaste.bind(_assertThisInitialized(_this));
    _this.onDelete = _this.onDelete.bind(_assertThisInitialized(_this));
    _this.inputRule = _this.inputRule.bind(_assertThisInitialized(_this));
    _this.markAutomaticChange = _this.markAutomaticChange.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(RichTextWrapper, [{
    key: "onEnter",
    value: function onEnter(_ref) {
      var value = _ref.value,
          onChange = _ref.onChange,
          shiftKey = _ref.shiftKey;
      var _this$props = this.props,
          onReplace = _this$props.onReplace,
          onSplit = _this$props.onSplit,
          multiline = _this$props.multiline;
      var canSplit = onReplace && onSplit;

      if (onReplace) {
        var transforms = getBlockTransforms('from').filter(function (_ref2) {
          var type = _ref2.type;
          return type === 'enter';
        });
        var transformation = findTransform(transforms, function (item) {
          return item.regExp.test(value.text);
        });

        if (transformation) {
          onReplace([transformation.transform({
            content: value.text
          })]);
          this.markAutomaticChange();
        }
      }

      if (multiline) {
        if (shiftKey) {
          onChange(insert(value, '\n'));
        } else if (canSplit && isEmptyLine(value)) {
          this.onSplit(value);
        } else {
          onChange(insertLineSeparator(value));
        }
      } else if (shiftKey || !canSplit) {
        onChange(insert(value, '\n'));
      } else {
        this.onSplit(value);
      }
    }
  }, {
    key: "onDelete",
    value: function onDelete(_ref3) {
      var value = _ref3.value,
          isReverse = _ref3.isReverse;
      var _this$props2 = this.props,
          onMerge = _this$props2.onMerge,
          onRemove = _this$props2.onRemove;

      if (onMerge) {
        onMerge(!isReverse);
      } // Only handle remove on Backspace. This serves dual-purpose of being
      // an intentional user interaction distinguishing between Backspace and
      // Delete to remove the empty field, but also to avoid merge & remove
      // causing destruction of two fields (merge, then removed merged).


      if (onRemove && isEmpty(value) && isReverse) {
        onRemove(!isReverse);
      }
    }
  }, {
    key: "onPaste",
    value: function onPaste(_ref4) {
      var value = _ref4.value,
          onChange = _ref4.onChange,
          html = _ref4.html,
          plainText = _ref4.plainText,
          image = _ref4.image;
      var _this$props3 = this.props,
          onReplace = _this$props3.onReplace,
          onSplit = _this$props3.onSplit,
          tagName = _this$props3.tagName,
          canUserUseUnfilteredHTML = _this$props3.canUserUseUnfilteredHTML,
          multiline = _this$props3.multiline,
          __unstableEmbedURLOnPaste = _this$props3.__unstableEmbedURLOnPaste;

      if (image && !html) {
        var file = image.getAsFile ? image.getAsFile() : image;

        var _content = pasteHandler({
          HTML: "<img src=\"".concat(createBlobURL(file), "\">"),
          mode: 'BLOCKS',
          tagName: tagName
        }); // Allows us to ask for this information when we get a report.


        window.console.log('Received item:\n\n', file);

        if (onReplace && isEmpty(value)) {
          onReplace(_content);
        } else {
          this.onSplit(value, _content);
        }

        return;
      }

      var mode = onReplace && onSplit ? 'AUTO' : 'INLINE';

      if (__unstableEmbedURLOnPaste && isEmpty(value) && isURL(plainText.trim())) {
        mode = 'BLOCKS';
      }

      var content = pasteHandler({
        HTML: html,
        plainText: plainText,
        mode: mode,
        tagName: tagName,
        canUserUseUnfilteredHTML: canUserUseUnfilteredHTML
      });

      if (typeof content === 'string') {
        var valueToInsert = create({
          html: content
        }); // If the content should be multiline, we should process text
        // separated by a line break as separate lines.

        if (multiline) {
          valueToInsert = replace(valueToInsert, /\n+/g, LINE_SEPARATOR);
        }

        onChange(insert(value, valueToInsert));
      } else if (content.length > 0) {
        if (onReplace && isEmpty(value)) {
          onReplace(content);
        } else {
          this.onSplit(value, content);
        }
      }
    }
    /**
     * Signals to the RichText owner that the block can be replaced with two
     * blocks as a result of splitting the block by pressing enter, or with
     * blocks as a result of splitting the block by pasting block content in the
     * instance.
     *
     * @param  {Object} record       The rich text value to split.
     * @param  {Array}  pastedBlocks The pasted blocks to insert, if any.
     */

  }, {
    key: "onSplit",
    value: function onSplit(record) {
      var pastedBlocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var _this$props4 = this.props,
          onReplace = _this$props4.onReplace,
          onSplit = _this$props4.onSplit,
          onSplitMiddle = _this$props4.__unstableOnSplitMiddle,
          multiline = _this$props4.multiline;

      if (!onReplace || !onSplit) {
        return;
      }

      var blocks = [];

      var _split = split(record),
          _split2 = _slicedToArray(_split, 2),
          before = _split2[0],
          after = _split2[1];

      var hasPastedBlocks = pastedBlocks.length > 0;
      var multilineTag = getMultilineTag(multiline); // Create a block with the content before the caret if there's no pasted
      // blocks, or if there are pasted blocks and the value is not empty.
      // We do not want a leading empty block on paste, but we do if split
      // with e.g. the enter key.

      if (!hasPastedBlocks || !isEmpty(before)) {
        blocks.push(onSplit(toHTMLString({
          value: before,
          multilineTag: multilineTag
        })));
      }

      if (hasPastedBlocks) {
        blocks.push.apply(blocks, _toConsumableArray(pastedBlocks));
      } else if (onSplitMiddle) {
        blocks.push(onSplitMiddle());
      } // If there's pasted blocks, append a block with the content after the
      // caret. Otherwise, do append and empty block if there is no
      // `onSplitMiddle` prop, but if there is and the content is empty, the
      // middle block is enough to set focus in.


      if (hasPastedBlocks || !onSplitMiddle || !isEmpty(after)) {
        blocks.push(onSplit(toHTMLString({
          value: after,
          multilineTag: multilineTag
        })));
      } // If there are pasted blocks, set the selection to the last one.
      // Otherwise, set the selection to the second block.


      var indexToSelect = hasPastedBlocks ? blocks.length - 1 : 1;
      onReplace(blocks, indexToSelect);
    }
  }, {
    key: "inputRule",
    value: function inputRule(value, valueToFormat) {
      var onReplace = this.props.onReplace;

      if (!onReplace) {
        return;
      }

      var start = value.start,
          text = value.text;
      var characterBefore = text.slice(start - 1, start); // The character right before the caret must be a plain space.

      if (characterBefore !== ' ') {
        return;
      }

      var trimmedTextBefore = text.slice(0, start).trim();
      var prefixTransforms = getBlockTransforms('from').filter(function (_ref5) {
        var type = _ref5.type;
        return type === 'prefix';
      });
      var transformation = findTransform(prefixTransforms, function (_ref6) {
        var prefix = _ref6.prefix;
        return trimmedTextBefore === prefix;
      });

      if (!transformation) {
        return;
      }

      var content = valueToFormat(slice(value, start, text.length));
      var block = transformation.transform(content);
      onReplace([block]);
      this.markAutomaticChange();
    }
  }, {
    key: "getAllowedFormats",
    value: function getAllowedFormats() {
      var _this$props5 = this.props,
          allowedFormats = _this$props5.allowedFormats,
          formattingControls = _this$props5.formattingControls;

      if (!allowedFormats && !formattingControls) {
        return;
      }

      if (allowedFormats) {
        return allowedFormats;
      }

      deprecated('wp.blockEditor.RichText formattingControls prop', {
        alternative: 'allowedFormats'
      });
      return formattingControls.map(function (name) {
        return "core/".concat(name);
      });
    }
    /**
     * Marks the last change as an automatic change at the next idle period to
     * ensure all selection changes have been recorded.
     */

  }, {
    key: "markAutomaticChange",
    value: function markAutomaticChange() {
      var _this2 = this;

      requestIdleCallback(function () {
        _this2.props.markAutomaticChange();
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props,
          children = _this$props6.children,
          tagName = _this$props6.tagName,
          originalValue = _this$props6.value,
          originalOnChange = _this$props6.onChange,
          selectionStart = _this$props6.selectionStart,
          selectionEnd = _this$props6.selectionEnd,
          onSelectionChange = _this$props6.onSelectionChange,
          multiline = _this$props6.multiline,
          inlineToolbar = _this$props6.inlineToolbar,
          wrapperClassName = _this$props6.wrapperClassName,
          className = _this$props6.className,
          autocompleters = _this$props6.autocompleters,
          onReplace = _this$props6.onReplace,
          isCaretWithinFormattedText = _this$props6.isCaretWithinFormattedText,
          onEnterFormattedText = _this$props6.onEnterFormattedText,
          onExitFormattedText = _this$props6.onExitFormattedText,
          originalIsSelected = _this$props6.isSelected,
          onCreateUndoLevel = _this$props6.onCreateUndoLevel,
          markAutomaticChange = _this$props6.markAutomaticChange,
          didAutomaticChange = _this$props6.didAutomaticChange,
          undo = _this$props6.undo,
          placeholder = _this$props6.placeholder,
          keepPlaceholderOnFocus = _this$props6.keepPlaceholderOnFocus,
          allowedFormats = _this$props6.allowedFormats,
          withoutInteractiveFormatting = _this$props6.withoutInteractiveFormatting,
          onRemove = _this$props6.onRemove,
          onMerge = _this$props6.onMerge,
          onSplit = _this$props6.onSplit,
          canUserUseUnfilteredHTML = _this$props6.canUserUseUnfilteredHTML,
          clientId = _this$props6.clientId,
          identifier = _this$props6.identifier,
          instanceId = _this$props6.instanceId,
          start = _this$props6.start,
          reversed = _this$props6.reversed,
          experimentalProps = _objectWithoutProperties(_this$props6, ["children", "tagName", "value", "onChange", "selectionStart", "selectionEnd", "onSelectionChange", "multiline", "inlineToolbar", "wrapperClassName", "className", "autocompleters", "onReplace", "isCaretWithinFormattedText", "onEnterFormattedText", "onExitFormattedText", "isSelected", "onCreateUndoLevel", "markAutomaticChange", "didAutomaticChange", "undo", "placeholder", "keepPlaceholderOnFocus", "allowedFormats", "withoutInteractiveFormatting", "onRemove", "onMerge", "onSplit", "canUserUseUnfilteredHTML", "clientId", "identifier", "instanceId", "start", "reversed"]);

      var multilineTag = getMultilineTag(multiline);
      var adjustedAllowedFormats = this.getAllowedFormats();
      var hasFormats = !adjustedAllowedFormats || adjustedAllowedFormats.length > 0;
      var adjustedValue = originalValue;
      var adjustedOnChange = originalOnChange; // Handle deprecated format.

      if (Array.isArray(originalValue)) {
        adjustedValue = childrenSource.toHTML(originalValue);

        adjustedOnChange = function adjustedOnChange(newValue) {
          return originalOnChange(childrenSource.fromDOM(__unstableCreateElement(document, newValue).childNodes));
        };
      }

      var content = createElement(RichText, _extends({}, experimentalProps, {
        value: adjustedValue,
        onChange: adjustedOnChange,
        selectionStart: selectionStart,
        selectionEnd: selectionEnd,
        onSelectionChange: onSelectionChange,
        tagName: tagName,
        className: classnames(classes, className, {
          'is-selected': originalIsSelected,
          'keep-placeholder-on-focus': keepPlaceholderOnFocus
        }),
        placeholder: placeholder,
        allowedFormats: adjustedAllowedFormats,
        withoutInteractiveFormatting: withoutInteractiveFormatting,
        onEnter: this.onEnter,
        onDelete: this.onDelete,
        onPaste: this.onPaste,
        __unstableIsSelected: originalIsSelected,
        __unstableInputRule: this.inputRule,
        __unstableMultilineTag: multilineTag,
        __unstableIsCaretWithinFormattedText: isCaretWithinFormattedText,
        __unstableOnEnterFormattedText: onEnterFormattedText,
        __unstableOnExitFormattedText: onExitFormattedText,
        __unstableOnCreateUndoLevel: onCreateUndoLevel,
        __unstableMarkAutomaticChange: this.markAutomaticChange,
        __unstableDidAutomaticChange: didAutomaticChange,
        __unstableUndo: undo
      }), function (_ref7) {
        var isSelected = _ref7.isSelected,
            value = _ref7.value,
            onChange = _ref7.onChange,
            Editable = _ref7.Editable;
        return createElement(Fragment, null, children && children({
          value: value,
          onChange: onChange
        }), isSelected && !inlineToolbar && hasFormats && createElement(BlockFormatControls, null, createElement(FormatToolbar, null)), isSelected && inlineToolbar && hasFormats && createElement(IsolatedEventContainer, {
          className: "editor-rich-text__inline-toolbar block-editor-rich-text__inline-toolbar"
        }, createElement(FormatToolbar, null)), isSelected && createElement(RemoveBrowserShortcuts, null), createElement(Autocomplete, {
          onReplace: onReplace,
          completers: autocompleters,
          record: value,
          onChange: onChange,
          isSelected: isSelected
        }, function (_ref8) {
          var listBoxId = _ref8.listBoxId,
              activeId = _ref8.activeId,
              onKeyDown = _ref8.onKeyDown;
          return createElement(Editable, {
            "aria-autocomplete": listBoxId ? 'list' : undefined,
            "aria-owns": listBoxId,
            "aria-activedescendant": activeId,
            start: start,
            reversed: reversed,
            onKeyDown: onKeyDown
          });
        }));
      });
      return createElement("div", {
        className: classnames(wrapperClasses, wrapperClassName)
      }, content);
    }
  }]);

  return RichTextWrapper;
}(Component);

var RichTextContainer = compose([withInstanceId, withBlockEditContext(function (_ref9) {
  var clientId = _ref9.clientId;
  return {
    clientId: clientId
  };
}), withSelect(function (select, _ref10) {
  var clientId = _ref10.clientId,
      instanceId = _ref10.instanceId,
      _ref10$identifier = _ref10.identifier,
      identifier = _ref10$identifier === void 0 ? instanceId : _ref10$identifier,
      isSelected = _ref10.isSelected;

  var _select = select('core/block-editor'),
      isCaretWithinFormattedText = _select.isCaretWithinFormattedText,
      getSelectionStart = _select.getSelectionStart,
      getSelectionEnd = _select.getSelectionEnd,
      getSettings = _select.getSettings,
      didAutomaticChange = _select.didAutomaticChange;

  var selectionStart = getSelectionStart();
  var selectionEnd = getSelectionEnd();

  var _getSettings = getSettings(),
      __experimentalCanUserUseUnfilteredHTML = _getSettings.__experimentalCanUserUseUnfilteredHTML;

  if (isSelected === undefined) {
    isSelected = selectionStart.clientId === clientId && selectionStart.attributeKey === identifier;
  } else if (isSelected) {
    isSelected = selectionStart.clientId === clientId;
  }

  return {
    canUserUseUnfilteredHTML: __experimentalCanUserUseUnfilteredHTML,
    isCaretWithinFormattedText: isCaretWithinFormattedText(),
    selectionStart: isSelected ? selectionStart.offset : undefined,
    selectionEnd: isSelected ? selectionEnd.offset : undefined,
    isSelected: isSelected,
    didAutomaticChange: didAutomaticChange()
  };
}), withDispatch(function (dispatch, _ref11) {
  var clientId = _ref11.clientId,
      instanceId = _ref11.instanceId,
      _ref11$identifier = _ref11.identifier,
      identifier = _ref11$identifier === void 0 ? instanceId : _ref11$identifier;

  var _dispatch = dispatch('core/block-editor'),
      __unstableMarkLastChangeAsPersistent = _dispatch.__unstableMarkLastChangeAsPersistent,
      enterFormattedText = _dispatch.enterFormattedText,
      exitFormattedText = _dispatch.exitFormattedText,
      selectionChange = _dispatch.selectionChange,
      __unstableMarkAutomaticChange = _dispatch.__unstableMarkAutomaticChange;

  var _dispatch2 = dispatch('core/editor'),
      undo = _dispatch2.undo;

  return {
    onCreateUndoLevel: __unstableMarkLastChangeAsPersistent,
    onEnterFormattedText: enterFormattedText,
    onExitFormattedText: exitFormattedText,
    onSelectionChange: function onSelectionChange(start, end) {
      selectionChange(clientId, identifier, start, end);
    },
    markAutomaticChange: __unstableMarkAutomaticChange,
    undo: undo
  };
}), withFilters('experimentalRichText')])(RichTextWrapper);

RichTextContainer.Content = function (_ref12) {
  var value = _ref12.value,
      Tag = _ref12.tagName,
      multiline = _ref12.multiline,
      props = _objectWithoutProperties(_ref12, ["value", "tagName", "multiline"]);

  // Handle deprecated `children` and `node` sources.
  if (Array.isArray(value)) {
    value = childrenSource.toHTML(value);
  }

  var MultilineTag = getMultilineTag(multiline);

  if (!value && MultilineTag) {
    value = "<".concat(MultilineTag, "></").concat(MultilineTag, ">");
  }

  var content = createElement(RawHTML, null, value);

  if (Tag) {
    return createElement(Tag, omit(props, ['format']), content);
  }

  return content;
};

RichTextContainer.isEmpty = function (value) {
  return !value || value.length === 0;
};

RichTextContainer.Content.defaultProps = {
  format: 'string',
  value: ''
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/master/packages/block-editor/src/components/rich-text/README.md
 */

export default RichTextContainer;
export { RichTextShortcut } from './shortcut';
export { RichTextToolbarButton } from './toolbar-button';
export { __unstableRichTextInputEvent } from './input-event';
//# sourceMappingURL=index.js.map