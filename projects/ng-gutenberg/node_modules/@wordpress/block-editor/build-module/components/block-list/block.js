import _extends from "@babel/runtime/helpers/esm/extends";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
import { first, last } from 'lodash';
import { animated } from 'react-spring/web.cjs';
/**
 * WordPress dependencies
 */

import { useRef, useEffect, useLayoutEffect, useState } from '@wordpress/element';
import { focus, isTextField, placeCaretAtHorizontalEdge } from '@wordpress/dom';
import { BACKSPACE, DELETE, ENTER, ESCAPE } from '@wordpress/keycodes';
import { getBlockType, getSaveElement, isReusableBlock, isUnmodifiedDefaultBlock, getUnregisteredTypeHandlerName } from '@wordpress/blocks';
import { KeyboardShortcuts, withFilters } from '@wordpress/components';
import { __, sprintf } from '@wordpress/i18n';
import { withDispatch, withSelect } from '@wordpress/data';
import { withViewportMatch } from '@wordpress/viewport';
import { compose, pure, ifCondition } from '@wordpress/compose';
/**
 * Internal dependencies
 */

import BlockEdit from '../block-edit';
import BlockMover from '../block-mover';
import BlockDropZone from '../block-drop-zone';
import BlockInvalidWarning from './block-invalid-warning';
import BlockCrashWarning from './block-crash-warning';
import BlockCrashBoundary from './block-crash-boundary';
import BlockHtml from './block-html';
import BlockBreadcrumb from './breadcrumb';
import BlockContextualToolbar from './block-contextual-toolbar';
import BlockMultiControls from './multi-controls';
import BlockMobileToolbar from './block-mobile-toolbar';
import BlockInsertionPoint from './insertion-point';
import IgnoreNestedEvents from '../ignore-nested-events';
import InserterWithShortcuts from '../inserter-with-shortcuts';
import Inserter from '../inserter';
import { isInsideRootBlock } from '../../utils/dom';
import useMovingAnimation from './moving-animation';
/**
 * Prevents default dragging behavior within a block to allow for multi-
 * selection to take effect unhampered.
 *
 * @param {DragEvent} event Drag event.
 */

var preventDrag = function preventDrag(event) {
  event.preventDefault();
};

function BlockListBlock(_ref) {
  var blockRef = _ref.blockRef,
      mode = _ref.mode,
      isFocusMode = _ref.isFocusMode,
      hasFixedToolbar = _ref.hasFixedToolbar,
      isLocked = _ref.isLocked,
      clientId = _ref.clientId,
      rootClientId = _ref.rootClientId,
      isSelected = _ref.isSelected,
      isPartOfMultiSelection = _ref.isPartOfMultiSelection,
      isFirstMultiSelected = _ref.isFirstMultiSelected,
      isTypingWithinBlock = _ref.isTypingWithinBlock,
      isCaretWithinFormattedText = _ref.isCaretWithinFormattedText,
      isEmptyDefaultBlock = _ref.isEmptyDefaultBlock,
      isMovable = _ref.isMovable,
      isParentOfSelectedBlock = _ref.isParentOfSelectedBlock,
      isDraggable = _ref.isDraggable,
      isSelectionEnabled = _ref.isSelectionEnabled,
      className = _ref.className,
      name = _ref.name,
      isValid = _ref.isValid,
      isLast = _ref.isLast,
      attributes = _ref.attributes,
      initialPosition = _ref.initialPosition,
      wrapperProps = _ref.wrapperProps,
      setAttributes = _ref.setAttributes,
      onReplace = _ref.onReplace,
      onInsertBlocksAfter = _ref.onInsertBlocksAfter,
      onMerge = _ref.onMerge,
      onSelect = _ref.onSelect,
      onRemove = _ref.onRemove,
      onInsertDefaultBlockAfter = _ref.onInsertDefaultBlockAfter,
      toggleSelection = _ref.toggleSelection,
      onShiftSelection = _ref.onShiftSelection,
      onSelectionStart = _ref.onSelectionStart,
      animateOnChange = _ref.animateOnChange,
      enableAnimation = _ref.enableAnimation,
      isNavigationMode = _ref.isNavigationMode,
      enableNavigationMode = _ref.enableNavigationMode;

  // Random state used to rerender the component if needed, ideally we don't need this
  var _useState = useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      updateRerenderState = _useState2[1];

  var rerender = function rerender() {
    return updateRerenderState({});
  }; // Reference of the wrapper


  var wrapper = useRef(null);
  useEffect(function () {
    blockRef(wrapper.current, clientId);
  }, []); // Reference to the block edit node

  var blockNodeRef = useRef();
  var breadcrumb = useRef(); // Keep track of touchstart to disable hover on iOS

  var hadTouchStart = useRef(false);

  var onTouchStart = function onTouchStart() {
    hadTouchStart.current = true;
  };

  var onTouchStop = function onTouchStop() {
    // Clear touchstart detection
    // Browser will try to emulate mouse events also see https://www.html5rocks.com/en/mobile/touchandmouse/
    hadTouchStart.current = false;
  }; // Handling isHovered


  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isBlockHovered = _useState4[0],
      setBlockHoveredState = _useState4[1];
  /**
   * Sets the block state as unhovered if currently hovering. There are cases
   * where mouseleave may occur but the block is not hovered (multi-select),
   * so to avoid unnecesary renders, the state is only set if hovered.
   */


  var hideHoverEffects = function hideHoverEffects() {
    if (isBlockHovered) {
      setBlockHoveredState(false);
    }
  };
  /**
   * A mouseover event handler to apply hover effect when a pointer device is
   * placed within the bounds of the block. The mouseover event is preferred
   * over mouseenter because it may be the case that a previous mouseenter
   * event was blocked from being handled by a IgnoreNestedEvents component,
   * therefore transitioning out of a nested block to the bounds of the block
   * would otherwise not trigger a hover effect.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/Events/mouseenter
   */


  var maybeHover = function maybeHover() {
    if (isBlockHovered || isPartOfMultiSelection || isSelected || hadTouchStart.current) {
      return;
    }

    setBlockHoveredState(true);
  }; // Set hover to false once we start typing or select the block.


  useEffect(function () {
    if (isTypingWithinBlock || isSelected) {
      hideHoverEffects();
    }
  }); // Handling the dragging state

  var _useState5 = useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      isDragging = _useState6[0],
      setBlockDraggingState = _useState6[1];

  var onDragStart = function onDragStart() {
    setBlockDraggingState(true);
  };

  var onDragEnd = function onDragEnd() {
    setBlockDraggingState(false);
  }; // Handling the error state


  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      hasError = _useState8[0],
      setErrorState = _useState8[1];

  var onBlockError = function onBlockError() {
    return setErrorState(true);
  }; // Handling of forceContextualToolbarFocus


  var isForcingContextualToolbar = useRef(false);
  useEffect(function () {
    if (isForcingContextualToolbar.current) {
      // The forcing of contextual toolbar should only be true during one update,
      // after the first update normal conditions should apply.
      isForcingContextualToolbar.current = false;
    }
  });

  var forceFocusedContextualToolbar = function forceFocusedContextualToolbar() {
    isForcingContextualToolbar.current = true; // trigger a re-render

    rerender();
  }; // Handing the focus of the block on creation and update

  /**
   * When a block becomes selected, transition focus to an inner tabbable.
   *
   * @param {boolean} ignoreInnerBlocks Should not focus inner blocks.
   */


  var focusTabbable = function focusTabbable(ignoreInnerBlocks) {
    // Focus is captured by the wrapper node, so while focus transition
    // should only consider tabbables within editable display, since it
    // may be the wrapper itself or a side control which triggered the
    // focus event, don't unnecessary transition to an inner tabbable.
    if (wrapper.current.contains(document.activeElement)) {
      return;
    }

    if (isNavigationMode) {
      breadcrumb.current.focus();
      return;
    } // Find all tabbables within node.


    var textInputs = focus.tabbable.find(blockNodeRef.current).filter(isTextField) // Exclude inner blocks
    .filter(function (node) {
      return !ignoreInnerBlocks || isInsideRootBlock(blockNodeRef.current, node);
    }); // If reversed (e.g. merge via backspace), use the last in the set of
    // tabbables.

    var isReverse = -1 === initialPosition;
    var target = (isReverse ? last : first)(textInputs);

    if (!target) {
      wrapper.current.focus();
      return;
    }

    placeCaretAtHorizontalEdge(target, isReverse);
  }; // Focus the selected block's wrapper or inner input on mount and update


  var isMounting = useRef(true);
  useEffect(function () {
    if (isSelected) {
      focusTabbable(!isMounting.current);
    }

    isMounting.current = false;
  }, [isSelected]); // Focus the first multi selected block

  useEffect(function () {
    if (isFirstMultiSelected) {
      wrapper.current.focus();
    }
  }, [isFirstMultiSelected]); // Block Reordering animation

  var animationStyle = useMovingAnimation(wrapper, isSelected || isPartOfMultiSelection, isSelected || isFirstMultiSelected, enableAnimation, animateOnChange); // Focus the breadcrumb if the wrapper is focused on navigation mode.
  // Focus the first editable or the wrapper if edit mode.

  useLayoutEffect(function () {
    if (isSelected) {
      if (isNavigationMode) {
        breadcrumb.current.focus();
      } else {
        focusTabbable(true);
      }
    }
  }, [isSelected, isNavigationMode]); // Other event handlers

  /**
   * Marks the block as selected when focused and not already selected. This
   * specifically handles the case where block does not set focus on its own
   * (via `setFocus`), typically if there is no focusable input in the block.
   */

  var onFocus = function onFocus() {
    if (!isSelected && !isPartOfMultiSelection) {
      onSelect();
    }
  };
  /**
   * Interprets keydown event intent to remove or insert after block if key
   * event occurs on wrapper node. This can occur when the block has no text
   * fields of its own, particularly after initial insertion, to allow for
   * easy deletion and continuous writing flow to add additional content.
   *
   * @param {KeyboardEvent} event Keydown event.
   */


  var onKeyDown = function onKeyDown(event) {
    var keyCode = event.keyCode,
        target = event.target; // ENTER/BACKSPACE Shortcuts are only available if the wrapper is focused
    // and the block is not locked.

    var canUseShortcuts = isSelected && !isLocked && (target === wrapper.current || target === breadcrumb.current);
    var isEditMode = !isNavigationMode;

    switch (keyCode) {
      case ENTER:
        if (canUseShortcuts && isEditMode) {
          // Insert default block after current block if enter and event
          // not already handled by descendant.
          onInsertDefaultBlockAfter();
          event.preventDefault();
        }

        break;

      case BACKSPACE:
      case DELETE:
        if (canUseShortcuts) {
          // Remove block on backspace.
          onRemove(clientId);
          event.preventDefault();
        }

        break;

      case ESCAPE:
        if (isSelected && isEditMode) {
          enableNavigationMode();
          wrapper.current.focus();
        }

        break;
    }
  };
  /**
   * Begins tracking cursor multi-selection when clicking down within block.
   *
   * @param {MouseEvent} event A mousedown event.
   */


  var onPointerDown = function onPointerDown(event) {
    // Not the main button.
    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
    if (event.button !== 0) {
      return;
    }

    if (event.shiftKey) {
      if (!isSelected) {
        onShiftSelection();
        event.preventDefault();
      } // Avoid triggering multi-selection if we click toolbars/inspectors
      // and all elements that are outside the Block Edit DOM tree.

    } else if (blockNodeRef.current.contains(event.target)) {
      onSelectionStart(clientId); // Allow user to escape out of a multi-selection to a singular
      // selection of a block via click. This is handled here since
      // onFocus excludes blocks involved in a multiselection, as
      // focus can be incurred by starting a multiselection (focus
      // moved to first block's multi-controls).

      if (isPartOfMultiSelection) {
        onSelect();
      }
    }
  };

  var selectOnOpen = function selectOnOpen(open) {
    if (open && !isSelected) {
      onSelect();
    }
  }; // Rendering the output


  var isHovered = isBlockHovered && !isPartOfMultiSelection;
  var blockType = getBlockType(name); // translators: %s: Type of block (i.e. Text, Image etc)

  var blockLabel = sprintf(__('Block: %s'), blockType.title); // The block as rendered in the editor is composed of general block UI
  // (mover, toolbar, wrapper) and the display of the block content.

  var isUnregisteredBlock = name === getUnregisteredTypeHandlerName(); // If the block is selected and we're typing the block should not appear.
  // Empty paragraph blocks should always show up as unselected.

  var showInserterShortcuts = !isNavigationMode && (isSelected || isHovered) && isEmptyDefaultBlock && isValid;
  var showEmptyBlockSideInserter = !isNavigationMode && (isSelected || isHovered || isLast) && isEmptyDefaultBlock && isValid;
  var shouldAppearSelected = !isFocusMode && !showEmptyBlockSideInserter && isSelected && !isTypingWithinBlock;
  var shouldAppearHovered = !isFocusMode && !hasFixedToolbar && isHovered && !isEmptyDefaultBlock; // We render block movers and block settings to keep them tabbale even if hidden

  var shouldRenderMovers = !isNavigationMode && isSelected && !showEmptyBlockSideInserter && !isPartOfMultiSelection && !isTypingWithinBlock;
  var shouldShowBreadcrumb = isSelected && isNavigationMode || !isNavigationMode && !isFocusMode && isHovered && !isEmptyDefaultBlock;
  var shouldShowContextualToolbar = !isNavigationMode && !hasFixedToolbar && !showEmptyBlockSideInserter && (isSelected && (!isTypingWithinBlock || isCaretWithinFormattedText) || isFirstMultiSelected);
  var shouldShowMobileToolbar = !isNavigationMode && shouldAppearSelected; // Insertion point can only be made visible if the block is at the
  // the extent of a multi-selection, or not in a multi-selection.

  var shouldShowInsertionPoint = isPartOfMultiSelection && isFirstMultiSelected || !isPartOfMultiSelection; // The wp-block className is important for editor styles.
  // Generate the wrapper class names handling the different states of the block.

  var wrapperClassName = classnames('wp-block editor-block-list__block block-editor-block-list__block', {
    'has-warning': !isValid || !!hasError || isUnregisteredBlock,
    'is-selected': shouldAppearSelected,
    'is-navigate-mode': isNavigationMode,
    'is-multi-selected': isPartOfMultiSelection,
    'is-hovered': shouldAppearHovered,
    'is-reusable': isReusableBlock(blockType),
    'is-dragging': isDragging,
    'is-typing': isTypingWithinBlock,
    'is-focused': isFocusMode && (isSelected || isParentOfSelectedBlock),
    'is-focus-mode': isFocusMode,
    'has-child-selected': isParentOfSelectedBlock
  }, className); // Determine whether the block has props to apply to the wrapper.

  if (blockType.getEditWrapperProps) {
    wrapperProps = _objectSpread({}, wrapperProps, blockType.getEditWrapperProps(attributes));
  }

  var blockElementId = "block-".concat(clientId); // We wrap the BlockEdit component in a div that hides it when editing in
  // HTML mode. This allows us to render all of the ancillary pieces
  // (InspectorControls, etc.) which are inside `BlockEdit` but not
  // `BlockHTML`, even in HTML mode.

  var blockEdit = createElement(BlockEdit, {
    name: name,
    isSelected: isSelected,
    attributes: attributes,
    setAttributes: setAttributes,
    insertBlocksAfter: isLocked ? undefined : onInsertBlocksAfter,
    onReplace: isLocked ? undefined : onReplace,
    mergeBlocks: isLocked ? undefined : onMerge,
    clientId: clientId,
    isSelectionEnabled: isSelectionEnabled,
    toggleSelection: toggleSelection
  });

  if (mode !== 'visual') {
    blockEdit = createElement("div", {
      style: {
        display: 'none'
      }
    }, blockEdit);
  }

  return createElement(IgnoreNestedEvents, _extends({
    id: blockElementId,
    ref: wrapper,
    onMouseOver: maybeHover,
    onMouseOverHandled: hideHoverEffects,
    onMouseLeave: hideHoverEffects,
    className: wrapperClassName,
    "data-type": name,
    onTouchStart: onTouchStart,
    onFocus: onFocus,
    onClick: onTouchStop,
    onKeyDown: onKeyDown,
    tabIndex: "0",
    "aria-label": blockLabel,
    childHandledEvents: ['onDragStart', 'onMouseDown'],
    tagName: animated.div
  }, wrapperProps, {
    style: wrapperProps && wrapperProps.style ? _objectSpread({}, wrapperProps.style, animationStyle) : animationStyle
  }), shouldShowInsertionPoint && createElement(BlockInsertionPoint, {
    clientId: clientId,
    rootClientId: rootClientId
  }), createElement(BlockDropZone, {
    clientId: clientId,
    rootClientId: rootClientId
  }), isFirstMultiSelected && createElement(BlockMultiControls, {
    rootClientId: rootClientId
  }), createElement("div", {
    className: "editor-block-list__block-edit block-editor-block-list__block-edit"
  }, shouldRenderMovers && createElement(BlockMover, {
    clientIds: clientId,
    blockElementId: blockElementId,
    isHidden: !isSelected,
    isDraggable: isDraggable !== false && !isPartOfMultiSelection && isMovable,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd
  }), shouldShowBreadcrumb && createElement(BlockBreadcrumb, {
    clientId: clientId,
    ref: breadcrumb
  }), (shouldShowContextualToolbar || isForcingContextualToolbar.current) && createElement(BlockContextualToolbar // If the toolbar is being shown because of being forced
  // it should focus the toolbar right after the mount.
  , {
    focusOnMount: isForcingContextualToolbar.current
  }), !isNavigationMode && !shouldShowContextualToolbar && isSelected && !hasFixedToolbar && !isEmptyDefaultBlock && createElement(KeyboardShortcuts, {
    bindGlobal: true,
    eventName: "keydown",
    shortcuts: {
      'alt+f10': forceFocusedContextualToolbar
    }
  }), createElement(IgnoreNestedEvents, {
    ref: blockNodeRef,
    onDragStart: preventDrag,
    onMouseDown: onPointerDown,
    "data-block": clientId
  }, createElement(BlockCrashBoundary, {
    onError: onBlockError
  }, isValid && blockEdit, isValid && mode === 'html' && createElement(BlockHtml, {
    clientId: clientId
  }), !isValid && [createElement(BlockInvalidWarning, {
    key: "invalid-warning",
    clientId: clientId
  }), createElement("div", {
    key: "invalid-preview"
  }, getSaveElement(blockType, attributes))]), !!hasError && createElement(BlockCrashWarning, null), shouldShowMobileToolbar && createElement(BlockMobileToolbar, {
    clientId: clientId
  }))), showInserterShortcuts && createElement("div", {
    className: "editor-block-list__side-inserter block-editor-block-list__side-inserter"
  }, createElement(InserterWithShortcuts, {
    clientId: clientId,
    rootClientId: rootClientId,
    onToggle: selectOnOpen
  })), showEmptyBlockSideInserter && createElement("div", {
    className: "editor-block-list__empty-block-inserter block-editor-block-list__empty-block-inserter"
  }, createElement(Inserter, {
    position: "top right",
    onToggle: selectOnOpen,
    rootClientId: rootClientId,
    clientId: clientId
  })));
}

var applyWithSelect = withSelect(function (select, _ref2) {
  var clientId = _ref2.clientId,
      rootClientId = _ref2.rootClientId,
      isLargeViewport = _ref2.isLargeViewport;

  var _select = select('core/block-editor'),
      isBlockSelected = _select.isBlockSelected,
      isAncestorMultiSelected = _select.isAncestorMultiSelected,
      isBlockMultiSelected = _select.isBlockMultiSelected,
      isFirstMultiSelectedBlock = _select.isFirstMultiSelectedBlock,
      isTyping = _select.isTyping,
      isCaretWithinFormattedText = _select.isCaretWithinFormattedText,
      getBlockMode = _select.getBlockMode,
      isSelectionEnabled = _select.isSelectionEnabled,
      getSelectedBlocksInitialCaretPosition = _select.getSelectedBlocksInitialCaretPosition,
      getSettings = _select.getSettings,
      hasSelectedInnerBlock = _select.hasSelectedInnerBlock,
      getTemplateLock = _select.getTemplateLock,
      getBlockIndex = _select.getBlockIndex,
      getBlockOrder = _select.getBlockOrder,
      __unstableGetBlockWithoutInnerBlocks = _select.__unstableGetBlockWithoutInnerBlocks,
      isNavigationMode = _select.isNavigationMode;

  var block = __unstableGetBlockWithoutInnerBlocks(clientId);

  var isSelected = isBlockSelected(clientId);

  var _getSettings = getSettings(),
      hasFixedToolbar = _getSettings.hasFixedToolbar,
      focusMode = _getSettings.focusMode,
      isRTL = _getSettings.isRTL;

  var templateLock = getTemplateLock(rootClientId);
  var isParentOfSelectedBlock = hasSelectedInnerBlock(clientId, true);
  var index = getBlockIndex(clientId, rootClientId);
  var blockOrder = getBlockOrder(rootClientId); // The fallback to `{}` is a temporary fix.
  // This function should never be called when a block is not present in the state.
  // It happens now because the order in withSelect rendering is not correct.

  var _ref3 = block || {},
      name = _ref3.name,
      attributes = _ref3.attributes,
      isValid = _ref3.isValid;

  return {
    isPartOfMultiSelection: isBlockMultiSelected(clientId) || isAncestorMultiSelected(clientId),
    isFirstMultiSelected: isFirstMultiSelectedBlock(clientId),
    // We only care about this prop when the block is selected
    // Thus to avoid unnecessary rerenders we avoid updating the prop if the block is not selected.
    isTypingWithinBlock: (isSelected || isParentOfSelectedBlock) && isTyping(),
    isCaretWithinFormattedText: isCaretWithinFormattedText(),
    mode: getBlockMode(clientId),
    isSelectionEnabled: isSelectionEnabled(),
    initialPosition: isSelected ? getSelectedBlocksInitialCaretPosition() : null,
    isEmptyDefaultBlock: name && isUnmodifiedDefaultBlock({
      name: name,
      attributes: attributes
    }),
    isMovable: 'all' !== templateLock,
    isLocked: !!templateLock,
    isFocusMode: focusMode && isLargeViewport,
    hasFixedToolbar: hasFixedToolbar && isLargeViewport,
    isLast: index === blockOrder.length - 1,
    isNavigationMode: isNavigationMode(),
    isRTL: isRTL,
    // Users of the editor.BlockListBlock filter used to be able to access the block prop
    // Ideally these blocks would rely on the clientId prop only.
    // This is kept for backward compatibility reasons.
    block: block,
    name: name,
    attributes: attributes,
    isValid: isValid,
    isSelected: isSelected,
    isParentOfSelectedBlock: isParentOfSelectedBlock
  };
});
var applyWithDispatch = withDispatch(function (dispatch, ownProps, _ref4) {
  var select = _ref4.select;

  var _dispatch = dispatch('core/block-editor'),
      updateBlockAttributes = _dispatch.updateBlockAttributes,
      selectBlock = _dispatch.selectBlock,
      multiSelect = _dispatch.multiSelect,
      insertBlocks = _dispatch.insertBlocks,
      insertDefaultBlock = _dispatch.insertDefaultBlock,
      removeBlock = _dispatch.removeBlock,
      mergeBlocks = _dispatch.mergeBlocks,
      replaceBlocks = _dispatch.replaceBlocks,
      _toggleSelection = _dispatch.toggleSelection,
      setNavigationMode = _dispatch.setNavigationMode,
      __unstableMarkLastChangeAsPersistent = _dispatch.__unstableMarkLastChangeAsPersistent;

  return {
    setAttributes: function setAttributes(newAttributes) {
      var clientId = ownProps.clientId;
      updateBlockAttributes(clientId, newAttributes);
    },
    onSelect: function onSelect() {
      var clientId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ownProps.clientId;
      var initialPosition = arguments.length > 1 ? arguments[1] : undefined;
      selectBlock(clientId, initialPosition);
    },
    onInsertBlocks: function onInsertBlocks(blocks, index) {
      var rootClientId = ownProps.rootClientId;
      insertBlocks(blocks, index, rootClientId);
    },
    onInsertDefaultBlockAfter: function onInsertDefaultBlockAfter() {
      var clientId = ownProps.clientId,
          rootClientId = ownProps.rootClientId;

      var _select2 = select('core/block-editor'),
          getBlockIndex = _select2.getBlockIndex;

      var index = getBlockIndex(clientId, rootClientId);
      insertDefaultBlock({}, rootClientId, index + 1);
    },
    onInsertBlocksAfter: function onInsertBlocksAfter(blocks) {
      var clientId = ownProps.clientId,
          rootClientId = ownProps.rootClientId;

      var _select3 = select('core/block-editor'),
          getBlockIndex = _select3.getBlockIndex;

      var index = getBlockIndex(clientId, rootClientId);
      insertBlocks(blocks, index + 1, rootClientId);
    },
    onRemove: function onRemove(clientId) {
      removeBlock(clientId);
    },
    onMerge: function onMerge(forward) {
      var clientId = ownProps.clientId;

      var _select4 = select('core/block-editor'),
          getPreviousBlockClientId = _select4.getPreviousBlockClientId,
          getNextBlockClientId = _select4.getNextBlockClientId;

      if (forward) {
        var nextBlockClientId = getNextBlockClientId(clientId);

        if (nextBlockClientId) {
          mergeBlocks(clientId, nextBlockClientId);
        }
      } else {
        var previousBlockClientId = getPreviousBlockClientId(clientId);

        if (previousBlockClientId) {
          mergeBlocks(previousBlockClientId, clientId);
        }
      }
    },
    onReplace: function onReplace(blocks, indexToSelect) {
      if (blocks.length && !isUnmodifiedDefaultBlock(blocks[blocks.length - 1])) {
        __unstableMarkLastChangeAsPersistent();
      }

      replaceBlocks([ownProps.clientId], blocks, indexToSelect);
    },
    onShiftSelection: function onShiftSelection() {
      if (!ownProps.isSelectionEnabled) {
        return;
      }

      var _select5 = select('core/block-editor'),
          getBlockSelectionStart = _select5.getBlockSelectionStart;

      if (getBlockSelectionStart()) {
        multiSelect(getBlockSelectionStart(), ownProps.clientId);
      } else {
        selectBlock(ownProps.clientId);
      }
    },
    toggleSelection: function toggleSelection(selectionEnabled) {
      _toggleSelection(selectionEnabled);
    },
    enableNavigationMode: function enableNavigationMode() {
      setNavigationMode(true);
    }
  };
});
export default compose(pure, withViewportMatch({
  isLargeViewport: 'medium'
}), applyWithSelect, applyWithDispatch, // block is sometimes not mounted at the right time, causing it be undefined
// see issue for more info https://github.com/WordPress/gutenberg/issues/17013
ifCondition(function (_ref5) {
  var block = _ref5.block;
  return !!block;
}), withFilters('editor.BlockListBlock'))(BlockListBlock);
//# sourceMappingURL=block.js.map