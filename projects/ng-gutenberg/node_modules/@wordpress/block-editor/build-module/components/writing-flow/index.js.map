{"version":3,"sources":["@wordpress/block-editor/src/components/writing-flow/index.js"],"names":["overEvery","find","findLast","reverse","first","last","Component","createRef","computeCaretRect","focus","isHorizontalEdge","isTextField","isVerticalEdge","placeCaretAtHorizontalEdge","placeCaretAtVerticalEdge","isEntirelySelected","UP","DOWN","LEFT","RIGHT","TAB","isKeyboardEvent","withSelect","withDispatch","compose","isBlockFocusStop","isInSameBlock","hasInnerBlocksContext","window","getSelection","getComputedStyle","isTabbableTextField","tabbable","isTabbableIndex","isNavigationCandidate","element","keyCode","hasModifier","isVertical","tagName","WritingFlow","arguments","onKeyDown","bind","bindContainer","onMouseDown","focusLastTextField","verticalRect","appender","ref","container","disableNavigationMode","props","isNavigationMode","target","isReverse","focusableNodes","focusable","slice","indexOf","isTabCandidate","node","i","array","contains","offset","nextNode","selectedBlockClientId","selectionStartClientId","selectionBeforeEndClientId","selectionAfterEndClientId","nextSelectionEndClientId","onMultiSelect","selectedFirstClientId","selectedLastClientId","focusedBlockClientId","onSelectBlock","closestTabbable","getClosestTabbable","event","hasMultiSelection","blocks","isUp","isDown","isLeft","isRight","isTab","isHorizontal","isNav","isShift","shiftKey","ctrlKey","altKey","metaKey","isNavEdge","navigateUp","navigateDown","focusedBlockUid","preventDefault","clearSelectedBlock","current","primary","isContentEditable","nativeEvent","defaultPrevented","direction","isReverseDir","isTabbableEdge","expandSelection","moveSelection","isCollapsed","children","select","getSelectedBlockClientId","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getPreviousBlockClientId","getNextBlockClientId","getFirstMultiSelectedBlockClientId","getLastMultiSelectedBlockClientId","getBlockOrder","selectionEndClientId","dispatch","multiSelect","selectBlock","setNavigationMode"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { overEvery, find, findLast, reverse, first, last } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { Component, createRef } from '@wordpress/element';\nimport {\n\tcomputeCaretRect,\n\tfocus,\n\tisHorizontalEdge,\n\tisTextField,\n\tisVerticalEdge,\n\tplaceCaretAtHorizontalEdge,\n\tplaceCaretAtVerticalEdge,\n\tisEntirelySelected,\n} from '@wordpress/dom';\nimport { UP, DOWN, LEFT, RIGHT, TAB, isKeyboardEvent } from '@wordpress/keycodes';\nimport { withSelect, withDispatch } from '@wordpress/data';\nimport { compose } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport {\n\tisBlockFocusStop,\n\tisInSameBlock,\n\thasInnerBlocksContext,\n} from '../../utils/dom';\n\n/**\n * Browser constants\n */\n\nconst { getSelection, getComputedStyle } = window;\n\n/**\n * Given an element, returns true if the element is a tabbable text field, or\n * false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is a tabbable text field.\n */\nconst isTabbableTextField = overEvery( [\n\tisTextField,\n\tfocus.tabbable.isTabbableIndex,\n] );\n\n/**\n * Returns true if the element should consider edge navigation upon a keyboard\n * event of the given directional key code, or false otherwise.\n *\n * @param {Element} element     HTML element to test.\n * @param {number}  keyCode     KeyboardEvent keyCode to test.\n * @param {boolean} hasModifier Whether a modifier is pressed.\n *\n * @return {boolean} Whether element should consider edge navigation.\n */\nexport function isNavigationCandidate( element, keyCode, hasModifier ) {\n\tconst isVertical = ( keyCode === UP || keyCode === DOWN );\n\n\t// Currently, all elements support unmodified vertical navigation.\n\tif ( isVertical && ! hasModifier ) {\n\t\treturn true;\n\t}\n\n\t// Native inputs should not navigate horizontally.\n\tconst { tagName } = element;\n\treturn tagName !== 'INPUT' && tagName !== 'TEXTAREA';\n}\n\nclass WritingFlow extends Component {\n\tconstructor() {\n\t\tsuper( ...arguments );\n\n\t\tthis.onKeyDown = this.onKeyDown.bind( this );\n\t\tthis.bindContainer = this.bindContainer.bind( this );\n\t\tthis.onMouseDown = this.onMouseDown.bind( this );\n\t\tthis.focusLastTextField = this.focusLastTextField.bind( this );\n\n\t\t/**\n\t\t * Here a rectangle is stored while moving the caret vertically so\n\t\t * vertical position of the start position can be restored.\n\t\t * This is to recreate browser behaviour across blocks.\n\t\t *\n\t\t * @type {?DOMRect}\n\t\t */\n\t\tthis.verticalRect = null;\n\n\t\t/**\n\t\t * Reference of the writing flow appender element.\n\t\t * The reference is used to focus the first tabbable element after the block list\n\t\t * once we hit `tab` on the last block in navigation mode.\n\t\t */\n\t\tthis.appender = createRef();\n\t}\n\n\tbindContainer( ref ) {\n\t\tthis.container = ref;\n\t}\n\n\tonMouseDown() {\n\t\tthis.verticalRect = null;\n\t\tthis.disableNavigationMode();\n\t}\n\n\tdisableNavigationMode() {\n\t\tif ( this.props.isNavigationMode ) {\n\t\t\tthis.props.disableNavigationMode();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the optimal tab target from the given focused element in the\n\t * desired direction. A preference is made toward text fields, falling back\n\t * to the block focus stop if no other candidates exist for the block.\n\t *\n\t * @param {Element} target    Currently focused text field.\n\t * @param {boolean} isReverse True if considering as the first field.\n\t *\n\t * @return {?Element} Optimal tab target, if one exists.\n\t */\n\tgetClosestTabbable( target, isReverse ) {\n\t\t// Since the current focus target is not guaranteed to be a text field,\n\t\t// find all focusables. Tabbability is considered later.\n\t\tlet focusableNodes = focus.focusable.find( this.container );\n\n\t\tif ( isReverse ) {\n\t\t\tfocusableNodes = reverse( focusableNodes );\n\t\t}\n\n\t\t// Consider as candidates those focusables after the current target.\n\t\t// It's assumed this can only be reached if the target is focusable\n\t\t// (on its keydown event), so no need to verify it exists in the set.\n\t\tfocusableNodes = focusableNodes.slice( focusableNodes.indexOf( target ) + 1 );\n\n\t\tfunction isTabCandidate( node, i, array ) {\n\t\t\t// Not a candidate if the node is not tabbable.\n\t\t\tif ( ! focus.tabbable.isTabbableIndex( node ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Prefer text fields...\n\t\t\tif ( isTextField( node ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// ...but settle for block focus stop.\n\t\t\tif ( ! isBlockFocusStop( node ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If element contains inner blocks, stop immediately at its focus\n\t\t\t// wrapper.\n\t\t\tif ( hasInnerBlocksContext( node ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// If navigating out of a block (in reverse), don't consider its\n\t\t\t// block focus stop.\n\t\t\tif ( node.contains( target ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// In case of block focus stop, check to see if there's a better\n\t\t\t// text field candidate within.\n\t\t\tfor ( let offset = 1, nextNode; ( nextNode = array[ i + offset ] ); offset++ ) {\n\t\t\t\t// Abort if no longer testing descendents of focus stop.\n\t\t\t\tif ( ! node.contains( nextNode ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Apply same tests by recursion. This is important to consider\n\t\t\t\t// nestable blocks where we don't want to settle for the inner\n\t\t\t\t// block focus stop.\n\t\t\t\tif ( isTabCandidate( nextNode, i + offset, array ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn find( focusableNodes, isTabCandidate );\n\t}\n\n\texpandSelection( isReverse ) {\n\t\tconst {\n\t\t\tselectedBlockClientId,\n\t\t\tselectionStartClientId,\n\t\t\tselectionBeforeEndClientId,\n\t\t\tselectionAfterEndClientId,\n\t\t} = this.props;\n\n\t\tconst nextSelectionEndClientId = isReverse ?\n\t\t\tselectionBeforeEndClientId :\n\t\t\tselectionAfterEndClientId;\n\n\t\tif ( nextSelectionEndClientId ) {\n\t\t\tthis.props.onMultiSelect(\n\t\t\t\tselectionStartClientId || selectedBlockClientId,\n\t\t\t\tnextSelectionEndClientId\n\t\t\t);\n\t\t}\n\t}\n\n\tmoveSelection( isReverse ) {\n\t\tconst { selectedFirstClientId, selectedLastClientId } = this.props;\n\n\t\tconst focusedBlockClientId = isReverse ? selectedFirstClientId : selectedLastClientId;\n\n\t\tif ( focusedBlockClientId ) {\n\t\t\tthis.props.onSelectBlock( focusedBlockClientId );\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the given target field is the last in its block which\n\t * can be considered for tab transition. For example, in a block with two\n\t * text fields, this would return true when reversing from the first of the\n\t * two fields, but false when reversing from the second.\n\t *\n\t * @param {Element} target    Currently focused text field.\n\t * @param {boolean} isReverse True if considering as the first field.\n\t *\n\t * @return {boolean} Whether field is at edge for tab transition.\n\t */\n\tisTabbableEdge( target, isReverse ) {\n\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\t\treturn ! closestTabbable || ! isInSameBlock( target, closestTabbable );\n\t}\n\n\tonKeyDown( event ) {\n\t\tconst {\n\t\t\thasMultiSelection,\n\t\t\tonMultiSelect,\n\t\t\tblocks,\n\t\t\tselectedBlockClientId,\n\t\t\tselectionBeforeEndClientId,\n\t\t\tselectionAfterEndClientId,\n\t\t\tisNavigationMode,\n\t\t} = this.props;\n\n\t\tconst { keyCode, target } = event;\n\t\tconst isUp = keyCode === UP;\n\t\tconst isDown = keyCode === DOWN;\n\t\tconst isLeft = keyCode === LEFT;\n\t\tconst isRight = keyCode === RIGHT;\n\t\tconst isTab = keyCode === TAB;\n\t\tconst isReverse = isUp || isLeft;\n\t\tconst isHorizontal = isLeft || isRight;\n\t\tconst isVertical = isUp || isDown;\n\t\tconst isNav = isHorizontal || isVertical;\n\t\tconst isShift = event.shiftKey;\n\t\tconst hasModifier = isShift || event.ctrlKey || event.altKey || event.metaKey;\n\t\tconst isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;\n\n\t\t// In navigation mode, tab and arrows navigate from block to block.\n\t\tif ( isNavigationMode ) {\n\t\t\tconst navigateUp = ( isTab && isShift ) || isUp;\n\t\t\tconst navigateDown = ( isTab && ! isShift ) || isDown;\n\t\t\tconst focusedBlockUid = navigateUp ? selectionBeforeEndClientId : selectionAfterEndClientId;\n\n\t\t\tif (\n\t\t\t\t( navigateDown || navigateUp ) &&\n\t\t\t\tfocusedBlockUid\n\t\t\t) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.props.onSelectBlock( focusedBlockUid );\n\t\t\t}\n\n\t\t\t// Special case when reaching the end of the blocks (navigate to the next tabbable outside of the writing flow)\n\t\t\tif ( navigateDown && selectedBlockClientId && ! selectionAfterEndClientId && [ UP, DOWN ].indexOf( keyCode ) === -1 ) {\n\t\t\t\tthis.props.clearSelectedBlock();\n\t\t\t\tthis.appender.current.focus();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// When presing any key other than up or down, the initial vertical\n\t\t// position must ALWAYS be reset. The vertical position is saved so it\n\t\t// can be restored as well as possible on sebsequent vertical arrow key\n\t\t// presses. It may not always be possible to restore the exact same\n\t\t// position (such as at an empty line), so it wouldn't be good to\n\t\t// compute the position right before any vertical arrow key press.\n\t\tif ( ! isVertical ) {\n\t\t\tthis.verticalRect = null;\n\t\t} else if ( ! this.verticalRect ) {\n\t\t\tthis.verticalRect = computeCaretRect();\n\t\t}\n\n\t\t// This logic inside this condition needs to be checked before\n\t\t// the check for event.nativeEvent.defaultPrevented.\n\t\t// The logic handles meta+a keypress and this event is default prevented\n\t\t// by RichText.\n\t\tif ( ! isNav ) {\n\t\t\t// Set immediately before the meta+a combination can be pressed.\n\t\t\tif ( isKeyboardEvent.primary( event ) ) {\n\t\t\t\tthis.isEntirelySelected = isEntirelySelected( target );\n\t\t\t}\n\n\t\t\tif ( isKeyboardEvent.primary( event, 'a' ) ) {\n\t\t\t\t// When the target is contentEditable, selection will already\n\t\t\t\t// have been set by the browser earlier in this call stack. We\n\t\t\t\t// need check the previous result, otherwise all blocks will be\n\t\t\t\t// selected right away.\n\t\t\t\tif ( target.isContentEditable ? this.isEntirelySelected : isEntirelySelected( target ) ) {\n\t\t\t\t\tonMultiSelect( first( blocks ), last( blocks ) );\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\t// After pressing primary + A we can assume isEntirelySelected is true.\n\t\t\t\t// Calling right away isEntirelySelected after primary + A may still return false on some browsers.\n\t\t\t\tthis.isEntirelySelected = true;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Abort if navigation has already been handled (e.g. RichText inline\n\t\t// boundaries).\n\t\tif ( event.nativeEvent.defaultPrevented ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Abort if our current target is not a candidate for navigation (e.g.\n\t\t// preserve native input behaviors).\n\t\tif ( ! isNavigationCandidate( target, keyCode, hasModifier ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// In the case of RTL scripts, right means previous and left means next,\n\t\t// which is the exact reverse of LTR.\n\t\tconst { direction } = getComputedStyle( target );\n\t\tconst isReverseDir = direction === 'rtl' ? ( ! isReverse ) : isReverse;\n\n\t\tif ( isShift ) {\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\t// Ensure that there is a target block.\n\t\t\t\t\t( isReverse && selectionBeforeEndClientId ) ||\n\t\t\t\t\t( ! isReverse && selectionAfterEndClientId )\n\t\t\t\t) && (\n\t\t\t\t\thasMultiSelection || (\n\t\t\t\t\t\tthis.isTabbableEdge( target, isReverse ) &&\n\t\t\t\t\t\tisNavEdge( target, isReverse )\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Shift key is down, and there is multi selection or we're at\n\t\t\t\t// the end of the current block.\n\t\t\t\tthis.expandSelection( isReverse );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t} else if ( hasMultiSelection ) {\n\t\t\t// Moving from block multi-selection to single block selection\n\t\t\tthis.moveSelection( isReverse );\n\t\t\tevent.preventDefault();\n\t\t} else if ( isVertical && isVerticalEdge( target, isReverse ) ) {\n\t\t\tconst closestTabbable = this.getClosestTabbable( target, isReverse );\n\n\t\t\tif ( closestTabbable ) {\n\t\t\t\tplaceCaretAtVerticalEdge( closestTabbable, isReverse, this.verticalRect );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t} else if ( isHorizontal && getSelection().isCollapsed && isHorizontalEdge( target, isReverseDir ) ) {\n\t\t\tconst closestTabbable = this.getClosestTabbable( target, isReverseDir );\n\t\t\tplaceCaretAtHorizontalEdge( closestTabbable, isReverseDir );\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\t/**\n\t * Sets focus to the end of the last tabbable text field, if one exists.\n\t */\n\tfocusLastTextField() {\n\t\tthis.disableNavigationMode();\n\t\tconst focusableNodes = focus.focusable.find( this.container );\n\t\tconst target = findLast( focusableNodes, isTabbableTextField );\n\t\tif ( target ) {\n\t\t\tplaceCaretAtHorizontalEdge( target, true );\n\t\t}\n\t}\n\n\trender() {\n\t\tconst { children } = this.props;\n\n\t\t// Disable reason: Wrapper itself is non-interactive, but must capture\n\t\t// bubbling events from children to determine focus transition intents.\n\t\t/* eslint-disable jsx-a11y/no-static-element-interactions */\n\t\treturn (\n\t\t\t<div className=\"editor-writing-flow block-editor-writing-flow\">\n\t\t\t\t<div\n\t\t\t\t\tref={ this.bindContainer }\n\t\t\t\t\tonKeyDown={ this.onKeyDown }\n\t\t\t\t\tonMouseDown={ this.onMouseDown }\n\t\t\t\t>\n\t\t\t\t\t{ children }\n\t\t\t\t</div>\n\t\t\t\t<div\n\t\t\t\t\tref={ this.appender }\n\t\t\t\t\taria-hidden\n\t\t\t\t\ttabIndex={ -1 }\n\t\t\t\t\tonClick={ this.focusLastTextField }\n\t\t\t\t\tclassName=\"editor-writing-flow__click-redirect block-editor-writing-flow__click-redirect\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t\t/* eslint-enable jsx-a11y/no-static-element-interactions */\n\t}\n}\n\nexport default compose( [\n\twithSelect( ( select ) => {\n\t\tconst {\n\t\t\tgetSelectedBlockClientId,\n\t\t\tgetMultiSelectedBlocksStartClientId,\n\t\t\tgetMultiSelectedBlocksEndClientId,\n\t\t\tgetPreviousBlockClientId,\n\t\t\tgetNextBlockClientId,\n\t\t\tgetFirstMultiSelectedBlockClientId,\n\t\t\tgetLastMultiSelectedBlockClientId,\n\t\t\thasMultiSelection,\n\t\t\tgetBlockOrder,\n\t\t\tisNavigationMode,\n\t\t} = select( 'core/block-editor' );\n\n\t\tconst selectedBlockClientId = getSelectedBlockClientId();\n\t\tconst selectionStartClientId = getMultiSelectedBlocksStartClientId();\n\t\tconst selectionEndClientId = getMultiSelectedBlocksEndClientId();\n\n\t\treturn {\n\t\t\tselectedBlockClientId,\n\t\t\tselectionStartClientId,\n\t\t\tselectionBeforeEndClientId: getPreviousBlockClientId( selectionEndClientId || selectedBlockClientId ),\n\t\t\tselectionAfterEndClientId: getNextBlockClientId( selectionEndClientId || selectedBlockClientId ),\n\t\t\tselectedFirstClientId: getFirstMultiSelectedBlockClientId(),\n\t\t\tselectedLastClientId: getLastMultiSelectedBlockClientId(),\n\t\t\thasMultiSelection: hasMultiSelection(),\n\t\t\tblocks: getBlockOrder(),\n\t\t\tisNavigationMode: isNavigationMode(),\n\t\t};\n\t} ),\n\twithDispatch( ( dispatch ) => {\n\t\tconst { multiSelect, selectBlock, setNavigationMode, clearSelectedBlock } = dispatch( 'core/block-editor' );\n\t\treturn {\n\t\t\tonMultiSelect: multiSelect,\n\t\t\tonSelectBlock: selectBlock,\n\t\t\tdisableNavigationMode: () => setNavigationMode( false ),\n\t\t\tclearSelectedBlock,\n\t\t};\n\t} ),\n] )( WritingFlow );\n"]}