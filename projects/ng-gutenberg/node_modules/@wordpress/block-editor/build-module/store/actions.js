import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _regeneratorRuntime from "@babel/runtime/regenerator";

var _marked =
/*#__PURE__*/
_regeneratorRuntime.mark(ensureDefaultBlock),
    _marked2 =
/*#__PURE__*/
_regeneratorRuntime.mark(selectPreviousBlock),
    _marked3 =
/*#__PURE__*/
_regeneratorRuntime.mark(selectNextBlock),
    _marked4 =
/*#__PURE__*/
_regeneratorRuntime.mark(replaceBlocks),
    _marked5 =
/*#__PURE__*/
_regeneratorRuntime.mark(moveBlockToPosition),
    _marked6 =
/*#__PURE__*/
_regeneratorRuntime.mark(insertBlocks),
    _marked7 =
/*#__PURE__*/
_regeneratorRuntime.mark(removeBlocks);

/**
 * External dependencies
 */
import { castArray, first, get, includes } from 'lodash';
/**
 * WordPress dependencies
 */

import { getDefaultBlockName, createBlock } from '@wordpress/blocks';
/**
 * Internal dependencies
 */

import { select } from './controls';
/**
 * Generator which will yield a default block insert action if there
 * are no other blocks at the root of the editor. This generator should be used
 * in actions which may result in no blocks remaining in the editor (removal,
 * replacement, etc).
 */

function ensureDefaultBlock() {
  var count;
  return _regeneratorRuntime.wrap(function ensureDefaultBlock$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return select('core/block-editor', 'getBlockCount');

        case 2:
          count = _context.sent;

          if (!(count === 0)) {
            _context.next = 6;
            break;
          }

          _context.next = 6;
          return insertDefaultBlock();

        case 6:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
/**
 * Returns an action object used in signalling that blocks state should be
 * reset to the specified array of blocks, taking precedence over any other
 * content reflected as an edit in state.
 *
 * @param {Array} blocks Array of blocks.
 *
 * @return {Object} Action object.
 */


export function resetBlocks(blocks) {
  return {
    type: 'RESET_BLOCKS',
    blocks: blocks
  };
}
/**
 * Returns an action object used in signalling that blocks have been received.
 * Unlike resetBlocks, these should be appended to the existing known set, not
 * replacing.
 *
 * @param {Object[]} blocks Array of block objects.
 *
 * @return {Object} Action object.
 */

export function receiveBlocks(blocks) {
  return {
    type: 'RECEIVE_BLOCKS',
    blocks: blocks
  };
}
/**
 * Returns an action object used in signalling that the block attributes with
 * the specified client ID has been updated.
 *
 * @param {string} clientId   Block client ID.
 * @param {Object} attributes Block attributes to be merged.
 *
 * @return {Object} Action object.
 */

export function updateBlockAttributes(clientId, attributes) {
  return {
    type: 'UPDATE_BLOCK_ATTRIBUTES',
    clientId: clientId,
    attributes: attributes
  };
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been updated.
 *
 * @param {string} clientId Block client ID.
 * @param {Object} updates  Block attributes to be merged.
 *
 * @return {Object} Action object.
 */

export function updateBlock(clientId, updates) {
  return {
    type: 'UPDATE_BLOCK',
    clientId: clientId,
    updates: updates
  };
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been selected, optionally accepting a position
 * value reflecting its selection directionality. An initialPosition of -1
 * reflects a reverse selection.
 *
 * @param {string}  clientId        Block client ID.
 * @param {?number} initialPosition Optional initial position. Pass as -1 to
 *                                  reflect reverse selection.
 *
 * @return {Object} Action object.
 */

export function selectBlock(clientId) {
  var initialPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return {
    type: 'SELECT_BLOCK',
    initialPosition: initialPosition,
    clientId: clientId
  };
}
/**
 * Yields action objects used in signalling that the block preceding the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */

export function selectPreviousBlock(clientId) {
  var previousBlockClientId;
  return _regeneratorRuntime.wrap(function selectPreviousBlock$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return select('core/block-editor', 'getPreviousBlockClientId', clientId);

        case 2:
          previousBlockClientId = _context2.sent;

          if (!previousBlockClientId) {
            _context2.next = 6;
            break;
          }

          _context2.next = 6;
          return selectBlock(previousBlockClientId, -1);

        case 6:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}
/**
 * Yields action objects used in signalling that the block following the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */

export function selectNextBlock(clientId) {
  var nextBlockClientId;
  return _regeneratorRuntime.wrap(function selectNextBlock$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return select('core/block-editor', 'getNextBlockClientId', clientId);

        case 2:
          nextBlockClientId = _context3.sent;

          if (!nextBlockClientId) {
            _context3.next = 6;
            break;
          }

          _context3.next = 6;
          return selectBlock(nextBlockClientId);

        case 6:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}
/**
 * Returns an action object used in signalling that a block multi-selection has started.
 *
 * @return {Object} Action object.
 */

export function startMultiSelect() {
  return {
    type: 'START_MULTI_SELECT'
  };
}
/**
 * Returns an action object used in signalling that block multi-selection stopped.
 *
 * @return {Object} Action object.
 */

export function stopMultiSelect() {
  return {
    type: 'STOP_MULTI_SELECT'
  };
}
/**
 * Returns an action object used in signalling that block multi-selection changed.
 *
 * @param {string} start First block of the multi selection.
 * @param {string} end   Last block of the multiselection.
 *
 * @return {Object} Action object.
 */

export function multiSelect(start, end) {
  return {
    type: 'MULTI_SELECT',
    start: start,
    end: end
  };
}
/**
 * Returns an action object used in signalling that the block selection is cleared.
 *
 * @return {Object} Action object.
 */

export function clearSelectedBlock() {
  return {
    type: 'CLEAR_SELECTED_BLOCK'
  };
}
/**
 * Returns an action object that enables or disables block selection.
 *
 * @param {boolean} [isSelectionEnabled=true] Whether block selection should
 *                                            be enabled.
 *
 * @return {Object} Action object.
 */

export function toggleSelection() {
  var isSelectionEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return {
    type: 'TOGGLE_SELECTION',
    isSelectionEnabled: isSelectionEnabled
  };
}

function getBlocksWithDefaultStylesApplied(blocks, blockEditorSettings) {
  var preferredStyleVariations = get(blockEditorSettings, ['__experimentalPreferredStyleVariations', 'value'], {});
  return blocks.map(function (block) {
    var blockName = block.name;

    if (!preferredStyleVariations[blockName]) {
      return block;
    }

    var className = get(block, ['attributes', 'className']);

    if (includes(className, 'is-style-')) {
      return block;
    }

    var _block$attributes = block.attributes,
        attributes = _block$attributes === void 0 ? {} : _block$attributes;
    var blockStyle = preferredStyleVariations[blockName];
    return _objectSpread({}, block, {
      attributes: _objectSpread({}, attributes, {
        className: "".concat(className || '', " is-style-").concat(blockStyle).trim()
      })
    });
  });
}
/**
 * Returns an action object signalling that a blocks should be replaced with
 * one or more replacement blocks.
 *
 * @param {(string|string[])} clientIds     Block client ID(s) to replace.
 * @param {(Object|Object[])} blocks        Replacement block(s).
 * @param {number}            indexToSelect Index of replacement block to
 *                                          select.
 *
 * @yield {Object} Action object.
 */


export function replaceBlocks(clientIds, blocks, indexToSelect) {
  var rootClientId, index, block, canInsertBlock;
  return _regeneratorRuntime.wrap(function replaceBlocks$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          clientIds = castArray(clientIds);
          _context4.t0 = getBlocksWithDefaultStylesApplied;
          _context4.t1 = castArray(blocks);
          _context4.next = 5;
          return select('core/block-editor', 'getSettings');

        case 5:
          _context4.t2 = _context4.sent;
          blocks = (0, _context4.t0)(_context4.t1, _context4.t2);
          _context4.next = 9;
          return select('core/block-editor', 'getBlockRootClientId', first(clientIds));

        case 9:
          rootClientId = _context4.sent;
          index = 0;

        case 11:
          if (!(index < blocks.length)) {
            _context4.next = 21;
            break;
          }

          block = blocks[index];
          _context4.next = 15;
          return select('core/block-editor', 'canInsertBlockType', block.name, rootClientId);

        case 15:
          canInsertBlock = _context4.sent;

          if (canInsertBlock) {
            _context4.next = 18;
            break;
          }

          return _context4.abrupt("return");

        case 18:
          index++;
          _context4.next = 11;
          break;

        case 21:
          _context4.next = 23;
          return {
            type: 'REPLACE_BLOCKS',
            clientIds: clientIds,
            blocks: blocks,
            time: Date.now(),
            indexToSelect: indexToSelect
          };

        case 23:
          return _context4.delegateYield(ensureDefaultBlock(), "t3", 24);

        case 24:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4);
}
/**
 * Returns an action object signalling that a single block should be replaced
 * with one or more replacement blocks.
 *
 * @param {(string|string[])} clientId Block client ID to replace.
 * @param {(Object|Object[])} block    Replacement block(s).
 *
 * @return {Object} Action object.
 */

export function replaceBlock(clientId, block) {
  return replaceBlocks(clientId, block);
}
/**
 * Higher-order action creator which, given the action type to dispatch creates
 * an action creator for managing block movement.
 *
 * @param {string} type Action type to dispatch.
 *
 * @return {Function} Action creator.
 */

function createOnMove(type) {
  return function (clientIds, rootClientId) {
    return {
      clientIds: castArray(clientIds),
      type: type,
      rootClientId: rootClientId
    };
  };
}

export var moveBlocksDown = createOnMove('MOVE_BLOCKS_DOWN');
export var moveBlocksUp = createOnMove('MOVE_BLOCKS_UP');
/**
 * Returns an action object signalling that an indexed block should be moved
 * to a new index.
 *
 * @param  {?string} clientId         The client ID of the block.
 * @param  {?string} fromRootClientId Root client ID source.
 * @param  {?string} toRootClientId   Root client ID destination.
 * @param  {number}  index            The index to move the block into.
 *
 * @yield {Object} Action object.
 */

export function moveBlockToPosition(clientId) {
  var fromRootClientId,
      toRootClientId,
      index,
      templateLock,
      action,
      blockName,
      canInsertBlock,
      _args5 = arguments;
  return _regeneratorRuntime.wrap(function moveBlockToPosition$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          fromRootClientId = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : '';
          toRootClientId = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : '';
          index = _args5.length > 3 ? _args5[3] : undefined;
          _context5.next = 5;
          return select('core/block-editor', 'getTemplateLock', fromRootClientId);

        case 5:
          templateLock = _context5.sent;

          if (!(templateLock === 'all')) {
            _context5.next = 8;
            break;
          }

          return _context5.abrupt("return");

        case 8:
          action = {
            type: 'MOVE_BLOCK_TO_POSITION',
            fromRootClientId: fromRootClientId,
            toRootClientId: toRootClientId,
            clientId: clientId,
            index: index
          }; // If moving inside the same root block the move is always possible.

          if (!(fromRootClientId === toRootClientId)) {
            _context5.next = 13;
            break;
          }

          _context5.next = 12;
          return action;

        case 12:
          return _context5.abrupt("return");

        case 13:
          if (!(templateLock === 'insert')) {
            _context5.next = 15;
            break;
          }

          return _context5.abrupt("return");

        case 15:
          _context5.next = 17;
          return select('core/block-editor', 'getBlockName', clientId);

        case 17:
          blockName = _context5.sent;
          _context5.next = 20;
          return select('core/block-editor', 'canInsertBlockType', blockName, toRootClientId);

        case 20:
          canInsertBlock = _context5.sent;

          if (!canInsertBlock) {
            _context5.next = 24;
            break;
          }

          _context5.next = 24;
          return action;

        case 24:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}
/**
 * Returns an action object used in signalling that a single block should be
 * inserted, optionally at a specific index respective a root block list.
 *
 * @param {Object}  block            Block object to insert.
 * @param {?number} index            Index at which block should be inserted.
 * @param {?string} rootClientId     Optional root client ID of block list on which to insert.
 * @param {?boolean} updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to true.
 *
 * @return {Object} Action object.
 */

export function insertBlock(block, index, rootClientId) {
  var updateSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return insertBlocks([block], index, rootClientId, updateSelection);
}
/**
 * Returns an action object used in signalling that an array of blocks should
 * be inserted, optionally at a specific index respective a root block list.
 *
 * @param {Object[]} blocks          Block objects to insert.
 * @param {?number}  index           Index at which block should be inserted.
 * @param {?string}  rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean} updateSelection If true block selection will be updated.  If false, block selection will not change. Defaults to true.
 *
 *  @return {Object} Action object.
 */

export function insertBlocks(blocks, index, rootClientId) {
  var updateSelection,
      allowedBlocks,
      _iteratorNormalCompletion,
      _didIteratorError,
      _iteratorError,
      _iterator,
      _step,
      block,
      isValid,
      _args6 = arguments;

  return _regeneratorRuntime.wrap(function insertBlocks$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          updateSelection = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : true;
          _context6.t0 = getBlocksWithDefaultStylesApplied;
          _context6.t1 = castArray(blocks);
          _context6.next = 5;
          return select('core/block-editor', 'getSettings');

        case 5:
          _context6.t2 = _context6.sent;
          blocks = (0, _context6.t0)(_context6.t1, _context6.t2);
          allowedBlocks = [];
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context6.prev = 11;
          _iterator = blocks[Symbol.iterator]();

        case 13:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context6.next = 22;
            break;
          }

          block = _step.value;
          _context6.next = 17;
          return select('core/block-editor', 'canInsertBlockType', block.name, rootClientId);

        case 17:
          isValid = _context6.sent;

          if (isValid) {
            allowedBlocks.push(block);
          }

        case 19:
          _iteratorNormalCompletion = true;
          _context6.next = 13;
          break;

        case 22:
          _context6.next = 28;
          break;

        case 24:
          _context6.prev = 24;
          _context6.t3 = _context6["catch"](11);
          _didIteratorError = true;
          _iteratorError = _context6.t3;

        case 28:
          _context6.prev = 28;
          _context6.prev = 29;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 31:
          _context6.prev = 31;

          if (!_didIteratorError) {
            _context6.next = 34;
            break;
          }

          throw _iteratorError;

        case 34:
          return _context6.finish(31);

        case 35:
          return _context6.finish(28);

        case 36:
          if (!allowedBlocks.length) {
            _context6.next = 38;
            break;
          }

          return _context6.abrupt("return", {
            type: 'INSERT_BLOCKS',
            blocks: allowedBlocks,
            index: index,
            rootClientId: rootClientId,
            time: Date.now(),
            updateSelection: updateSelection
          });

        case 38:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6, null, [[11, 24, 28, 36], [29,, 31, 35]]);
}
/**
 * Returns an action object used in signalling that the insertion point should
 * be shown.
 *
 * @param {?string} rootClientId Optional root client ID of block list on
 *                               which to insert.
 * @param {?number} index        Index at which block should be inserted.
 *
 * @return {Object} Action object.
 */

export function showInsertionPoint(rootClientId, index) {
  return {
    type: 'SHOW_INSERTION_POINT',
    rootClientId: rootClientId,
    index: index
  };
}
/**
 * Returns an action object hiding the insertion point.
 *
 * @return {Object} Action object.
 */

export function hideInsertionPoint() {
  return {
    type: 'HIDE_INSERTION_POINT'
  };
}
/**
 * Returns an action object resetting the template validity.
 *
 * @param {boolean}  isValid  template validity flag.
 *
 * @return {Object} Action object.
 */

export function setTemplateValidity(isValid) {
  return {
    type: 'SET_TEMPLATE_VALIDITY',
    isValid: isValid
  };
}
/**
 * Returns an action object synchronize the template with the list of blocks
 *
 * @return {Object} Action object.
 */

export function synchronizeTemplate() {
  return {
    type: 'SYNCHRONIZE_TEMPLATE'
  };
}
/**
 * Returns an action object used in signalling that two blocks should be merged
 *
 * @param {string} firstBlockClientId  Client ID of the first block to merge.
 * @param {string} secondBlockClientId Client ID of the second block to merge.
 *
 * @return {Object} Action object.
 */

export function mergeBlocks(firstBlockClientId, secondBlockClientId) {
  return {
    type: 'MERGE_BLOCKS',
    blocks: [firstBlockClientId, secondBlockClientId]
  };
}
/**
 * Yields action objects used in signalling that the blocks corresponding to
 * the set of specified client IDs are to be removed.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block should be
 *                                         selected when a block is removed.
 */

export function removeBlocks(clientIds) {
  var selectPrevious,
      _args7 = arguments;
  return _regeneratorRuntime.wrap(function removeBlocks$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          selectPrevious = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : true;
          clientIds = castArray(clientIds);

          if (!selectPrevious) {
            _context7.next = 5;
            break;
          }

          _context7.next = 5;
          return selectPreviousBlock(clientIds[0]);

        case 5:
          _context7.next = 7;
          return {
            type: 'REMOVE_BLOCKS',
            clientIds: clientIds
          };

        case 7:
          return _context7.delegateYield(ensureDefaultBlock(), "t0", 8);

        case 8:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7);
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID is to be removed.
 *
 * @param {string}  clientId       Client ID of block to remove.
 * @param {boolean} selectPrevious True if the previous block should be
 *                                 selected when a block is removed.
 *
 * @return {Object} Action object.
 */

export function removeBlock(clientId, selectPrevious) {
  return removeBlocks([clientId], selectPrevious);
}
/**
 * Returns an action object used in signalling that the inner blocks with the
 * specified client ID should be replaced.
 *
 * @param {string}   rootClientId    Client ID of the block whose InnerBlocks will re replaced.
 * @param {Object[]} blocks          Block objects to insert as new InnerBlocks
 * @param {?boolean} updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to true.
 *
 * @return {Object} Action object.
 */

export function replaceInnerBlocks(rootClientId, blocks) {
  var updateSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return {
    type: 'REPLACE_INNER_BLOCKS',
    rootClientId: rootClientId,
    blocks: blocks,
    updateSelection: updateSelection,
    time: Date.now()
  };
}
/**
 * Returns an action object used to toggle the block editing mode between
 * visual and HTML modes.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Action object.
 */

export function toggleBlockMode(clientId) {
  return {
    type: 'TOGGLE_BLOCK_MODE',
    clientId: clientId
  };
}
/**
 * Returns an action object used in signalling that the user has begun to type.
 *
 * @return {Object} Action object.
 */

export function startTyping() {
  return {
    type: 'START_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has stopped typing.
 *
 * @return {Object} Action object.
 */

export function stopTyping() {
  return {
    type: 'STOP_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the caret has entered formatted text.
 *
 * @return {Object} Action object.
 */

export function enterFormattedText() {
  return {
    type: 'ENTER_FORMATTED_TEXT'
  };
}
/**
 * Returns an action object used in signalling that the user caret has exited formatted text.
 *
 * @return {Object} Action object.
 */

export function exitFormattedText() {
  return {
    type: 'EXIT_FORMATTED_TEXT'
  };
}
/**
 * Returns an action object used in signalling that the user caret has changed
 * position.
 *
 * @param {string} clientId     The selected block client ID.
 * @param {string} attributeKey The selected block attribute key.
 * @param {number} startOffset  The start offset.
 * @param {number} endOffset    The end offset.
 *
 * @return {Object} Action object.
 */

export function selectionChange(clientId, attributeKey, startOffset, endOffset) {
  return {
    type: 'SELECTION_CHANGE',
    clientId: clientId,
    attributeKey: attributeKey,
    startOffset: startOffset,
    endOffset: endOffset
  };
}
/**
 * Returns an action object used in signalling that a new block of the default
 * type should be added to the block list.
 *
 * @param {?Object} attributes   Optional attributes of the block to assign.
 * @param {?string} rootClientId Optional root client ID of block list on which
 *                               to append.
 * @param {?number} index        Optional index where to insert the default block
 *
 * @return {Object} Action object
 */

export function insertDefaultBlock(attributes, rootClientId, index) {
  // Abort if there is no default block type (if it has been unregistered).
  var defaultBlockName = getDefaultBlockName();

  if (!defaultBlockName) {
    return;
  }

  var block = createBlock(defaultBlockName, attributes);
  return insertBlock(block, index, rootClientId);
}
/**
 * Returns an action object that changes the nested settings of a given block.
 *
 * @param {string} clientId Client ID of the block whose nested setting are
 *                          being received.
 * @param {Object} settings Object with the new settings for the nested block.
 *
 * @return {Object} Action object
 */

export function updateBlockListSettings(clientId, settings) {
  return {
    type: 'UPDATE_BLOCK_LIST_SETTINGS',
    clientId: clientId,
    settings: settings
  };
}
/*
 * Returns an action object used in signalling that the block editor settings have been updated.
 *
 * @param {Object} settings Updated settings
 *
 * @return {Object} Action object
 */

export function updateSettings(settings) {
  return {
    type: 'UPDATE_SETTINGS',
    settings: settings
  };
}
/**
 * Returns an action object used in signalling that a temporary reusable blocks have been saved
 * in order to switch its temporary id with the real id.
 *
 * @param {string} id        Reusable block's id.
 * @param {string} updatedId Updated block's id.
 *
 * @return {Object} Action object.
 */

export function __unstableSaveReusableBlock(id, updatedId) {
  return {
    type: 'SAVE_REUSABLE_BLOCK_SUCCESS',
    id: id,
    updatedId: updatedId
  };
}
/**
 * Returns an action object used in signalling that the last block change should be marked explicitely as persistent.
 *
 * @return {Object} Action object.
 */

export function __unstableMarkLastChangeAsPersistent() {
  return {
    type: 'MARK_LAST_CHANGE_AS_PERSISTENT'
  };
}
/**
 * Returns an action object used in signalling that the last block change is
 * an automatic change, meaning it was not performed by the user, and can be
 * undone using the `Escape` and `Backspace` keys. This action must be called
 * after the change was made, and any actions that are a consequence of it, so
 * it is recommended to be called at the next idle period to ensure all
 * selection changes have been recorded.
 *
 * @return {Object} Action object.
 */

export function __unstableMarkAutomaticChange() {
  return {
    type: 'MARK_AUTOMATIC_CHANGE'
  };
}
/**
 * Returns an action object used to enable or disable the navigation mode.
 *
 * @param {string} isNavigationMode Enable/Disable navigation mode.
 *
 * @return {Object} Action object
 */

export function setNavigationMode() {
  var isNavigationMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return {
    type: 'SET_NAVIGATION_MODE',
    isNavigationMode: isNavigationMode
  };
}
//# sourceMappingURL=actions.js.map