import _regeneratorRuntime from "@babel/runtime/regenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";

var _marked =
/*#__PURE__*/
_regeneratorRuntime.mark(getBlocksWithSourcedAttributes),
    _marked2 =
/*#__PURE__*/
_regeneratorRuntime.mark(resetLastBlockSourceDependencies),
    _marked3 =
/*#__PURE__*/
_regeneratorRuntime.mark(setupEditor),
    _marked4 =
/*#__PURE__*/
_regeneratorRuntime.mark(__experimentalSubscribeSources),
    _marked5 =
/*#__PURE__*/
_regeneratorRuntime.mark(resetAutosave),
    _marked6 =
/*#__PURE__*/
_regeneratorRuntime.mark(editPost),
    _marked7 =
/*#__PURE__*/
_regeneratorRuntime.mark(savePost),
    _marked8 =
/*#__PURE__*/
_regeneratorRuntime.mark(refreshPost),
    _marked9 =
/*#__PURE__*/
_regeneratorRuntime.mark(trashPost),
    _marked10 =
/*#__PURE__*/
_regeneratorRuntime.mark(autosave),
    _marked11 =
/*#__PURE__*/
_regeneratorRuntime.mark(__experimentalLocalAutosave),
    _marked12 =
/*#__PURE__*/
_regeneratorRuntime.mark(redo),
    _marked13 =
/*#__PURE__*/
_regeneratorRuntime.mark(undo),
    _marked14 =
/*#__PURE__*/
_regeneratorRuntime.mark(resetEditorBlocks);

/**
 * External dependencies
 */
import { has, castArray } from 'lodash';
/**
 * WordPress dependencies
 */

import deprecated from '@wordpress/deprecated';
import { dispatch, select, apiFetch } from '@wordpress/data-controls';
import { parse, synchronizeBlocksWithTemplate } from '@wordpress/blocks';
import isShallowEqual from '@wordpress/is-shallow-equal';
/**
 * Internal dependencies
 */

import { STORE_KEY, POST_UPDATE_TRANSACTION_ID, TRASH_POST_NOTICE_ID } from './constants';
import { getNotificationArgumentsForSaveSuccess, getNotificationArgumentsForSaveFail, getNotificationArgumentsForTrashFail } from './utils/notice-builder';
import serializeBlocks from './utils/serialize-blocks';
import { awaitNextStateChange, getRegistry } from './controls';
import * as sources from './block-sources';
/**
 * Map of Registry instance to WeakMap of dependencies by custom source.
 *
 * @type WeakMap<WPDataRegistry,WeakMap<WPBlockAttributeSource,Object>>
 */

var lastBlockSourceDependenciesByRegistry = new WeakMap();
/**
 * Given a blocks array, returns a blocks array with sourced attribute values
 * applied. The reference will remain consistent with the original argument if
 * no attribute values must be overridden. If sourced values are applied, the
 * return value will be a modified copy of the original array.
 *
 * @param {WPBlock[]} blocks Original blocks array.
 *
 * @return {WPBlock[]} Blocks array with sourced values applied.
 */

function getBlocksWithSourcedAttributes(blocks) {
  var registry, blockSourceDependencies, workingBlocks, i, block, blockType, _i, _Object$entries, _Object$entries$_i, attributeName, schema, dependencies, sourcedAttributeValue, appliedInnerBlocks;

  return _regeneratorRuntime.wrap(function getBlocksWithSourcedAttributes$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return getRegistry();

        case 2:
          registry = _context.sent;

          if (lastBlockSourceDependenciesByRegistry.has(registry)) {
            _context.next = 5;
            break;
          }

          return _context.abrupt("return", blocks);

        case 5:
          blockSourceDependencies = lastBlockSourceDependenciesByRegistry.get(registry);
          workingBlocks = blocks;
          i = 0;

        case 8:
          if (!(i < blocks.length)) {
            _context.next = 37;
            break;
          }

          block = blocks[i];
          _context.next = 12;
          return select('core/blocks', 'getBlockType', block.name);

        case 12:
          blockType = _context.sent;
          _i = 0, _Object$entries = Object.entries(blockType.attributes);

        case 14:
          if (!(_i < _Object$entries.length)) {
            _context.next = 30;
            break;
          }

          _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), attributeName = _Object$entries$_i[0], schema = _Object$entries$_i[1];

          if (!(!sources[schema.source] || !sources[schema.source].apply)) {
            _context.next = 18;
            break;
          }

          return _context.abrupt("continue", 27);

        case 18:
          if (blockSourceDependencies.has(sources[schema.source])) {
            _context.next = 20;
            break;
          }

          return _context.abrupt("continue", 27);

        case 20:
          dependencies = blockSourceDependencies.get(sources[schema.source]);
          sourcedAttributeValue = sources[schema.source].apply(schema, dependencies); // It's only necessary to apply the value if it differs from the
          // block's locally-assigned value, to avoid needlessly resetting
          // the block editor.

          if (!(sourcedAttributeValue === block.attributes[attributeName])) {
            _context.next = 24;
            break;
          }

          return _context.abrupt("continue", 27);

        case 24:
          // Create a shallow clone to mutate, leaving the original intact.
          if (workingBlocks === blocks) {
            workingBlocks = _toConsumableArray(workingBlocks);
          }

          block = _objectSpread({}, block, {
            attributes: _objectSpread({}, block.attributes, _defineProperty({}, attributeName, sourcedAttributeValue))
          });
          workingBlocks.splice(i, 1, block);

        case 27:
          _i++;
          _context.next = 14;
          break;

        case 30:
          if (!block.innerBlocks.length) {
            _context.next = 34;
            break;
          }

          return _context.delegateYield(getBlocksWithSourcedAttributes(block.innerBlocks), "t0", 32);

        case 32:
          appliedInnerBlocks = _context.t0;

          if (appliedInnerBlocks !== block.innerBlocks) {
            if (workingBlocks === blocks) {
              workingBlocks = _toConsumableArray(workingBlocks);
            }

            block = _objectSpread({}, block, {
              innerBlocks: appliedInnerBlocks
            });
            workingBlocks.splice(i, 1, block);
          }

        case 34:
          i++;
          _context.next = 8;
          break;

        case 37:
          return _context.abrupt("return", workingBlocks);

        case 38:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
/**
 * Refreshes the last block source dependencies, optionally for a given subset
 * of sources (defaults to the full set of sources).
 *
 * @param {?Array} sourcesToUpdate Optional subset of sources to reset.
 *
 * @yield {Object} Yielded actions or control descriptors.
 */


function resetLastBlockSourceDependencies() {
  var sourcesToUpdate,
      registry,
      lastBlockSourceDependencies,
      _iteratorNormalCompletion,
      _didIteratorError,
      _iteratorError,
      _iterator,
      _step,
      source,
      dependencies,
      _args2 = arguments;

  return _regeneratorRuntime.wrap(function resetLastBlockSourceDependencies$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          sourcesToUpdate = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : Object.values(sources);

          if (sourcesToUpdate.length) {
            _context2.next = 3;
            break;
          }

          return _context2.abrupt("return");

        case 3:
          _context2.next = 5;
          return getRegistry();

        case 5:
          registry = _context2.sent;

          if (!lastBlockSourceDependenciesByRegistry.has(registry)) {
            lastBlockSourceDependenciesByRegistry.set(registry, new WeakMap());
          }

          lastBlockSourceDependencies = lastBlockSourceDependenciesByRegistry.get(registry);
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context2.prev = 11;
          _iterator = sourcesToUpdate[Symbol.iterator]();

        case 13:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context2.next = 21;
            break;
          }

          source = _step.value;
          return _context2.delegateYield(source.getDependencies(), "t0", 16);

        case 16:
          dependencies = _context2.t0;
          lastBlockSourceDependencies.set(source, dependencies);

        case 18:
          _iteratorNormalCompletion = true;
          _context2.next = 13;
          break;

        case 21:
          _context2.next = 27;
          break;

        case 23:
          _context2.prev = 23;
          _context2.t1 = _context2["catch"](11);
          _didIteratorError = true;
          _iteratorError = _context2.t1;

        case 27:
          _context2.prev = 27;
          _context2.prev = 28;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 30:
          _context2.prev = 30;

          if (!_didIteratorError) {
            _context2.next = 33;
            break;
          }

          throw _iteratorError;

        case 33:
          return _context2.finish(30);

        case 34:
          return _context2.finish(27);

        case 35:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[11, 23, 27, 35], [28,, 30, 34]]);
}
/**
 * Returns an action generator used in signalling that editor has initialized with
 * the specified post object and editor settings.
 *
 * @param {Object} post      Post object.
 * @param {Object} edits     Initial edited attributes object.
 * @param {Array?} template  Block Template.
 */


export function setupEditor(post, edits, template) {
  var content, blocks, isNewPost;
  return _regeneratorRuntime.wrap(function setupEditor$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          // In order to ensure maximum of a single parse during setup, edits are
          // included as part of editor setup action. Assume edited content as
          // canonical if provided, falling back to post.
          if (has(edits, ['content'])) {
            content = edits.content;
          } else {
            content = post.content.raw;
          }

          blocks = parse(content); // Apply a template for new posts only, if exists.

          isNewPost = post.status === 'auto-draft';

          if (isNewPost && template) {
            blocks = synchronizeBlocksWithTemplate(blocks, template);
          }

          _context3.next = 6;
          return resetPost(post);

        case 6:
          return _context3.delegateYield(resetLastBlockSourceDependencies(), "t0", 7);

        case 7:
          _context3.next = 9;
          return {
            type: 'SETUP_EDITOR',
            post: post,
            edits: edits,
            template: template
          };

        case 9:
          _context3.next = 11;
          return resetEditorBlocks(blocks, {
            __unstableShouldCreateUndoLevel: false
          });

        case 11:
          _context3.next = 13;
          return setupEditorState(post);

        case 13:
          if (!(edits && Object.keys(edits).some(function (key) {
            return edits[key] !== (has(post, [key, 'raw']) ? post[key].raw : post[key]);
          }))) {
            _context3.next = 16;
            break;
          }

          _context3.next = 16;
          return editPost(edits);

        case 16:
          return _context3.delegateYield(__experimentalSubscribeSources(), "t1", 17);

        case 17:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}
/**
 * Returns an action object signalling that the editor is being destroyed and
 * that any necessary state or side-effect cleanup should occur.
 *
 * @return {Object} Action object.
 */

export function __experimentalTearDownEditor() {
  return {
    type: 'TEAR_DOWN_EDITOR'
  };
}
/**
 * Returns an action generator which loops to await the next state change,
 * calling to reset blocks when a block source dependencies change.
 *
 * @yield {Object} Action object.
 */

export function __experimentalSubscribeSources() {
  var isStillReady, registry, reset, _i2, _Object$values, source, dependencies, lastBlockSourceDependencies, lastDependencies;

  return _regeneratorRuntime.wrap(function __experimentalSubscribeSources$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!true) {
            _context4.next = 36;
            break;
          }

          _context4.next = 3;
          return awaitNextStateChange();

        case 3:
          _context4.next = 5;
          return select(STORE_KEY, '__unstableIsEditorReady');

        case 5:
          isStillReady = _context4.sent;

          if (isStillReady) {
            _context4.next = 8;
            break;
          }

          return _context4.abrupt("break", 36);

        case 8:
          _context4.next = 10;
          return getRegistry();

        case 10:
          registry = _context4.sent;
          reset = false;
          _i2 = 0, _Object$values = Object.values(sources);

        case 13:
          if (!(_i2 < _Object$values.length)) {
            _context4.next = 26;
            break;
          }

          source = _Object$values[_i2];

          if (source.getDependencies) {
            _context4.next = 17;
            break;
          }

          return _context4.abrupt("continue", 23);

        case 17:
          return _context4.delegateYield(source.getDependencies(), "t0", 18);

        case 18:
          dependencies = _context4.t0;

          if (!lastBlockSourceDependenciesByRegistry.has(registry)) {
            lastBlockSourceDependenciesByRegistry.set(registry, new WeakMap());
          }

          lastBlockSourceDependencies = lastBlockSourceDependenciesByRegistry.get(registry);
          lastDependencies = lastBlockSourceDependencies.get(source);

          if (!isShallowEqual(dependencies, lastDependencies)) {
            lastBlockSourceDependencies.set(source, dependencies); // Allow the loop to continue in order to assign latest
            // dependencies values, but mark for reset.

            reset = true;
          }

        case 23:
          _i2++;
          _context4.next = 13;
          break;

        case 26:
          if (!reset) {
            _context4.next = 34;
            break;
          }

          _context4.t1 = resetEditorBlocks;
          _context4.next = 30;
          return select(STORE_KEY, 'getEditorBlocks');

        case 30:
          _context4.t2 = _context4.sent;
          _context4.t3 = {
            __unstableShouldCreateUndoLevel: false
          };
          _context4.next = 34;
          return (0, _context4.t1)(_context4.t2, _context4.t3);

        case 34:
          _context4.next = 0;
          break;

        case 36:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4);
}
/**
 * Returns an action object used in signalling that the latest version of the
 * post has been received, either by initialization or save.
 *
 * @param {Object} post Post object.
 *
 * @return {Object} Action object.
 */

export function resetPost(post) {
  return {
    type: 'RESET_POST',
    post: post
  };
}
/**
 * Returns an action object used in signalling that the latest autosave of the
 * post has been received, by initialization or autosave.
 *
 * @deprecated since 5.6. Callers should use the `receiveAutosaves( postId, autosave )`
 * 			   selector from the '@wordpress/core-data' package.
 *
 * @param {Object} newAutosave Autosave post object.
 *
 * @return {Object} Action object.
 */

export function resetAutosave(newAutosave) {
  var postId;
  return _regeneratorRuntime.wrap(function resetAutosave$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          deprecated('resetAutosave action (`core/editor` store)', {
            alternative: 'receiveAutosaves action (`core` store)',
            plugin: 'Gutenberg'
          });
          _context5.next = 3;
          return select(STORE_KEY, 'getCurrentPostId');

        case 3:
          postId = _context5.sent;
          _context5.next = 6;
          return dispatch('core', 'receiveAutosaves', postId, newAutosave);

        case 6:
          return _context5.abrupt("return", {
            type: '__INERT__'
          });

        case 7:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}
/**
 * Action for dispatching that a post update request has started.
 *
 * @param {Object} options
 *
 * @return {Object} An action object
 */

export function __experimentalRequestPostUpdateStart() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    type: 'REQUEST_POST_UPDATE_START',
    options: options
  };
}
/**
 * Action for dispatching that a post update request has finished.
 *
 * @param {Object} options
 *
 * @return {Object} An action object
 */

export function __experimentalRequestPostUpdateFinish() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    type: 'REQUEST_POST_UPDATE_FINISH',
    options: options
  };
}
/**
 * Returns an action object used in signalling that a patch of updates for the
 * latest version of the post have been received.
 *
 * @param {Object} edits Updated post fields.
 *
 * @return {Object} Action object.
 */

export function updatePost(edits) {
  return {
    type: 'UPDATE_POST',
    edits: edits
  };
}
/**
 * Returns an action object used to setup the editor state when first opening
 * an editor.
 *
 * @param {Object} post   Post object.
 *
 * @return {Object} Action object.
 */

export function setupEditorState(post) {
  return {
    type: 'SETUP_EDITOR_STATE',
    post: post
  };
}
/**
 * Returns an action object used in signalling that attributes of the post have
 * been edited.
 *
 * @param {Object} edits   Post attributes to edit.
 * @param {Object} options Options for the edit.
 *
 * @yield {Object} Action object or control.
 */

export function editPost(edits, options) {
  var _ref, id, type;

  return _regeneratorRuntime.wrap(function editPost$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return select(STORE_KEY, 'getCurrentPost');

        case 2:
          _ref = _context6.sent;
          id = _ref.id;
          type = _ref.type;
          _context6.next = 7;
          return dispatch('core', 'editEntityRecord', 'postType', type, id, edits, options);

        case 7:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6);
}
/**
 * Returns action object produced by the updatePost creator augmented by
 * an optimist option that signals optimistically applying updates.
 *
 * @param {Object} edits  Updated post fields.
 *
 * @return {Object} Action object.
 */

export function __experimentalOptimisticUpdatePost(edits) {
  return _objectSpread({}, updatePost(edits), {
    optimist: {
      id: POST_UPDATE_TRANSACTION_ID
    }
  });
}
/**
 * Action generator for saving the current post in the editor.
 *
 * @param {Object} options
 */

export function savePost() {
  var options,
      edits,
      previousRecord,
      error,
      args,
      updatedRecord,
      _args7,
      _args8 = arguments;

  return _regeneratorRuntime.wrap(function savePost$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          options = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};
          _context7.next = 3;
          return select(STORE_KEY, 'isEditedPostSaveable');

        case 3:
          if (_context7.sent) {
            _context7.next = 5;
            break;
          }

          return _context7.abrupt("return");

        case 5:
          _context7.next = 7;
          return select(STORE_KEY, 'getEditedPostContent');

        case 7:
          _context7.t0 = _context7.sent;
          edits = {
            content: _context7.t0
          };

          if (options.isAutosave) {
            _context7.next = 12;
            break;
          }

          _context7.next = 12;
          return dispatch(STORE_KEY, 'editPost', edits, {
            undoIgnore: true
          });

        case 12:
          _context7.next = 14;
          return __experimentalRequestPostUpdateStart(options);

        case 14:
          _context7.next = 16;
          return select(STORE_KEY, 'getCurrentPost');

        case 16:
          previousRecord = _context7.sent;
          _context7.t1 = _objectSpread;
          _context7.t2 = {
            id: previousRecord.id
          };
          _context7.next = 21;
          return select('core', 'getEntityRecordNonTransientEdits', 'postType', previousRecord.type, previousRecord.id);

        case 21:
          _context7.t3 = _context7.sent;
          _context7.t4 = edits;
          edits = (0, _context7.t1)(_context7.t2, _context7.t3, _context7.t4);
          _context7.next = 26;
          return dispatch('core', 'saveEntityRecord', 'postType', previousRecord.type, edits, options);

        case 26:
          _context7.next = 28;
          return __experimentalRequestPostUpdateFinish(options);

        case 28:
          _context7.next = 30;
          return select('core', 'getLastEntitySaveError', 'postType', previousRecord.type, previousRecord.id);

        case 30:
          error = _context7.sent;

          if (!error) {
            _context7.next = 38;
            break;
          }

          args = getNotificationArgumentsForSaveFail({
            post: previousRecord,
            edits: edits,
            error: error
          });

          if (!args.length) {
            _context7.next = 36;
            break;
          }

          _context7.next = 36;
          return dispatch.apply(void 0, ['core/notices', 'createErrorNotice'].concat(_toConsumableArray(args)));

        case 36:
          _context7.next = 56;
          break;

        case 38:
          _context7.next = 40;
          return select(STORE_KEY, 'getCurrentPost');

        case 40:
          updatedRecord = _context7.sent;
          _context7.t5 = getNotificationArgumentsForSaveSuccess;
          _context7.t6 = previousRecord;
          _context7.t7 = updatedRecord;
          _context7.next = 46;
          return select('core', 'getPostType', updatedRecord.type);

        case 46:
          _context7.t8 = _context7.sent;
          _context7.t9 = options;
          _context7.t10 = {
            previousPost: _context7.t6,
            post: _context7.t7,
            postType: _context7.t8,
            options: _context7.t9
          };
          _args7 = (0, _context7.t5)(_context7.t10);

          if (!_args7.length) {
            _context7.next = 53;
            break;
          }

          _context7.next = 53;
          return dispatch.apply(void 0, ['core/notices', 'createSuccessNotice'].concat(_toConsumableArray(_args7)));

        case 53:
          if (options.isAutosave) {
            _context7.next = 56;
            break;
          }

          _context7.next = 56;
          return dispatch('core/block-editor', '__unstableMarkLastChangeAsPersistent');

        case 56:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7);
}
/**
 * Action generator for handling refreshing the current post.
 */

export function refreshPost() {
  var post, postTypeSlug, postType, newPost;
  return _regeneratorRuntime.wrap(function refreshPost$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return select(STORE_KEY, 'getCurrentPost');

        case 2:
          post = _context8.sent;
          _context8.next = 5;
          return select(STORE_KEY, 'getCurrentPostType');

        case 5:
          postTypeSlug = _context8.sent;
          _context8.next = 8;
          return select('core', 'getPostType', postTypeSlug);

        case 8:
          postType = _context8.sent;
          _context8.next = 11;
          return apiFetch({
            // Timestamp arg allows caller to bypass browser caching, which is
            // expected for this specific function.
            path: "/wp/v2/".concat(postType.rest_base, "/").concat(post.id) + "?context=edit&_timestamp=".concat(Date.now())
          });

        case 11:
          newPost = _context8.sent;
          _context8.next = 14;
          return dispatch(STORE_KEY, 'resetPost', newPost);

        case 14:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked8);
}
/**
 * Action generator for trashing the current post in the editor.
 */

export function trashPost() {
  var postTypeSlug, postType, post;
  return _regeneratorRuntime.wrap(function trashPost$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          _context9.next = 2;
          return select(STORE_KEY, 'getCurrentPostType');

        case 2:
          postTypeSlug = _context9.sent;
          _context9.next = 5;
          return select('core', 'getPostType', postTypeSlug);

        case 5:
          postType = _context9.sent;
          _context9.next = 8;
          return dispatch('core/notices', 'removeNotice', TRASH_POST_NOTICE_ID);

        case 8:
          _context9.prev = 8;
          _context9.next = 11;
          return select(STORE_KEY, 'getCurrentPost');

        case 11:
          post = _context9.sent;
          _context9.next = 14;
          return apiFetch({
            path: "/wp/v2/".concat(postType.rest_base, "/").concat(post.id),
            method: 'DELETE'
          });

        case 14:
          _context9.next = 16;
          return dispatch(STORE_KEY, 'savePost');

        case 16:
          _context9.next = 22;
          break;

        case 18:
          _context9.prev = 18;
          _context9.t0 = _context9["catch"](8);
          _context9.next = 22;
          return dispatch.apply(void 0, ['core/notices', 'createErrorNotice'].concat(_toConsumableArray(getNotificationArgumentsForTrashFail({
            error: _context9.t0
          }))));

        case 22:
        case "end":
          return _context9.stop();
      }
    }
  }, _marked9, null, [[8, 18]]);
}
/**
 * Action generator used in signalling that the post should autosave.
 *
 * @param {Object?} options Extra flags to identify the autosave.
 */

export function autosave(options) {
  return _regeneratorRuntime.wrap(function autosave$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          _context10.next = 2;
          return dispatch(STORE_KEY, 'savePost', _objectSpread({
            isAutosave: true
          }, options));

        case 2:
        case "end":
          return _context10.stop();
      }
    }
  }, _marked10);
}
export function __experimentalLocalAutosave() {
  var post, title, content, excerpt;
  return _regeneratorRuntime.wrap(function __experimentalLocalAutosave$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          _context11.next = 2;
          return select(STORE_KEY, 'getCurrentPost');

        case 2:
          post = _context11.sent;
          _context11.next = 5;
          return select(STORE_KEY, 'getEditedPostAttribute', 'title');

        case 5:
          title = _context11.sent;
          _context11.next = 8;
          return select(STORE_KEY, 'getEditedPostAttribute', 'content');

        case 8:
          content = _context11.sent;
          _context11.next = 11;
          return select(STORE_KEY, 'getEditedPostAttribute', 'excerpt');

        case 11:
          excerpt = _context11.sent;
          _context11.next = 14;
          return {
            type: 'LOCAL_AUTOSAVE_SET',
            postId: post.id,
            title: title,
            content: content,
            excerpt: excerpt
          };

        case 14:
        case "end":
          return _context11.stop();
      }
    }
  }, _marked11);
}
/**
 * Returns an action object used in signalling that undo history should
 * restore last popped state.
 *
 * @yield {Object} Action object.
 */

export function redo() {
  return _regeneratorRuntime.wrap(function redo$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          _context12.next = 2;
          return dispatch('core', 'redo');

        case 2:
        case "end":
          return _context12.stop();
      }
    }
  }, _marked12);
}
/**
 * Returns an action object used in signalling that undo history should pop.
 *
 * @yield {Object} Action object.
 */

export function undo() {
  return _regeneratorRuntime.wrap(function undo$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          _context13.next = 2;
          return dispatch('core', 'undo');

        case 2:
        case "end":
          return _context13.stop();
      }
    }
  }, _marked13);
}
/**
 * Returns an action object used in signalling that undo history record should
 * be created.
 *
 * @return {Object} Action object.
 */

export function createUndoLevel() {
  return {
    type: 'CREATE_UNDO_LEVEL'
  };
}
/**
 * Returns an action object used to lock the editor.
 *
 * @param {Object}  lock Details about the post lock status, user, and nonce.
 *
 * @return {Object} Action object.
 */

export function updatePostLock(lock) {
  return {
    type: 'UPDATE_POST_LOCK',
    lock: lock
  };
}
/**
 * Returns an action object used to fetch a single reusable block or all
 * reusable blocks from the REST API into the store.
 *
 * @param {?string} id If given, only a single reusable block with this ID will
 *                     be fetched.
 *
 * @return {Object} Action object.
 */

export function __experimentalFetchReusableBlocks(id) {
  return {
    type: 'FETCH_REUSABLE_BLOCKS',
    id: id
  };
}
/**
 * Returns an action object used in signalling that reusable blocks have been
 * received. `results` is an array of objects containing:
 *  - `reusableBlock` - Details about how the reusable block is persisted.
 *  - `parsedBlock` - The original block.
 *
 * @param {Object[]} results Reusable blocks received.
 *
 * @return {Object} Action object.
 */

export function __experimentalReceiveReusableBlocks(results) {
  return {
    type: 'RECEIVE_REUSABLE_BLOCKS',
    results: results
  };
}
/**
 * Returns an action object used to save a reusable block that's in the store to
 * the REST API.
 *
 * @param {Object} id The ID of the reusable block to save.
 *
 * @return {Object} Action object.
 */

export function __experimentalSaveReusableBlock(id) {
  return {
    type: 'SAVE_REUSABLE_BLOCK',
    id: id
  };
}
/**
 * Returns an action object used to delete a reusable block via the REST API.
 *
 * @param {number} id The ID of the reusable block to delete.
 *
 * @return {Object} Action object.
 */

export function __experimentalDeleteReusableBlock(id) {
  return {
    type: 'DELETE_REUSABLE_BLOCK',
    id: id
  };
}
/**
 * Returns an action object used in signalling that a reusable block is
 * to be updated.
 *
 * @param {number} id      The ID of the reusable block to update.
 * @param {Object} changes The changes to apply.
 *
 * @return {Object} Action object.
 */

export function __experimentalUpdateReusableBlock(id, changes) {
  return {
    type: 'UPDATE_REUSABLE_BLOCK',
    id: id,
    changes: changes
  };
}
/**
 * Returns an action object used to convert a reusable block into a static
 * block.
 *
 * @param {string} clientId The client ID of the block to attach.
 *
 * @return {Object} Action object.
 */

export function __experimentalConvertBlockToStatic(clientId) {
  return {
    type: 'CONVERT_BLOCK_TO_STATIC',
    clientId: clientId
  };
}
/**
 * Returns an action object used to convert a static block into a reusable
 * block.
 *
 * @param {string} clientIds The client IDs of the block to detach.
 *
 * @return {Object} Action object.
 */

export function __experimentalConvertBlockToReusable(clientIds) {
  return {
    type: 'CONVERT_BLOCK_TO_REUSABLE',
    clientIds: castArray(clientIds)
  };
}
/**
 * Returns an action object used in signalling that the user has enabled the
 * publish sidebar.
 *
 * @return {Object} Action object
 */

export function enablePublishSidebar() {
  return {
    type: 'ENABLE_PUBLISH_SIDEBAR'
  };
}
/**
 * Returns an action object used in signalling that the user has disabled the
 * publish sidebar.
 *
 * @return {Object} Action object
 */

export function disablePublishSidebar() {
  return {
    type: 'DISABLE_PUBLISH_SIDEBAR'
  };
}
/**
 * Returns an action object used to signal that post saving is locked.
 *
 * @param  {string} lockName The lock name.
 *
 * @example
 * ```
 * const { subscribe } = wp.data;
 *
 * const initialPostStatus = wp.data.select( 'core/editor' ).getEditedPostAttribute( 'status' );
 *
 * // Only allow publishing posts that are set to a future date.
 * if ( 'publish' !== initialPostStatus ) {
 *
 * 	// Track locking.
 * 	let locked = false;
 *
 * 	// Watch for the publish event.
 * 	let unssubscribe = subscribe( () => {
 * 		const currentPostStatus = wp.data.select( 'core/editor' ).getEditedPostAttribute( 'status' );
 * 		if ( 'publish' !== currentPostStatus ) {
 *
 * 			// Compare the post date to the current date, lock the post if the date isn't in the future.
 * 			const postDate = new Date( wp.data.select( 'core/editor' ).getEditedPostAttribute( 'date' ) );
 * 			const currentDate = new Date();
 * 			if ( postDate.getTime() <= currentDate.getTime() ) {
 * 				if ( ! locked ) {
 * 					locked = true;
 * 					wp.data.dispatch( 'core/editor' ).lockPostSaving( 'futurelock' );
 * 				}
 * 			} else {
 * 				if ( locked ) {
 * 					locked = false;
 * 					wp.data.dispatch( 'core/editor' ).unlockPostSaving( 'futurelock' );
 * 				}
 * 			}
 * 		}
 * 	} );
 * }
 * ```
 *
 * @return {Object} Action object
 */

export function lockPostSaving(lockName) {
  return {
    type: 'LOCK_POST_SAVING',
    lockName: lockName
  };
}
/**
 * Returns an action object used to signal that post saving is unlocked.
 *
 * @param  {string} lockName The lock name.
 *
 * @example
 * ```
 * // Unlock post saving with the lock key `mylock`:
 * wp.data.dispatch( 'core/editor' ).unlockPostSaving( 'mylock' );
 * ```
 *
 * @return {Object} Action object
 */

export function unlockPostSaving(lockName) {
  return {
    type: 'UNLOCK_POST_SAVING',
    lockName: lockName
  };
}
/**
 * Returns an action object used to signal that the blocks have been updated.
 *
 * @param {Array}   blocks  Block Array.
 * @param {?Object} options Optional options.
 *
 * @yield {Object} Action object
 */

export function resetEditorBlocks(blocks) {
  var options,
      lastBlockAttributesChange,
      updatedSources,
      updatedBlockTypes,
      _i3,
      _Object$entries2,
      _Object$entries2$_i,
      clientId,
      attributes,
      blockName,
      blockType,
      _i4,
      _Object$entries3,
      _Object$entries3$_i,
      attributeName,
      newAttributeValue,
      schema,
      source,
      edits,
      _ref2,
      id,
      type,
      noChange,
      _args15 = arguments;

  return _regeneratorRuntime.wrap(function resetEditorBlocks$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          options = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : {};
          _context14.next = 3;
          return select('core/block-editor', '__experimentalGetLastBlockAttributeChanges');

        case 3:
          lastBlockAttributesChange = _context14.sent;

          if (!lastBlockAttributesChange) {
            _context14.next = 36;
            break;
          }

          updatedSources = new Set();
          updatedBlockTypes = new Set();
          _i3 = 0, _Object$entries2 = Object.entries(lastBlockAttributesChange);

        case 8:
          if (!(_i3 < _Object$entries2.length)) {
            _context14.next = 35;
            break;
          }

          _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2), clientId = _Object$entries2$_i[0], attributes = _Object$entries2$_i[1];
          _context14.next = 12;
          return select('core/block-editor', 'getBlockName', clientId);

        case 12:
          blockName = _context14.sent;

          if (!updatedBlockTypes.has(blockName)) {
            _context14.next = 15;
            break;
          }

          return _context14.abrupt("continue", 32);

        case 15:
          updatedBlockTypes.add(blockName);
          _context14.next = 18;
          return select('core/blocks', 'getBlockType', blockName);

        case 18:
          blockType = _context14.sent;
          _i4 = 0, _Object$entries3 = Object.entries(attributes);

        case 20:
          if (!(_i4 < _Object$entries3.length)) {
            _context14.next = 32;
            break;
          }

          _Object$entries3$_i = _slicedToArray(_Object$entries3[_i4], 2), attributeName = _Object$entries3$_i[0], newAttributeValue = _Object$entries3$_i[1];

          if (blockType.attributes.hasOwnProperty(attributeName)) {
            _context14.next = 24;
            break;
          }

          return _context14.abrupt("continue", 29);

        case 24:
          schema = blockType.attributes[attributeName];
          source = sources[schema.source];

          if (!(source && source.update)) {
            _context14.next = 29;
            break;
          }

          return _context14.delegateYield(source.update(schema, newAttributeValue), "t0", 28);

        case 28:
          updatedSources.add(source);

        case 29:
          _i4++;
          _context14.next = 20;
          break;

        case 32:
          _i3++;
          _context14.next = 8;
          break;

        case 35:
          return _context14.delegateYield(resetLastBlockSourceDependencies(Array.from(updatedSources)), "t1", 36);

        case 36:
          return _context14.delegateYield(getBlocksWithSourcedAttributes(blocks), "t2", 37);

        case 37:
          _context14.t3 = _context14.t2;
          edits = {
            blocks: _context14.t3
          };

          if (!(options.__unstableShouldCreateUndoLevel !== false)) {
            _context14.next = 55;
            break;
          }

          _context14.next = 42;
          return select(STORE_KEY, 'getCurrentPost');

        case 42:
          _ref2 = _context14.sent;
          id = _ref2.id;
          type = _ref2.type;
          _context14.next = 47;
          return select('core', 'getEditedEntityRecord', 'postType', type, id);

        case 47:
          _context14.t4 = _context14.sent.blocks;
          _context14.t5 = edits.blocks;
          noChange = _context14.t4 === _context14.t5;

          if (!noChange) {
            _context14.next = 54;
            break;
          }

          _context14.next = 53;
          return dispatch('core', '__unstableCreateUndoLevel', 'postType', type, id);

        case 53:
          return _context14.abrupt("return", _context14.sent);

        case 54:
          // We create a new function here on every persistent edit
          // to make sure the edit makes the post dirty and creates
          // a new undo level.
          edits.content = function (_ref3) {
            var _ref3$blocks = _ref3.blocks,
                blocksForSerialization = _ref3$blocks === void 0 ? [] : _ref3$blocks;
            return serializeBlocks(blocksForSerialization);
          };

        case 55:
          return _context14.delegateYield(editPost(edits), "t6", 56);

        case 56:
        case "end":
          return _context14.stop();
      }
    }
  }, _marked14);
}
/*
 * Returns an action object used in signalling that the post editor settings have been updated.
 *
 * @param {Object} settings Updated settings
 *
 * @return {Object} Action object
 */

export function updateEditorSettings(settings) {
  return {
    type: 'UPDATE_EDITOR_SETTINGS',
    settings: settings
  };
}
/**
 * Backward compatibility
 */

var getBlockEditorAction = function getBlockEditorAction(name) {
  return (
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee() {
      var _len,
          args,
          _key,
          _args16 = arguments;

      return _regeneratorRuntime.wrap(function _callee$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              deprecated('`wp.data.dispatch( \'core/editor\' ).' + name + '`', {
                alternative: '`wp.data.dispatch( \'core/block-editor\' ).' + name + '`'
              });

              for (_len = _args16.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = _args16[_key];
              }

              _context15.next = 4;
              return dispatch.apply(void 0, ['core/block-editor', name].concat(args));

            case 4:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee);
    })
  );
};
/**
 * @see resetBlocks in core/block-editor store.
 */


export var resetBlocks = getBlockEditorAction('resetBlocks');
/**
 * @see receiveBlocks in core/block-editor store.
 */

export var receiveBlocks = getBlockEditorAction('receiveBlocks');
/**
 * @see updateBlock in core/block-editor store.
 */

export var updateBlock = getBlockEditorAction('updateBlock');
/**
 * @see updateBlockAttributes in core/block-editor store.
 */

export var updateBlockAttributes = getBlockEditorAction('updateBlockAttributes');
/**
 * @see selectBlock in core/block-editor store.
 */

export var selectBlock = getBlockEditorAction('selectBlock');
/**
 * @see startMultiSelect in core/block-editor store.
 */

export var startMultiSelect = getBlockEditorAction('startMultiSelect');
/**
 * @see stopMultiSelect in core/block-editor store.
 */

export var stopMultiSelect = getBlockEditorAction('stopMultiSelect');
/**
 * @see multiSelect in core/block-editor store.
 */

export var multiSelect = getBlockEditorAction('multiSelect');
/**
 * @see clearSelectedBlock in core/block-editor store.
 */

export var clearSelectedBlock = getBlockEditorAction('clearSelectedBlock');
/**
 * @see toggleSelection in core/block-editor store.
 */

export var toggleSelection = getBlockEditorAction('toggleSelection');
/**
 * @see replaceBlocks in core/block-editor store.
 */

export var replaceBlocks = getBlockEditorAction('replaceBlocks');
/**
 * @see replaceBlock in core/block-editor store.
 */

export var replaceBlock = getBlockEditorAction('replaceBlock');
/**
 * @see moveBlocksDown in core/block-editor store.
 */

export var moveBlocksDown = getBlockEditorAction('moveBlocksDown');
/**
 * @see moveBlocksUp in core/block-editor store.
 */

export var moveBlocksUp = getBlockEditorAction('moveBlocksUp');
/**
 * @see moveBlockToPosition in core/block-editor store.
 */

export var moveBlockToPosition = getBlockEditorAction('moveBlockToPosition');
/**
 * @see insertBlock in core/block-editor store.
 */

export var insertBlock = getBlockEditorAction('insertBlock');
/**
 * @see insertBlocks in core/block-editor store.
 */

export var insertBlocks = getBlockEditorAction('insertBlocks');
/**
 * @see showInsertionPoint in core/block-editor store.
 */

export var showInsertionPoint = getBlockEditorAction('showInsertionPoint');
/**
 * @see hideInsertionPoint in core/block-editor store.
 */

export var hideInsertionPoint = getBlockEditorAction('hideInsertionPoint');
/**
 * @see setTemplateValidity in core/block-editor store.
 */

export var setTemplateValidity = getBlockEditorAction('setTemplateValidity');
/**
 * @see synchronizeTemplate in core/block-editor store.
 */

export var synchronizeTemplate = getBlockEditorAction('synchronizeTemplate');
/**
 * @see mergeBlocks in core/block-editor store.
 */

export var mergeBlocks = getBlockEditorAction('mergeBlocks');
/**
 * @see removeBlocks in core/block-editor store.
 */

export var removeBlocks = getBlockEditorAction('removeBlocks');
/**
 * @see removeBlock in core/block-editor store.
 */

export var removeBlock = getBlockEditorAction('removeBlock');
/**
 * @see toggleBlockMode in core/block-editor store.
 */

export var toggleBlockMode = getBlockEditorAction('toggleBlockMode');
/**
 * @see startTyping in core/block-editor store.
 */

export var startTyping = getBlockEditorAction('startTyping');
/**
 * @see stopTyping in core/block-editor store.
 */

export var stopTyping = getBlockEditorAction('stopTyping');
/**
 * @see enterFormattedText in core/block-editor store.
 */

export var enterFormattedText = getBlockEditorAction('enterFormattedText');
/**
 * @see exitFormattedText in core/block-editor store.
 */

export var exitFormattedText = getBlockEditorAction('exitFormattedText');
/**
 * @see insertDefaultBlock in core/block-editor store.
 */

export var insertDefaultBlock = getBlockEditorAction('insertDefaultBlock');
/**
 * @see updateBlockListSettings in core/block-editor store.
 */

export var updateBlockListSettings = getBlockEditorAction('updateBlockListSettings');
//# sourceMappingURL=actions.js.map