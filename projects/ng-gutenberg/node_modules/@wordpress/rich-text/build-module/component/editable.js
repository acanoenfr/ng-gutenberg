import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";

/**
 * External dependencies
 */
import { isEqual } from 'lodash';
/**
 * WordPress dependencies
 */

import { Component, createElement } from '@wordpress/element';
/**
 * Internal dependencies
 */

import { diffAriaProps } from './aria';

var Editable =
/*#__PURE__*/
function (_Component) {
  _inherits(Editable, _Component);

  function Editable() {
    var _this;

    _classCallCheck(this, Editable);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Editable).call(this));
    _this.bindEditorNode = _this.bindEditorNode.bind(_assertThisInitialized(_this));
    return _this;
  } // We must prevent rerenders because the browser will modify the DOM. React
  // will rerender the DOM fine, but we're losing selection and it would be
  // more expensive to do so as it would just set the inner HTML through
  // `dangerouslySetInnerHTML`. Instead RichText does it's own diffing and
  // selection setting.
  //
  // Because we never update the component, we have to look through props and
  // update the attributes on the wrapper nodes here. `componentDidUpdate`
  // will never be called.


  _createClass(Editable, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var _this2 = this;

      if (!isEqual(this.props.style, nextProps.style)) {
        this.editorNode.setAttribute('style', '');
        Object.assign(this.editorNode.style, _objectSpread({}, nextProps.style || {}, {
          whiteSpace: 'pre-wrap'
        }));
      }

      if (!isEqual(this.props.className, nextProps.className)) {
        this.editorNode.className = nextProps.className;
      }

      if (this.props.start !== nextProps.start) {
        this.editorNode.setAttribute('start', nextProps.start);
      }

      if (this.props.reversed !== nextProps.reversed) {
        this.editorNode.reversed = nextProps.reversed;
      }

      var _diffAriaProps = diffAriaProps(this.props, nextProps),
          removedKeys = _diffAriaProps.removedKeys,
          updatedKeys = _diffAriaProps.updatedKeys;

      removedKeys.forEach(function (key) {
        return _this2.editorNode.removeAttribute(key);
      });
      updatedKeys.forEach(function (key) {
        return _this2.editorNode.setAttribute(key, nextProps[key]);
      });
      return false;
    }
  }, {
    key: "bindEditorNode",
    value: function bindEditorNode(editorNode) {
      this.editorNode = editorNode;
      this.props.setRef(editorNode);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          _this$props$tagName = _this$props.tagName,
          tagName = _this$props$tagName === void 0 ? 'div' : _this$props$tagName,
          _this$props$style = _this$props.style,
          style = _this$props$style === void 0 ? {} : _this$props$style,
          record = _this$props.record,
          valueToEditableHTML = _this$props.valueToEditableHTML,
          className = _this$props.className,
          remainingProps = _objectWithoutProperties(_this$props, ["tagName", "style", "record", "valueToEditableHTML", "className"]);

      delete remainingProps.setRef; // In HTML, leading and trailing spaces are not visible, and multiple
      // spaces elsewhere are visually reduced to one space. This rule
      // prevents spaces from collapsing so all space is visible in the editor
      // and can be removed.
      // It also prevents some browsers from inserting non-breaking spaces at
      // the end of a line to prevent the space from visually disappearing.
      // Sometimes these non breaking spaces can linger in the editor causing
      // unwanted non breaking spaces in between words. If also prevent
      // Firefox from inserting a trailing `br` node to visualise any trailing
      // space, causing the element to be saved.
      //
      // > Authors are encouraged to set the 'white-space' property on editing
      // > hosts and on markup that was originally created through these
      // > editing mechanisms to the value 'pre-wrap'. Default HTML whitespace
      // > handling is not well suited to WYSIWYG editing, and line wrapping
      // > will not work correctly in some corner cases if 'white-space' is
      // > left at its default value.
      // >
      // > https://html.spec.whatwg.org/multipage/interaction.html#best-practices-for-in-page-editors

      var whiteSpace = 'pre-wrap';
      return createElement(tagName, _objectSpread({
        role: 'textbox',
        'aria-multiline': true,
        className: className,
        contentEditable: true,
        ref: this.bindEditorNode,
        style: _objectSpread({}, style, {
          whiteSpace: whiteSpace
        }),
        suppressContentEditableWarning: true,
        dangerouslySetInnerHTML: {
          __html: valueToEditableHTML(record)
        }
      }, remainingProps));
    }
  }]);

  return Editable;
}(Component);

export { Editable as default };
//# sourceMappingURL=editable.js.map