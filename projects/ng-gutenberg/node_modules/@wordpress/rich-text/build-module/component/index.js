import _extends from "@babel/runtime/helpers/esm/extends";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
import { find, isNil, pickBy } from 'lodash';
/**
 * WordPress dependencies
 */

import { Component } from '@wordpress/element';
import { BACKSPACE, DELETE, ENTER, LEFT, RIGHT, SPACE, ESCAPE } from '@wordpress/keycodes';
import { withSelect } from '@wordpress/data';
import { withSafeTimeout, compose } from '@wordpress/compose';
import isShallowEqual from '@wordpress/is-shallow-equal';
import deprecated from '@wordpress/deprecated';
/**
 * Internal dependencies
 */

import FormatEdit from './format-edit';
import _Editable from './editable';
import { pickAriaProps } from './aria';
import { create } from '../create';
import { apply, toDom } from '../to-dom';
import { toHTMLString } from '../to-html-string';
import { remove } from '../remove';
import { removeFormat } from '../remove-format';
import { isCollapsed } from '../is-collapsed';
import { LINE_SEPARATOR } from '../special-characters';
import { indentListItems } from '../indent-list-items';
import { getActiveFormats } from '../get-active-formats';
import { updateFormats } from '../update-formats';
import { removeLineSeparator } from '../remove-line-separator';
/**
 * Browser dependencies
 */

var _window = window,
    getSelection = _window.getSelection,
    getComputedStyle = _window.getComputedStyle;
/**
 * All inserting input types that would insert HTML into the DOM.
 *
 * @see https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes
 *
 * @type {Set}
 */

var INSERTION_INPUT_TYPES_TO_IGNORE = new Set(['insertParagraph', 'insertOrderedList', 'insertUnorderedList', 'insertHorizontalRule', 'insertLink']);
/**
 * Global stylesheet.
 */

var globalStyle = document.createElement('style');
document.head.appendChild(globalStyle);

function createPrepareEditableTree(props, prefix) {
  var fns = Object.keys(props).reduce(function (accumulator, key) {
    if (key.startsWith(prefix)) {
      accumulator.push(props[key]);
    }

    return accumulator;
  }, []);
  return function (value) {
    return fns.reduce(function (accumulator, fn) {
      return fn(accumulator, value.text);
    }, value.formats);
  };
}
/**
 * If the selection is set on the placeholder element, collapse the selection to
 * the start (before the placeholder).
 */


function fixPlaceholderSelection() {
  var selection = window.getSelection();
  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset;

  if (anchorNode.nodeType !== anchorNode.ELEMENT_NODE) {
    return;
  }

  var targetNode = anchorNode.childNodes[anchorOffset];

  if (!targetNode || targetNode.nodeType !== targetNode.ELEMENT_NODE || !targetNode.getAttribute('data-rich-text-placeholder')) {
    return;
  }

  selection.collapseToStart();
}
/**
 * See export statement below.
 */


var RichText =
/*#__PURE__*/
function (_Component) {
  _inherits(RichText, _Component);

  function RichText(_ref) {
    var _this;

    var value = _ref.value,
        selectionStart = _ref.selectionStart,
        selectionEnd = _ref.selectionEnd;

    _classCallCheck(this, RichText);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RichText).apply(this, arguments));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized(_this));
    _this.onChange = _this.onChange.bind(_assertThisInitialized(_this));
    _this.handleDelete = _this.handleDelete.bind(_assertThisInitialized(_this));
    _this.handleEnter = _this.handleEnter.bind(_assertThisInitialized(_this));
    _this.handleSpace = _this.handleSpace.bind(_assertThisInitialized(_this));
    _this.handleHorizontalNavigation = _this.handleHorizontalNavigation.bind(_assertThisInitialized(_this));
    _this.onPaste = _this.onPaste.bind(_assertThisInitialized(_this));
    _this.onCreateUndoLevel = _this.onCreateUndoLevel.bind(_assertThisInitialized(_this));
    _this.onInput = _this.onInput.bind(_assertThisInitialized(_this));
    _this.onCompositionEnd = _this.onCompositionEnd.bind(_assertThisInitialized(_this));
    _this.onSelectionChange = _this.onSelectionChange.bind(_assertThisInitialized(_this));
    _this.createRecord = _this.createRecord.bind(_assertThisInitialized(_this));
    _this.applyRecord = _this.applyRecord.bind(_assertThisInitialized(_this));
    _this.valueToFormat = _this.valueToFormat.bind(_assertThisInitialized(_this));
    _this.setRef = _this.setRef.bind(_assertThisInitialized(_this));
    _this.valueToEditableHTML = _this.valueToEditableHTML.bind(_assertThisInitialized(_this));
    _this.onPointerDown = _this.onPointerDown.bind(_assertThisInitialized(_this));
    _this.formatToValue = _this.formatToValue.bind(_assertThisInitialized(_this));
    _this.Editable = _this.Editable.bind(_assertThisInitialized(_this));

    _this.onKeyDown = function (event) {
      if (event.defaultPrevented) {
        return;
      }

      _this.handleDelete(event);

      _this.handleEnter(event);

      _this.handleSpace(event);

      _this.handleHorizontalNavigation(event);
    };

    _this.state = {};
    _this.lastHistoryValue = value; // Internal values are updated synchronously, unlike props and state.

    _this.value = value;
    _this.record = _this.formatToValue(value);
    _this.record.start = selectionStart;
    _this.record.end = selectionEnd;
    return _this;
  }

  _createClass(RichText, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.removeEventListener('selectionchange', this.onSelectionChange);
      window.cancelAnimationFrame(this.rafId);
    }
  }, {
    key: "setRef",
    value: function setRef(node) {
      if (node) {
        if (process.env.NODE_ENV === 'development') {
          var computedStyle = getComputedStyle(node);

          if (computedStyle.display === 'inline') {
            // eslint-disable-next-line no-console
            console.warn('RichText cannot be used with an inline container. Please use a different tagName.');
          }
        }

        this.editableRef = node;
      } else {
        delete this.editableRef;
      }
    }
  }, {
    key: "createRecord",
    value: function createRecord() {
      var multilineTag = this.props.__unstableMultilineTag;
      var selection = getSelection();
      var range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
      return create({
        element: this.editableRef,
        range: range,
        multilineTag: multilineTag,
        multilineWrapperTags: multilineTag === 'li' ? ['ul', 'ol'] : undefined,
        __unstableIsEditableTree: true
      });
    }
  }, {
    key: "applyRecord",
    value: function applyRecord(record) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          domOnly = _ref2.domOnly;

      var multilineTag = this.props.__unstableMultilineTag;
      apply({
        value: record,
        current: this.editableRef,
        multilineTag: multilineTag,
        multilineWrapperTags: multilineTag === 'li' ? ['ul', 'ol'] : undefined,
        prepareEditableTree: createPrepareEditableTree(this.props, 'format_prepare_functions'),
        __unstableDomOnly: domOnly,
        placeholder: this.props.placeholder
      });
    }
    /**
     * Handles a paste event.
     *
     * Saves the pasted data as plain text in `pastedPlainText`.
     *
     * @param {PasteEvent} event The paste event.
     */

  }, {
    key: "onPaste",
    value: function onPaste(event) {
      var _this$props = this.props,
          formatTypes = _this$props.formatTypes,
          onPaste = _this$props.onPaste;
      var clipboardData = event.clipboardData;
      var items = clipboardData.items,
          files = clipboardData.files; // In Edge these properties can be null instead of undefined, so a more
      // rigorous test is required over using default values.

      items = isNil(items) ? [] : items;
      files = isNil(files) ? [] : files;
      var plainText = '';
      var html = ''; // IE11 only supports `Text` as an argument for `getData` and will
      // otherwise throw an invalid argument error, so we try the standard
      // arguments first, then fallback to `Text` if they fail.

      try {
        plainText = clipboardData.getData('text/plain');
        html = clipboardData.getData('text/html');
      } catch (error1) {
        try {
          html = clipboardData.getData('Text');
        } catch (error2) {
          // Some browsers like UC Browser paste plain text by default and
          // don't support clipboardData at all, so allow default
          // behaviour.
          return;
        }
      }

      event.preventDefault(); // Allows us to ask for this information when we get a report.

      window.console.log('Received HTML:\n\n', html);
      window.console.log('Received plain text:\n\n', plainText);
      var record = this.record;
      var transformed = formatTypes.reduce(function (accumlator, _ref3) {
        var __unstablePasteRule = _ref3.__unstablePasteRule;

        // Only allow one transform.
        if (__unstablePasteRule && accumlator === record) {
          accumlator = __unstablePasteRule(record, {
            html: html,
            plainText: plainText
          });
        }

        return accumlator;
      }, record);

      if (transformed !== record) {
        this.onChange(transformed);
        return;
      }

      if (onPaste) {
        // Only process file if no HTML is present.
        // Note: a pasted file may have the URL as plain text.
        var image = find([].concat(_toConsumableArray(items), _toConsumableArray(files)), function (_ref4) {
          var type = _ref4.type;
          return /^image\/(?:jpe?g|png|gif)$/.test(type);
        });
        onPaste({
          value: this.removeEditorOnlyFormats(record),
          onChange: this.onChange,
          html: html,
          plainText: plainText,
          image: image
        });
      }
    }
    /**
     * Handles a focus event on the contenteditable field, calling the
     * `unstableOnFocus` prop callback if one is defined. The callback does not
     * receive any arguments.
     *
     * This is marked as a private API and the `unstableOnFocus` prop is not
     * documented, as the current requirements where it is used are subject to
     * future refactoring following `isSelected` handling.
     *
     * In contrast with `setFocusedElement`, this is only triggered in response
     * to focus within the contenteditable field, whereas `setFocusedElement`
     * is triggered on focus within any `RichText` descendent element.
     *
     * @see setFocusedElement
     *
     * @private
     */

  }, {
    key: "onFocus",
    value: function onFocus() {
      var unstableOnFocus = this.props.unstableOnFocus;

      if (unstableOnFocus) {
        unstableOnFocus();
      }

      this.recalculateBoundaryStyle(); // We know for certain that on focus, the old selection is invalid. It
      // will be recalculated on the next mouseup, keyup, or touchend event.

      var index = undefined;
      var activeFormats = undefined;
      this.record = _objectSpread({}, this.record, {
        start: index,
        end: index,
        activeFormats: activeFormats
      });
      this.props.onSelectionChange(index, index);
      this.setState({
        activeFormats: activeFormats
      }); // Update selection as soon as possible, which is at the next animation
      // frame. The event listener for selection changes may be added too late
      // at this point, but this focus event is still too early to calculate
      // the selection.

      this.rafId = window.requestAnimationFrame(this.onSelectionChange);
      document.addEventListener('selectionchange', this.onSelectionChange);

      if (this.props.setFocusedElement) {
        deprecated('wp.blockEditor.RichText setFocusedElement prop', {
          alternative: 'selection state from the block editor store.'
        });
        this.props.setFocusedElement(this.props.instanceId);
      }
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      document.removeEventListener('selectionchange', this.onSelectionChange);
    }
    /**
     * Handle input on the next selection change event.
     *
     * @param {SyntheticEvent} event Synthetic input event.
     */

  }, {
    key: "onInput",
    value: function onInput(event) {
      // For Input Method Editor (IME), used in Chinese, Japanese, and Korean
      // (CJK), do not trigger a change if characters are being composed.
      // Browsers setting `isComposing` to `true` will usually emit a final
      // `input` event when the characters are composed.
      if (event && event.nativeEvent && event.nativeEvent.isComposing) {
        // Also don't update any selection.
        document.removeEventListener('selectionchange', this.onSelectionChange);
        return;
      }

      var inputType;

      if (event) {
        inputType = event.inputType;
      }

      if (!inputType) {
        inputType = event.nativeEvent.inputType;
      } // The browser formatted something or tried to insert HTML.
      // Overwrite it. It will be handled later by the format library if
      // needed.


      if (inputType && (inputType.indexOf('format') === 0 || INSERTION_INPUT_TYPES_TO_IGNORE.has(inputType))) {
        this.applyRecord(this.record);
        return;
      }

      var value = this.createRecord();
      var _this$record = this.record,
          start = _this$record.start,
          _this$record$activeFo = _this$record.activeFormats,
          activeFormats = _this$record$activeFo === void 0 ? [] : _this$record$activeFo; // Update the formats between the last and new caret position.

      var change = updateFormats({
        value: value,
        start: start,
        end: value.start,
        formats: activeFormats
      });
      this.onChange(change, {
        withoutHistory: true
      });
      var _this$props2 = this.props,
          inputRule = _this$props2.__unstableInputRule,
          markAutomaticChange = _this$props2.__unstableMarkAutomaticChange,
          formatTypes = _this$props2.formatTypes,
          setTimeout = _this$props2.setTimeout,
          clearTimeout = _this$props2.clearTimeout; // Create an undo level when input stops for over a second.

      clearTimeout(this.onInput.timeout);
      this.onInput.timeout = setTimeout(this.onCreateUndoLevel, 1000); // Only run input rules when inserting text.

      if (inputType !== 'insertText') {
        return;
      }

      if (inputRule) {
        inputRule(change, this.valueToFormat);
      }

      var transformed = formatTypes.reduce(function (accumlator, _ref5) {
        var __unstableInputRule = _ref5.__unstableInputRule;

        if (__unstableInputRule) {
          accumlator = __unstableInputRule(accumlator);
        }

        return accumlator;
      }, change);

      if (transformed !== change) {
        this.onCreateUndoLevel();
        this.onChange(_objectSpread({}, transformed, {
          activeFormats: activeFormats
        }));
        markAutomaticChange();
      }
    }
  }, {
    key: "onCompositionEnd",
    value: function onCompositionEnd() {
      // Ensure the value is up-to-date for browsers that don't emit a final
      // input event after composition.
      this.onInput({
        inputType: 'insertText'
      }); // Tracking selection changes can be resumed.

      document.addEventListener('selectionchange', this.onSelectionChange);
    }
    /**
     * Syncs the selection to local state. A callback for the `selectionchange`
     * native events, `keyup`, `mouseup` and `touchend` synthetic events, and
     * animation frames after the `focus` event.
     *
     * @param {Event|SyntheticEvent|DOMHighResTimeStamp} event
     */

  }, {
    key: "onSelectionChange",
    value: function onSelectionChange(event) {
      if (event.type !== 'selectionchange' && !this.props.__unstableIsSelected) {
        return;
      } // In case of a keyboard event, ignore selection changes during
      // composition.


      if (event.nativeEvent && event.nativeEvent.isComposing) {
        return;
      }

      var _this$createRecord = this.createRecord(),
          start = _this$createRecord.start,
          end = _this$createRecord.end,
          text = _this$createRecord.text;

      var value = this.record; // Fallback mechanism for IE11, which doesn't support the input event.
      // Any input results in a selection change.

      if (text !== value.text) {
        this.onInput();
        return;
      }

      if (start === value.start && end === value.end) {
        // Sometimes the browser may set the selection on the placeholder
        // element, in which case the caret is not visible. We need to set
        // the caret before the placeholder if that's the case.
        if (value.text.length === 0 && start === 0) {
          fixPlaceholderSelection();
        }

        return;
      }

      var _this$props3 = this.props,
          isCaretWithinFormattedText = _this$props3.__unstableIsCaretWithinFormattedText,
          onEnterFormattedText = _this$props3.__unstableOnEnterFormattedText,
          onExitFormattedText = _this$props3.__unstableOnExitFormattedText;

      var newValue = _objectSpread({}, value, {
        start: start,
        end: end,
        // Allow `getActiveFormats` to get new `activeFormats`.
        activeFormats: undefined
      });

      var activeFormats = getActiveFormats(newValue); // Update the value with the new active formats.

      newValue.activeFormats = activeFormats;

      if (!isCaretWithinFormattedText && activeFormats.length) {
        onEnterFormattedText();
      } else if (isCaretWithinFormattedText && !activeFormats.length) {
        onExitFormattedText();
      } // It is important that the internal value is updated first,
      // otherwise the value will be wrong on render!


      this.record = newValue;
      this.applyRecord(newValue, {
        domOnly: true
      });
      this.props.onSelectionChange(start, end);
      this.setState({
        activeFormats: activeFormats
      });

      if (activeFormats.length > 0) {
        this.recalculateBoundaryStyle();
      }
    }
  }, {
    key: "recalculateBoundaryStyle",
    value: function recalculateBoundaryStyle() {
      var boundarySelector = '*[data-rich-text-format-boundary]';
      var element = this.editableRef.querySelector(boundarySelector);

      if (!element) {
        return;
      }

      var computedStyle = getComputedStyle(element);
      var newColor = computedStyle.color.replace(')', ', 0.2)').replace('rgb', 'rgba');
      var selector = ".rich-text:focus ".concat(boundarySelector);
      var rule = "background-color: ".concat(newColor);
      globalStyle.innerHTML = "".concat(selector, " {").concat(rule, "}");
    }
    /**
     * Sync the value to global state. The node tree and selection will also be
     * updated if differences are found.
     *
     * @param {Object}  record            The record to sync and apply.
     * @param {Object}  $2                Named options.
     * @param {boolean} $2.withoutHistory If true, no undo level will be
     *                                    created.
     */

  }, {
    key: "onChange",
    value: function onChange(record) {
      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          withoutHistory = _ref6.withoutHistory;

      this.applyRecord(record);
      var start = record.start,
          end = record.end,
          _record$activeFormats = record.activeFormats,
          activeFormats = _record$activeFormats === void 0 ? [] : _record$activeFormats;
      var changeHandlers = pickBy(this.props, function (v, key) {
        return key.startsWith('format_on_change_functions_');
      });
      Object.values(changeHandlers).forEach(function (changeHandler) {
        changeHandler(record.formats, record.text);
      });
      this.value = this.valueToFormat(record);
      this.record = record;
      this.props.onChange(this.value);
      this.props.onSelectionChange(start, end);
      this.setState({
        activeFormats: activeFormats
      });

      if (!withoutHistory) {
        this.onCreateUndoLevel();
      }
    }
  }, {
    key: "onCreateUndoLevel",
    value: function onCreateUndoLevel() {
      // If the content is the same, no level needs to be created.
      if (this.lastHistoryValue === this.value) {
        return;
      }

      this.props.__unstableOnCreateUndoLevel();

      this.lastHistoryValue = this.value;
    }
    /**
     * Handles delete on keydown:
     * - outdent list items,
     * - delete content if everything is selected,
     * - trigger the onDelete prop when selection is uncollapsed and at an edge.
     *
     * @param {SyntheticEvent} event A synthetic keyboard event.
     */

  }, {
    key: "handleDelete",
    value: function handleDelete(event) {
      var keyCode = event.keyCode;

      if (keyCode !== DELETE && keyCode !== BACKSPACE && keyCode !== ESCAPE) {
        return;
      }

      if (this.props.__unstableDidAutomaticChange) {
        event.preventDefault();

        this.props.__unstableUndo();

        return;
      }

      if (keyCode === ESCAPE) {
        return;
      }

      var _this$props4 = this.props,
          onDelete = _this$props4.onDelete,
          multilineTag = _this$props4.__unstableMultilineTag;
      var _this$state$activeFor = this.state.activeFormats,
          activeFormats = _this$state$activeFor === void 0 ? [] : _this$state$activeFor;
      var value = this.createRecord();
      var start = value.start,
          end = value.end,
          text = value.text;
      var isReverse = keyCode === BACKSPACE;

      if (multilineTag) {
        var newValue = removeLineSeparator(value, isReverse);

        if (newValue) {
          this.onChange(newValue);
          event.preventDefault();
        }
      } // Always handle full content deletion ourselves.


      if (start === 0 && end !== 0 && end === text.length) {
        this.onChange(remove(value));
        event.preventDefault();
        return;
      } // Only process delete if the key press occurs at an uncollapsed edge.


      if (!onDelete || !isCollapsed(value) || activeFormats.length || isReverse && start !== 0 || !isReverse && end !== text.length) {
        return;
      }

      onDelete({
        isReverse: isReverse,
        value: value
      });
      event.preventDefault();
    }
    /**
     * Triggers the `onEnter` prop on keydown.
     *
     * @param {SyntheticEvent} event A synthetic keyboard event.
     */

  }, {
    key: "handleEnter",
    value: function handleEnter(event) {
      if (event.keyCode !== ENTER) {
        return;
      }

      event.preventDefault();
      var onEnter = this.props.onEnter;

      if (!onEnter) {
        return;
      }

      onEnter({
        value: this.removeEditorOnlyFormats(this.createRecord()),
        onChange: this.onChange,
        shiftKey: event.shiftKey
      });
    }
    /**
     * Indents list items on space keydown.
     *
     * @param {SyntheticEvent} event A synthetic keyboard event.
     */

  }, {
    key: "handleSpace",
    value: function handleSpace(event) {
      var keyCode = event.keyCode,
          shiftKey = event.shiftKey,
          altKey = event.altKey,
          metaKey = event.metaKey,
          ctrlKey = event.ctrlKey;
      var _this$props5 = this.props,
          tagName = _this$props5.tagName,
          multilineTag = _this$props5.__unstableMultilineTag;

      if ( // Only override when no modifiers are pressed.
      shiftKey || altKey || metaKey || ctrlKey || keyCode !== SPACE || multilineTag !== 'li') {
        return;
      }

      var value = this.createRecord();

      if (!isCollapsed(value)) {
        return;
      }

      var text = value.text,
          start = value.start;
      var characterBefore = text[start - 1]; // The caret must be at the start of a line.

      if (characterBefore && characterBefore !== LINE_SEPARATOR) {
        return;
      }

      this.onChange(indentListItems(value, {
        type: tagName
      }));
      event.preventDefault();
    }
    /**
     * Handles horizontal keyboard navigation when no modifiers are pressed. The
     * navigation is handled separately to move correctly around format
     * boundaries.
     *
     * @param  {SyntheticEvent} event A synthetic keyboard event.
     */

  }, {
    key: "handleHorizontalNavigation",
    value: function handleHorizontalNavigation(event) {
      var _this2 = this;

      var keyCode = event.keyCode,
          shiftKey = event.shiftKey,
          altKey = event.altKey,
          metaKey = event.metaKey,
          ctrlKey = event.ctrlKey;

      if ( // Only override left and right keys without modifiers pressed.
      shiftKey || altKey || metaKey || ctrlKey || keyCode !== LEFT && keyCode !== RIGHT) {
        return;
      }

      var value = this.record;
      var text = value.text,
          formats = value.formats,
          start = value.start,
          end = value.end,
          _value$activeFormats = value.activeFormats,
          activeFormats = _value$activeFormats === void 0 ? [] : _value$activeFormats;
      var collapsed = isCollapsed(value); // To do: ideally, we should look at visual position instead.

      var _getComputedStyle = getComputedStyle(this.editableRef),
          direction = _getComputedStyle.direction;

      var reverseKey = direction === 'rtl' ? RIGHT : LEFT;
      var isReverse = event.keyCode === reverseKey; // If the selection is collapsed and at the very start, do nothing if
      // navigating backward.
      // If the selection is collapsed and at the very end, do nothing if
      // navigating forward.

      if (collapsed && activeFormats.length === 0) {
        if (start === 0 && isReverse) {
          return;
        }

        if (end === text.length && !isReverse) {
          return;
        }
      } // If the selection is not collapsed, let the browser handle collapsing
      // the selection for now. Later we could expand this logic to set
      // boundary positions if needed.


      if (!collapsed) {
        return;
      } // In all other cases, prevent default behaviour.


      event.preventDefault();
      var formatsBefore = formats[start - 1] || [];
      var formatsAfter = formats[start] || [];
      var newActiveFormatsLength = activeFormats.length;
      var source = formatsAfter;

      if (formatsBefore.length > formatsAfter.length) {
        source = formatsBefore;
      } // If the amount of formats before the caret and after the caret is
      // different, the caret is at a format boundary.


      if (formatsBefore.length < formatsAfter.length) {
        if (!isReverse && activeFormats.length < formatsAfter.length) {
          newActiveFormatsLength++;
        }

        if (isReverse && activeFormats.length > formatsBefore.length) {
          newActiveFormatsLength--;
        }
      } else if (formatsBefore.length > formatsAfter.length) {
        if (!isReverse && activeFormats.length > formatsAfter.length) {
          newActiveFormatsLength--;
        }

        if (isReverse && activeFormats.length < formatsBefore.length) {
          newActiveFormatsLength++;
        }
      } // Wait for boundary class to be added.


      this.props.setTimeout(function () {
        return _this2.recalculateBoundaryStyle();
      });

      if (newActiveFormatsLength !== activeFormats.length) {
        var _newActiveFormats = source.slice(0, newActiveFormatsLength);

        var _newValue = _objectSpread({}, value, {
          activeFormats: _newActiveFormats
        });

        this.record = _newValue;
        this.applyRecord(_newValue);
        this.setState({
          activeFormats: _newActiveFormats
        });
        return;
      }

      var newPos = start + (isReverse ? -1 : 1);
      var newActiveFormats = isReverse ? formatsBefore : formatsAfter;

      var newValue = _objectSpread({}, value, {
        start: newPos,
        end: newPos,
        activeFormats: newActiveFormats
      });

      this.record = newValue;
      this.applyRecord(newValue);
      this.props.onSelectionChange(newPos, newPos);
      this.setState({
        activeFormats: newActiveFormats
      });
    }
    /**
     * Select object when they are clicked. The browser will not set any
     * selection when clicking e.g. an image.
     *
     * @param  {SyntheticEvent} event Synthetic mousedown or touchstart event.
     */

  }, {
    key: "onPointerDown",
    value: function onPointerDown(event) {
      var target = event.target; // If the child element has no text content, it must be an object.

      if (target === this.editableRef || target.textContent) {
        return;
      }

      var parentNode = target.parentNode;
      var index = Array.from(parentNode.childNodes).indexOf(target);
      var range = target.ownerDocument.createRange();
      var selection = getSelection();
      range.setStart(target.parentNode, index);
      range.setEnd(target.parentNode, index + 1);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props,
          tagName = _this$props6.tagName,
          value = _this$props6.value,
          selectionStart = _this$props6.selectionStart,
          selectionEnd = _this$props6.selectionEnd,
          placeholder = _this$props6.placeholder,
          isSelected = _this$props6.__unstableIsSelected; // Check if the content changed.

      var shouldReapply = tagName === prevProps.tagName && value !== prevProps.value && value !== this.value; // Check if the selection changed.

      shouldReapply = shouldReapply || isSelected && !prevProps.isSelected && (this.record.start !== selectionStart || this.record.end !== selectionEnd);
      var prefix = 'format_prepare_props_';

      var predicate = function predicate(v, key) {
        return key.startsWith(prefix);
      };

      var prepareProps = pickBy(this.props, predicate);
      var prevPrepareProps = pickBy(prevProps, predicate); // Check if any format props changed.

      shouldReapply = shouldReapply || !isShallowEqual(prepareProps, prevPrepareProps); // Rerender if the placeholder changed.

      shouldReapply = shouldReapply || placeholder !== prevProps.placeholder;

      if (shouldReapply) {
        this.value = value;
        this.record = this.formatToValue(value);
        this.record.start = selectionStart;
        this.record.end = selectionEnd;
        this.applyRecord(this.record);
      } else if (this.record.start !== selectionStart || this.record.end !== selectionEnd) {
        this.record = _objectSpread({}, this.record, {
          start: selectionStart,
          end: selectionEnd
        });
      }
    }
    /**
     * Converts the outside data structure to our internal representation.
     *
     * @param {*} value The outside value, data type depends on props.
     * @return {Object} An internal rich-text value.
     */

  }, {
    key: "formatToValue",
    value: function formatToValue(value) {
      var _this$props7 = this.props,
          format = _this$props7.format,
          multilineTag = _this$props7.__unstableMultilineTag;

      if (format !== 'string') {
        return value;
      }

      var prepare = createPrepareEditableTree(this.props, 'format_value_functions');
      value = create({
        html: value,
        multilineTag: multilineTag,
        multilineWrapperTags: multilineTag === 'li' ? ['ul', 'ol'] : undefined
      });
      value.formats = prepare(value);
      return value;
    }
  }, {
    key: "valueToEditableHTML",
    value: function valueToEditableHTML(value) {
      var multilineTag = this.props.__unstableMultilineTag;
      return toDom({
        value: value,
        multilineTag: multilineTag,
        prepareEditableTree: createPrepareEditableTree(this.props, 'format_prepare_functions'),
        placeholder: this.props.placeholder
      }).body.innerHTML;
    }
    /**
     * Removes editor only formats from the value.
     *
     * Editor only formats are applied using `prepareEditableTree`, so we need to
     * remove them before converting the internal state
     *
     * @param {Object} value The internal rich-text value.
     * @return {Object} A new rich-text value.
     */

  }, {
    key: "removeEditorOnlyFormats",
    value: function removeEditorOnlyFormats(value) {
      this.props.formatTypes.forEach(function (formatType) {
        // Remove formats created by prepareEditableTree, because they are editor only.
        if (formatType.__experimentalCreatePrepareEditableTree) {
          value = removeFormat(value, formatType.name, 0, value.text.length);
        }
      });
      return value;
    }
    /**
     * Converts the internal value to the external data format.
     *
     * @param {Object} value The internal rich-text value.
     * @return {*} The external data format, data type depends on props.
     */

  }, {
    key: "valueToFormat",
    value: function valueToFormat(value) {
      var _this$props8 = this.props,
          format = _this$props8.format,
          multilineTag = _this$props8.__unstableMultilineTag;
      value = this.removeEditorOnlyFormats(value);

      if (format !== 'string') {
        return;
      }

      return toHTMLString({
        value: value,
        multilineTag: multilineTag
      });
    }
  }, {
    key: "Editable",
    value: function Editable(props) {
      var _this3 = this;

      var _this$props9 = this.props,
          _this$props9$tagName = _this$props9.tagName,
          Tagname = _this$props9$tagName === void 0 ? 'div' : _this$props9$tagName,
          style = _this$props9.style,
          className = _this$props9.className,
          placeholder = _this$props9.placeholder; // Generating a key that includes `tagName` ensures that if the tag
      // changes, we replace the relevant element. This is needed because we
      // prevent Editable component updates.

      var key = Tagname;
      return createElement(_Editable, _extends({}, props, {
        tagName: Tagname,
        style: style,
        record: this.record,
        valueToEditableHTML: this.valueToEditableHTML,
        "aria-label": placeholder
      }, pickAriaProps(this.props), {
        className: classnames('rich-text', className),
        key: key,
        onPaste: this.onPaste,
        onInput: this.onInput,
        onCompositionEnd: this.onCompositionEnd,
        onKeyDown: props.onKeyDown ? function (event) {
          props.onKeyDown(event);

          _this3.onKeyDown(event);
        } : this.onKeyDown,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onMouseDown: this.onPointerDown,
        onTouchStart: this.onPointerDown,
        setRef: this.setRef // Selection updates must be done at these events as they
        // happen before the `selectionchange` event. In some cases,
        // the `selectionchange` event may not even fire, for
        // example when the window receives focus again on click.
        ,
        onKeyUp: this.onSelectionChange,
        onMouseUp: this.onSelectionChange,
        onTouchEnd: this.onSelectionChange
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props10 = this.props,
          isSelected = _this$props10.__unstableIsSelected,
          children = _this$props10.children,
          allowedFormats = _this$props10.allowedFormats,
          withoutInteractiveFormatting = _this$props10.withoutInteractiveFormatting;
      return createElement(Fragment, null, isSelected && createElement(FormatEdit, {
        allowedFormats: allowedFormats,
        withoutInteractiveFormatting: withoutInteractiveFormatting,
        value: this.record,
        onChange: this.onChange
      }), children && children({
        isSelected: isSelected,
        value: this.record,
        onChange: this.onChange,
        Editable: this.Editable
      }), !children && createElement(this.Editable, null));
    }
  }]);

  return RichText;
}(Component);

RichText.defaultProps = {
  format: 'string',
  value: ''
};
/**
 * Renders a rich content input, providing users with the option to format the
 * content.
 */

export default compose([withSelect(function (select) {
  return {
    formatTypes: select('core/rich-text').getFormatTypes()
  };
}), withSafeTimeout])(RichText);
//# sourceMappingURL=index.js.map