"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _lodash = require("lodash");

var _element = require("@wordpress/element");

var _aria = require("./aria");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
var Editable =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(Editable, _Component);

  function Editable() {
    var _this;

    (0, _classCallCheck2.default)(this, Editable);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Editable).call(this));
    _this.bindEditorNode = _this.bindEditorNode.bind((0, _assertThisInitialized2.default)(_this));
    return _this;
  } // We must prevent rerenders because the browser will modify the DOM. React
  // will rerender the DOM fine, but we're losing selection and it would be
  // more expensive to do so as it would just set the inner HTML through
  // `dangerouslySetInnerHTML`. Instead RichText does it's own diffing and
  // selection setting.
  //
  // Because we never update the component, we have to look through props and
  // update the attributes on the wrapper nodes here. `componentDidUpdate`
  // will never be called.


  (0, _createClass2.default)(Editable, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var _this2 = this;

      if (!(0, _lodash.isEqual)(this.props.style, nextProps.style)) {
        this.editorNode.setAttribute('style', '');
        Object.assign(this.editorNode.style, (0, _objectSpread2.default)({}, nextProps.style || {}, {
          whiteSpace: 'pre-wrap'
        }));
      }

      if (!(0, _lodash.isEqual)(this.props.className, nextProps.className)) {
        this.editorNode.className = nextProps.className;
      }

      if (this.props.start !== nextProps.start) {
        this.editorNode.setAttribute('start', nextProps.start);
      }

      if (this.props.reversed !== nextProps.reversed) {
        this.editorNode.reversed = nextProps.reversed;
      }

      var _diffAriaProps = (0, _aria.diffAriaProps)(this.props, nextProps),
          removedKeys = _diffAriaProps.removedKeys,
          updatedKeys = _diffAriaProps.updatedKeys;

      removedKeys.forEach(function (key) {
        return _this2.editorNode.removeAttribute(key);
      });
      updatedKeys.forEach(function (key) {
        return _this2.editorNode.setAttribute(key, nextProps[key]);
      });
      return false;
    }
  }, {
    key: "bindEditorNode",
    value: function bindEditorNode(editorNode) {
      this.editorNode = editorNode;
      this.props.setRef(editorNode);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          _this$props$tagName = _this$props.tagName,
          tagName = _this$props$tagName === void 0 ? 'div' : _this$props$tagName,
          _this$props$style = _this$props.style,
          style = _this$props$style === void 0 ? {} : _this$props$style,
          record = _this$props.record,
          valueToEditableHTML = _this$props.valueToEditableHTML,
          className = _this$props.className,
          remainingProps = (0, _objectWithoutProperties2.default)(_this$props, ["tagName", "style", "record", "valueToEditableHTML", "className"]);
      delete remainingProps.setRef; // In HTML, leading and trailing spaces are not visible, and multiple
      // spaces elsewhere are visually reduced to one space. This rule
      // prevents spaces from collapsing so all space is visible in the editor
      // and can be removed.
      // It also prevents some browsers from inserting non-breaking spaces at
      // the end of a line to prevent the space from visually disappearing.
      // Sometimes these non breaking spaces can linger in the editor causing
      // unwanted non breaking spaces in between words. If also prevent
      // Firefox from inserting a trailing `br` node to visualise any trailing
      // space, causing the element to be saved.
      //
      // > Authors are encouraged to set the 'white-space' property on editing
      // > hosts and on markup that was originally created through these
      // > editing mechanisms to the value 'pre-wrap'. Default HTML whitespace
      // > handling is not well suited to WYSIWYG editing, and line wrapping
      // > will not work correctly in some corner cases if 'white-space' is
      // > left at its default value.
      // >
      // > https://html.spec.whatwg.org/multipage/interaction.html#best-practices-for-in-page-editors

      var whiteSpace = 'pre-wrap';
      return (0, _element.createElement)(tagName, (0, _objectSpread2.default)({
        role: 'textbox',
        'aria-multiline': true,
        className: className,
        contentEditable: true,
        ref: this.bindEditorNode,
        style: (0, _objectSpread2.default)({}, style, {
          whiteSpace: whiteSpace
        }),
        suppressContentEditableWarning: true,
        dangerouslySetInnerHTML: {
          __html: valueToEditableHTML(record)
        }
      }, remainingProps));
    }
  }]);
  return Editable;
}(_element.Component);

exports.default = Editable;
//# sourceMappingURL=editable.js.map