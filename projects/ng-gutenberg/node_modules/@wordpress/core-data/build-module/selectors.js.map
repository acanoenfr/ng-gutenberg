{"version":3,"sources":["@wordpress/core-data/src/selectors.js"],"names":["createSelector","map","find","get","filter","compact","defaultTo","createRegistrySelector","deprecated","REDUCER_KEY","getQueriedItems","isRequestingEmbedPreview","select","state","url","isResolving","getAuthors","getUserQueryResults","getCurrentUser","currentUser","queryID","queryResults","users","queries","id","byId","getEntitiesByKind","kind","entities","config","getEntity","name","getEntityRecord","key","data","getRawEntityRecord","record","Object","keys","reduce","acc","_key","getEntityRecords","query","queriedState","getEntityRecordEdits","recordId","getEntityRecordNonTransientEdits","transientEdits","edits","hasEditsForEntityRecord","isSavingEntityRecord","length","getEditedEntityRecord","isAutosavingEntityRecord","pending","isAutosave","Boolean","getLastEntitySaveError","getCurrentUndoOffset","undo","offset","getUndoEdit","getRedoEdit","hasUndo","hasRedo","getThemeSupports","themeSupports","getEmbedPreview","embedPreviews","isPreviewEmbedFallback","preview","oEmbedLinkCheck","html","hasUploadPermissions","alternative","canUser","action","resource","join","getAutosaves","postType","postId","autosaves","getAutosave","authorId","undefined","author","hasFetchedAutosaves","hasFinishedResolution","getReferenceByDistinctEdits"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport createSelector from 'rememo';\nimport { map, find, get, filter, compact, defaultTo } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { createRegistrySelector } from '@wordpress/data';\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Internal dependencies\n */\nimport { REDUCER_KEY } from './name';\nimport { getQueriedItems } from './queried-data';\n\n/**\n * Returns true if a request is in progress for embed preview data, or false\n * otherwise.\n *\n * @param {Object} state Data state.\n * @param {string} url   URL the preview would be for.\n *\n * @return {boolean} Whether a request is in progress for an embed preview.\n */\nexport const isRequestingEmbedPreview = createRegistrySelector( ( select ) => ( state, url ) => {\n\treturn select( 'core/data' ).isResolving( REDUCER_KEY, 'getEmbedPreview', [ url ] );\n} );\n\n/**\n * Returns all available authors.\n *\n * @param {Object} state Data state.\n *\n * @return {Array} Authors list.\n */\nexport function getAuthors( state ) {\n\treturn getUserQueryResults( state, 'authors' );\n}\n\n/**\n * Returns the current user.\n *\n * @param {Object} state Data state.\n *\n * @return {Object} Current user object.\n */\nexport function getCurrentUser( state ) {\n\treturn state.currentUser;\n}\n\n/**\n * Returns all the users returned by a query ID.\n *\n * @param {Object} state   Data state.\n * @param {string} queryID Query ID.\n *\n * @return {Array} Users list.\n */\nexport const getUserQueryResults = createSelector(\n\t( state, queryID ) => {\n\t\tconst queryResults = state.users.queries[ queryID ];\n\n\t\treturn map( queryResults, ( id ) => state.users.byId[ id ] );\n\t},\n\t( state, queryID ) => [ state.users.queries[ queryID ], state.users.byId ]\n);\n\n/**\n * Returns whether the entities for the give kind are loaded.\n *\n * @param {Object} state   Data state.\n * @param {string} kind  Entity kind.\n *\n * @return {boolean} Whether the entities are loaded\n */\nexport function getEntitiesByKind( state, kind ) {\n\treturn filter( state.entities.config, { kind } );\n}\n\n/**\n * Returns the entity object given its kind and name.\n *\n * @param {Object} state   Data state.\n * @param {string} kind  Entity kind.\n * @param {string} name  Entity name.\n *\n * @return {Object} Entity\n */\nexport function getEntity( state, kind, name ) {\n\treturn find( state.entities.config, { kind, name } );\n}\n\n/**\n * Returns the Entity's record object by key.\n *\n * @param {Object} state  State tree\n * @param {string} kind   Entity kind.\n * @param {string} name   Entity name.\n * @param {number} key    Record's key\n *\n * @return {Object?} Record.\n */\nexport function getEntityRecord( state, kind, name, key ) {\n\treturn get( state.entities.data, [ kind, name, 'queriedData', 'items', key ] );\n}\n\n/**\n * Returns the entity's record object by key,\n * with its attributes mapped to their raw values.\n *\n * @param {Object} state  State tree.\n * @param {string} kind   Entity kind.\n * @param {string} name   Entity name.\n * @param {number} key    Record's key.\n *\n * @return {Object?} Object with the entity's raw attributes.\n */\nexport const getRawEntityRecord = createSelector(\n\t( state, kind, name, key ) => {\n\t\tconst record = getEntityRecord( state, kind, name, key );\n\t\treturn (\n\t\t\trecord &&\n\t\t\t\t\t\t\tObject.keys( record ).reduce( ( acc, _key ) => {\n\t\t\t\t\t\t\t\t// Because edits are the \"raw\" attribute values,\n\t\t\t\t\t\t\t\t// we return those from record selectors to make rendering,\n\t\t\t\t\t\t\t\t// comparisons, and joins with edits easier.\n\t\t\t\t\t\t\t\tacc[ _key ] = get( record[ _key ], 'raw', record[ _key ] );\n\t\t\t\t\t\t\t\treturn acc;\n\t\t\t\t\t\t\t}, {} )\n\t\t);\n\t},\n\t( state ) => [ state.entities.data ]\n);\n\n/**\n * Returns the Entity's records.\n *\n * @param {Object}  state  State tree\n * @param {string}  kind   Entity kind.\n * @param {string}  name   Entity name.\n * @param {?Object} query  Optional terms query.\n *\n * @return {Array} Records.\n */\nexport function getEntityRecords( state, kind, name, query ) {\n\tconst queriedState = get( state.entities.data, [ kind, name, 'queriedData' ] );\n\tif ( ! queriedState ) {\n\t\treturn [];\n\t}\n\treturn getQueriedItems( queriedState, query );\n}\n\n/**\n * Returns the specified entity record's edits.\n *\n * @param {Object} state    State tree.\n * @param {string} kind     Entity kind.\n * @param {string} name     Entity name.\n * @param {number} recordId Record ID.\n *\n * @return {Object?} The entity record's edits.\n */\nexport function getEntityRecordEdits( state, kind, name, recordId ) {\n\treturn get( state.entities.data, [ kind, name, 'edits', recordId ] );\n}\n\n/**\n * Returns the specified entity record's non transient edits.\n *\n * Transient edits don't create an undo level, and\n * are not considered for change detection.\n * They are defined in the entity's config.\n *\n * @param {Object} state    State tree.\n * @param {string} kind     Entity kind.\n * @param {string} name     Entity name.\n * @param {number} recordId Record ID.\n *\n * @return {Object?} The entity record's non transient edits.\n */\nexport const getEntityRecordNonTransientEdits = createSelector(\n\t( state, kind, name, recordId ) => {\n\t\tconst { transientEdits = {} } = getEntity( state, kind, name );\n\t\tconst edits = getEntityRecordEdits( state, kind, name, recordId ) || [];\n\t\treturn Object.keys( edits ).reduce( ( acc, key ) => {\n\t\t\tif ( ! transientEdits[ key ] ) {\n\t\t\t\tacc[ key ] = edits[ key ];\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, {} );\n\t},\n\t( state ) => [ state.entities.config, state.entities.data ]\n);\n\n/**\n * Returns true if the specified entity record has edits,\n * and false otherwise.\n *\n * @param {Object} state    State tree.\n * @param {string} kind     Entity kind.\n * @param {string} name     Entity name.\n * @param {number} recordId Record ID.\n *\n * @return {boolean} Whether the entity record has edits or not.\n */\nexport function hasEditsForEntityRecord( state, kind, name, recordId ) {\n\treturn (\n\t\tisSavingEntityRecord( state, kind, name, recordId ) ||\n\t\tObject.keys( getEntityRecordNonTransientEdits( state, kind, name, recordId ) )\n\t\t\t.length > 0\n\t);\n}\n\n/**\n * Returns the specified entity record, merged with its edits.\n *\n * @param {Object} state    State tree.\n * @param {string} kind     Entity kind.\n * @param {string} name     Entity name.\n * @param {number} recordId Record ID.\n *\n * @return {Object?} The entity record, merged with its edits.\n */\nexport const getEditedEntityRecord = createSelector(\n\t( state, kind, name, recordId ) => ( {\n\t\t...getRawEntityRecord( state, kind, name, recordId ),\n\t\t...getEntityRecordEdits( state, kind, name, recordId ),\n\t} ),\n\t( state ) => [ state.entities.data ]\n);\n\n/**\n * Returns true if the specified entity record is autosaving, and false otherwise.\n *\n * @param {Object} state    State tree.\n * @param {string} kind     Entity kind.\n * @param {string} name     Entity name.\n * @param {number} recordId Record ID.\n *\n * @return {boolean} Whether the entity record is autosaving or not.\n */\nexport function isAutosavingEntityRecord( state, kind, name, recordId ) {\n\tconst { pending, isAutosave } = get(\n\t\tstate.entities.data,\n\t\t[ kind, name, 'saving', recordId ],\n\t\t{}\n\t);\n\treturn Boolean( pending && isAutosave );\n}\n\n/**\n * Returns true if the specified entity record is saving, and false otherwise.\n *\n * @param {Object} state    State tree.\n * @param {string} kind     Entity kind.\n * @param {string} name     Entity name.\n * @param {number} recordId Record ID.\n *\n * @return {boolean} Whether the entity record is saving or not.\n */\nexport function isSavingEntityRecord( state, kind, name, recordId ) {\n\treturn get(\n\t\tstate.entities.data,\n\t\t[ kind, name, 'saving', recordId, 'pending' ],\n\t\tfalse\n\t);\n}\n\n/**\n * Returns the specified entity record's last save error.\n *\n * @param {Object} state    State tree.\n * @param {string} kind     Entity kind.\n * @param {string} name     Entity name.\n * @param {number} recordId Record ID.\n *\n * @return {Object?} The entity record's save error.\n */\nexport function getLastEntitySaveError( state, kind, name, recordId ) {\n\treturn get( state.entities.data, [ kind, name, 'saving', recordId, 'error' ] );\n}\n\n/**\n * Returns the current undo offset for the\n * entity records edits history. The offset\n * represents how many items from the end\n * of the history stack we are at. 0 is the\n * last edit, -1 is the second last, and so on.\n *\n * @param {Object} state State tree.\n *\n * @return {number} The current undo offset.\n */\nfunction getCurrentUndoOffset( state ) {\n\treturn state.undo.offset;\n}\n\n/**\n * Returns the previous edit from the current undo offset\n * for the entity records edits history, if any.\n *\n * @param {Object} state State tree.\n *\n * @return {Object?} The edit.\n */\nexport function getUndoEdit( state ) {\n\treturn state.undo[ state.undo.length - 2 + getCurrentUndoOffset( state ) ];\n}\n\n/**\n * Returns the next edit from the current undo offset\n * for the entity records edits history, if any.\n *\n * @param {Object} state State tree.\n *\n * @return {Object?} The edit.\n */\nexport function getRedoEdit( state ) {\n\treturn state.undo[ state.undo.length + getCurrentUndoOffset( state ) ];\n}\n\n/**\n * Returns true if there is a previous edit from the current undo offset\n * for the entity records edits history, and false otherwise.\n *\n * @param {Object} state State tree.\n *\n * @return {boolean} Whether there is a previous edit or not.\n */\nexport function hasUndo( state ) {\n\treturn Boolean( getUndoEdit( state ) );\n}\n\n/**\n * Returns true if there is a next edit from the current undo offset\n * for the entity records edits history, and false otherwise.\n *\n * @param {Object} state State tree.\n *\n * @return {boolean} Whether there is a next edit or not.\n */\nexport function hasRedo( state ) {\n\treturn Boolean( getRedoEdit( state ) );\n}\n\n/**\n * Return theme supports data in the index.\n *\n * @param {Object} state Data state.\n *\n * @return {*}           Index data.\n */\nexport function getThemeSupports( state ) {\n\treturn state.themeSupports;\n}\n\n/**\n * Returns the embed preview for the given URL.\n *\n * @param {Object} state    Data state.\n * @param {string} url      Embedded URL.\n *\n * @return {*} Undefined if the preview has not been fetched, otherwise, the preview fetched from the embed preview API.\n */\nexport function getEmbedPreview( state, url ) {\n\treturn state.embedPreviews[ url ];\n}\n\n/**\n * Determines if the returned preview is an oEmbed link fallback.\n *\n * WordPress can be configured to return a simple link to a URL if it is not embeddable.\n * We need to be able to determine if a URL is embeddable or not, based on what we\n * get back from the oEmbed preview API.\n *\n * @param {Object} state    Data state.\n * @param {string} url      Embedded URL.\n *\n * @return {boolean} Is the preview for the URL an oEmbed link fallback.\n */\nexport function isPreviewEmbedFallback( state, url ) {\n\tconst preview = state.embedPreviews[ url ];\n\tconst oEmbedLinkCheck = '<a href=\"' + url + '\">' + url + '</a>';\n\tif ( ! preview ) {\n\t\treturn false;\n\t}\n\treturn preview.html === oEmbedLinkCheck;\n}\n\n/**\n * Returns whether the current user can upload media.\n *\n * Calling this may trigger an OPTIONS request to the REST API via the\n * `canUser()` resolver.\n *\n * https://developer.wordpress.org/rest-api/reference/\n *\n * @deprecated since 5.0. Callers should use the more generic `canUser()` selector instead of\n *             `hasUploadPermissions()`, e.g. `canUser( 'create', 'media' )`.\n *\n * @param {Object} state Data state.\n *\n * @return {boolean} Whether or not the user can upload media. Defaults to `true` if the OPTIONS\n *                   request is being made.\n */\nexport function hasUploadPermissions( state ) {\n\tdeprecated( \"select( 'core' ).hasUploadPermissions()\", {\n\t\talternative: \"select( 'core' ).canUser( 'create', 'media' )\",\n\t} );\n\treturn defaultTo( canUser( state, 'create', 'media' ), true );\n}\n\n/**\n * Returns whether the current user can perform the given action on the given\n * REST resource.\n *\n * Calling this may trigger an OPTIONS request to the REST API via the\n * `canUser()` resolver.\n *\n * https://developer.wordpress.org/rest-api/reference/\n *\n * @param {Object}   state            Data state.\n * @param {string}   action           Action to check. One of: 'create', 'read', 'update', 'delete'.\n * @param {string}   resource         REST resource to check, e.g. 'media' or 'posts'.\n * @param {string=}  id               Optional ID of the rest resource to check.\n *\n * @return {boolean|undefined} Whether or not the user can perform the action,\n *                             or `undefined` if the OPTIONS request is still being made.\n */\nexport function canUser( state, action, resource, id ) {\n\tconst key = compact( [ action, resource, id ] ).join( '/' );\n\treturn get( state, [ 'userPermissions', key ] );\n}\n\n/**\n * Returns the latest autosaves for the post.\n *\n * May return multiple autosaves since the backend stores one autosave per\n * author for each post.\n *\n * @param {Object} state    State tree.\n * @param {string} postType The type of the parent post.\n * @param {number} postId   The id of the parent post.\n *\n * @return {?Array} An array of autosaves for the post, or undefined if there is none.\n */\nexport function getAutosaves( state, postType, postId ) {\n\treturn state.autosaves[ postId ];\n}\n\n/**\n * Returns the autosave for the post and author.\n *\n * @param {Object} state    State tree.\n * @param {string} postType The type of the parent post.\n * @param {number} postId   The id of the parent post.\n * @param {number} authorId The id of the author.\n *\n * @return {?Object} The autosave for the post and author.\n */\nexport function getAutosave( state, postType, postId, authorId ) {\n\tif ( authorId === undefined ) {\n\t\treturn;\n\t}\n\n\tconst autosaves = state.autosaves[ postId ];\n\treturn find( autosaves, { author: authorId } );\n}\n\n/**\n * Returns true if the REST request for autosaves has completed.\n *\n * @param {Object} state State tree.\n * @param {string} postType The type of the parent post.\n * @param {number} postId   The id of the parent post.\n *\n * @return {boolean} True if the REST request was completed. False otherwise.\n */\nexport const hasFetchedAutosaves = createRegistrySelector( ( select ) => ( state, postType, postId ) => {\n\treturn select( REDUCER_KEY ).hasFinishedResolution( 'getAutosaves', [ postType, postId ] );\n} );\n\n/**\n * Returns a new reference when edited values have changed. This is useful in\n * inferring where an edit has been made between states by comparison of the\n * return values using strict equality.\n *\n * @example\n *\n * ```\n * const hasEditOccurred = (\n *    getReferenceByDistinctEdits( beforeState ) !==\n *    getReferenceByDistinctEdits( afterState )\n * );\n * ```\n *\n * @param {Object} state Editor state.\n *\n * @return {*} A value whose reference will change only when an edit occurs.\n */\nexport const getReferenceByDistinctEdits = createSelector(\n\t() => [],\n\t( state ) => [ state.undo.length, state.undo.offset ],\n);\n"]}