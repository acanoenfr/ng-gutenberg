"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.receiveUserQuery = receiveUserQuery;
exports.receiveCurrentUser = receiveCurrentUser;
exports.addEntities = addEntities;
exports.receiveEntityRecords = receiveEntityRecords;
exports.receiveThemeSupports = receiveThemeSupports;
exports.receiveEmbedPreview = receiveEmbedPreview;
exports.editEntityRecord = editEntityRecord;
exports.undo = undo;
exports.redo = redo;
exports.__unstableCreateUndoLevel = __unstableCreateUndoLevel;
exports.saveEntityRecord = saveEntityRecord;
exports.saveEditedEntityRecord = saveEditedEntityRecord;
exports.receiveUploadPermissions = receiveUploadPermissions;
exports.receiveUserPermission = receiveUserPermission;
exports.receiveAutosaves = receiveAutosaves;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _lodash = require("lodash");

var _queriedData = require("./queried-data");

var _entities = require("./entities");

var _controls = require("./controls");

var _marked =
/*#__PURE__*/
_regenerator.default.mark(editEntityRecord),
    _marked2 =
/*#__PURE__*/
_regenerator.default.mark(undo),
    _marked3 =
/*#__PURE__*/
_regenerator.default.mark(redo),
    _marked4 =
/*#__PURE__*/
_regenerator.default.mark(saveEntityRecord),
    _marked5 =
/*#__PURE__*/
_regenerator.default.mark(saveEditedEntityRecord);

/**
 * Returns an action object used in signalling that authors have been received.
 *
 * @param {string}       queryID Query ID.
 * @param {Array|Object} users   Users received.
 *
 * @return {Object} Action object.
 */
function receiveUserQuery(queryID, users) {
  return {
    type: 'RECEIVE_USER_QUERY',
    users: (0, _lodash.castArray)(users),
    queryID: queryID
  };
}
/**
 * Returns an action used in signalling that the current user has been received.
 *
 * @param {Object} currentUser Current user object.
 *
 * @return {Object} Action object.
 */


function receiveCurrentUser(currentUser) {
  return {
    type: 'RECEIVE_CURRENT_USER',
    currentUser: currentUser
  };
}
/**
 * Returns an action object used in adding new entities.
 *
 * @param {Array} entities  Entities received.
 *
 * @return {Object} Action object.
 */


function addEntities(entities) {
  return {
    type: 'ADD_ENTITIES',
    entities: entities
  };
}
/**
 * Returns an action object used in signalling that entity records have been received.
 *
 * @param {string}       kind            Kind of the received entity.
 * @param {string}       name            Name of the received entity.
 * @param {Array|Object} records         Records received.
 * @param {?Object}      query           Query Object.
 * @param {?boolean}     invalidateCache Should invalidate query caches
 *
 * @return {Object} Action object.
 */


function receiveEntityRecords(kind, name, records, query) {
  var invalidateCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // Auto drafts should not have titles, but some plugins rely on them so we can't filter this
  // on the server.
  if (kind === 'postType') {
    records = (0, _lodash.castArray)(records).map(function (record) {
      return record.status === 'auto-draft' ? (0, _objectSpread2.default)({}, record, {
        title: ''
      }) : record;
    });
  }

  var action;

  if (query) {
    action = (0, _queriedData.receiveQueriedItems)(records, query);
  } else {
    action = (0, _queriedData.receiveItems)(records);
  }

  return (0, _objectSpread2.default)({}, action, {
    kind: kind,
    name: name,
    invalidateCache: invalidateCache
  });
}
/**
 * Returns an action object used in signalling that the index has been received.
 *
 * @param {Object} themeSupports Theme support for the current theme.
 *
 * @return {Object} Action object.
 */


function receiveThemeSupports(themeSupports) {
  return {
    type: 'RECEIVE_THEME_SUPPORTS',
    themeSupports: themeSupports
  };
}
/**
 * Returns an action object used in signalling that the preview data for
 * a given URl has been received.
 *
 * @param {string}  url      URL to preview the embed for.
 * @param {Mixed}   preview  Preview data.
 *
 * @return {Object} Action object.
 */


function receiveEmbedPreview(url, preview) {
  return {
    type: 'RECEIVE_EMBED_PREVIEW',
    url: url,
    preview: preview
  };
}
/**
 * Returns an action object that triggers an
 * edit to an entity record.
 *
 * @param {string} kind     Kind of the edited entity record.
 * @param {string} name     Name of the edited entity record.
 * @param {number} recordId Record ID of the edited entity record.
 * @param {Object} edits    The edits.
 * @param {Object} options  Options for the edit.
 * @param {boolean} options.undoIgnore Whether to ignore the edit in undo history or not.
 *
 * @return {Object} Action object.
 */


function editEntityRecord(kind, name, recordId, edits) {
  var options,
      _ref,
      _ref$transientEdits,
      transientEdits,
      _ref$mergedEdits,
      mergedEdits,
      record,
      editedRecord,
      edit,
      _args = arguments;

  return _regenerator.default.wrap(function editEntityRecord$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 4 && _args[4] !== undefined ? _args[4] : {};
          _context.next = 3;
          return (0, _controls.select)('getEntity', kind, name);

        case 3:
          _ref = _context.sent;
          _ref$transientEdits = _ref.transientEdits;
          transientEdits = _ref$transientEdits === void 0 ? {} : _ref$transientEdits;
          _ref$mergedEdits = _ref.mergedEdits;
          mergedEdits = _ref$mergedEdits === void 0 ? {} : _ref$mergedEdits;
          _context.next = 10;
          return (0, _controls.select)('getRawEntityRecord', kind, name, recordId);

        case 10:
          record = _context.sent;
          _context.next = 13;
          return (0, _controls.select)('getEditedEntityRecord', kind, name, recordId);

        case 13:
          editedRecord = _context.sent;
          edit = {
            kind: kind,
            name: name,
            recordId: recordId,
            // Clear edits when they are equal to their persisted counterparts
            // so that the property is not considered dirty.
            edits: Object.keys(edits).reduce(function (acc, key) {
              var recordValue = record[key];
              var editedRecordValue = editedRecord[key];
              var value = mergedEdits[key] ? (0, _objectSpread2.default)({}, editedRecordValue, edits[key]) : edits[key];
              acc[key] = (0, _lodash.isEqual)(recordValue, value) ? undefined : value;
              return acc;
            }, {}),
            transientEdits: transientEdits
          };
          return _context.abrupt("return", (0, _objectSpread2.default)({
            type: 'EDIT_ENTITY_RECORD'
          }, edit, {
            meta: {
              undo: !options.undoIgnore && (0, _objectSpread2.default)({}, edit, {
                // Send the current values for things like the first undo stack entry.
                edits: Object.keys(edits).reduce(function (acc, key) {
                  acc[key] = editedRecord[key];
                  return acc;
                }, {})
              })
            }
          }));

        case 16:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
/**
 * Action triggered to undo the last edit to
 * an entity record, if any.
 */


function undo() {
  var undoEdit;
  return _regenerator.default.wrap(function undo$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return (0, _controls.select)('getUndoEdit');

        case 2:
          undoEdit = _context2.sent;

          if (undoEdit) {
            _context2.next = 5;
            break;
          }

          return _context2.abrupt("return");

        case 5:
          _context2.next = 7;
          return (0, _objectSpread2.default)({
            type: 'EDIT_ENTITY_RECORD'
          }, undoEdit, {
            meta: {
              isUndo: true
            }
          });

        case 7:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}
/**
 * Action triggered to redo the last undoed
 * edit to an entity record, if any.
 */


function redo() {
  var redoEdit;
  return _regenerator.default.wrap(function redo$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _controls.select)('getRedoEdit');

        case 2:
          redoEdit = _context3.sent;

          if (redoEdit) {
            _context3.next = 5;
            break;
          }

          return _context3.abrupt("return");

        case 5:
          _context3.next = 7;
          return (0, _objectSpread2.default)({
            type: 'EDIT_ENTITY_RECORD'
          }, redoEdit, {
            meta: {
              isRedo: true
            }
          });

        case 7:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}
/**
 * Forces the creation of a new undo level.
 *
 * @return {Object} Action object.
 */


function __unstableCreateUndoLevel() {
  return {
    type: 'CREATE_UNDO_LEVEL'
  };
}
/**
 * Action triggered to save an entity record.
 *
 * @param {string} kind    Kind of the received entity.
 * @param {string} name    Name of the received entity.
 * @param {Object} record  Record to be saved.
 * @param {Object} options Saving options.
 */


function saveEntityRecord(kind, name, record) {
  var _ref2,
      _ref2$isAutosave,
      isAutosave,
      entities,
      entity,
      entityIdKey,
      recordId,
      updatedRecord,
      error,
      persistedEntity,
      currentEdits,
      path,
      persistedRecord,
      currentUser,
      currentUserId,
      autosavePost,
      data,
      newRecord,
      _data,
      _args4 = arguments;

  return _regenerator.default.wrap(function saveEntityRecord$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _ref2 = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : {
            isAutosave: false
          }, _ref2$isAutosave = _ref2.isAutosave, isAutosave = _ref2$isAutosave === void 0 ? false : _ref2$isAutosave;
          _context4.next = 3;
          return (0, _entities.getKindEntities)(kind);

        case 3:
          entities = _context4.sent;
          entity = (0, _lodash.find)(entities, {
            kind: kind,
            name: name
          });

          if (entity) {
            _context4.next = 7;
            break;
          }

          return _context4.abrupt("return");

        case 7:
          entityIdKey = entity.key || _entities.DEFAULT_ENTITY_KEY;
          recordId = record[entityIdKey];
          _context4.next = 11;
          return {
            type: 'SAVE_ENTITY_RECORD_START',
            kind: kind,
            name: name,
            recordId: recordId,
            isAutosave: isAutosave
          };

        case 11:
          _context4.prev = 11;
          path = "".concat(entity.baseURL).concat(recordId ? '/' + recordId : '');
          _context4.next = 15;
          return (0, _controls.select)('getRawEntityRecord', kind, name, recordId);

        case 15:
          persistedRecord = _context4.sent;

          if (!isAutosave) {
            _context4.next = 40;
            break;
          }

          _context4.next = 19;
          return (0, _controls.select)('getCurrentUser');

        case 19:
          currentUser = _context4.sent;
          currentUserId = currentUser ? currentUser.id : undefined;
          _context4.next = 23;
          return (0, _controls.select)('getAutosave', persistedRecord.type, persistedRecord.id, currentUserId);

        case 23:
          autosavePost = _context4.sent;
          // Autosaves need all expected fields to be present.
          // So we fallback to the previous autosave and then
          // to the actual persisted entity if the edits don't
          // have a value.
          data = (0, _objectSpread2.default)({}, persistedRecord, autosavePost, record);
          data = Object.keys(data).reduce(function (acc, key) {
            if (['title', 'excerpt', 'content'].includes(key)) {
              // Edits should be the "raw" attribute values.
              acc[key] = (0, _lodash.get)(data[key], 'raw', data[key]);
            }

            return acc;
          }, {
            status: data.status === 'auto-draft' ? 'draft' : data.status
          });
          _context4.next = 28;
          return (0, _controls.apiFetch)({
            path: "".concat(path, "/autosaves"),
            method: 'POST',
            data: data
          });

        case 28:
          updatedRecord = _context4.sent;

          if (!(persistedRecord.id === updatedRecord.id)) {
            _context4.next = 36;
            break;
          }

          newRecord = (0, _objectSpread2.default)({}, persistedRecord, data, updatedRecord);
          newRecord = Object.keys(newRecord).reduce(function (acc, key) {
            // These properties are persisted in autosaves.
            if (['title', 'excerpt', 'content'].includes(key)) {
              // Edits should be the "raw" attribute values.
              acc[key] = (0, _lodash.get)(newRecord[key], 'raw', newRecord[key]);
            } else if (key === 'status') {
              // Status is only persisted in autosaves when going from
              // "auto-draft" to "draft".
              acc[key] = persistedRecord.status === 'auto-draft' && newRecord.status === 'draft' ? newRecord.status : persistedRecord.status;
            } else {
              // These properties are not persisted in autosaves.
              acc[key] = (0, _lodash.get)(persistedRecord[key], 'raw', persistedRecord[key]);
            }

            return acc;
          }, {});
          _context4.next = 34;
          return receiveEntityRecords(kind, name, newRecord, undefined, true);

        case 34:
          _context4.next = 38;
          break;

        case 36:
          _context4.next = 38;
          return receiveAutosaves(persistedRecord.id, updatedRecord);

        case 38:
          _context4.next = 55;
          break;

        case 40:
          // Auto drafts should be converted to drafts on explicit saves and we should not respect their default title,
          // but some plugins break with this behavior so we can't filter it on the server.
          _data = record;

          if (kind === 'postType' && persistedRecord && persistedRecord.status === 'auto-draft') {
            if (!_data.status) {
              _data = (0, _objectSpread2.default)({}, _data, {
                status: 'draft'
              });
            }

            if (!_data.title || _data.title === 'Auto Draft') {
              _data = (0, _objectSpread2.default)({}, _data, {
                title: ''
              });
            }
          } // We perform an optimistic update here to clear all the edits that
          // will be persisted so that if the server filters them, the new
          // filtered values are always accepted.


          _context4.next = 44;
          return (0, _controls.select)('getEntityRecord', kind, name, recordId);

        case 44:
          persistedEntity = _context4.sent;
          _context4.next = 47;
          return (0, _controls.select)('getEntityRecordEdits', kind, name, recordId);

        case 47:
          currentEdits = _context4.sent;
          _context4.next = 50;
          return receiveEntityRecords(kind, name, (0, _objectSpread2.default)({}, persistedEntity, _data), undefined, true);

        case 50:
          _context4.next = 52;
          return (0, _controls.apiFetch)({
            path: path,
            method: recordId ? 'PUT' : 'POST',
            data: _data
          });

        case 52:
          updatedRecord = _context4.sent;
          _context4.next = 55;
          return receiveEntityRecords(kind, name, updatedRecord, undefined, true);

        case 55:
          _context4.next = 77;
          break;

        case 57:
          _context4.prev = 57;
          _context4.t0 = _context4["catch"](11);
          error = _context4.t0; // If we got to the point in the try block where we made an optimistic update,
          // we need to roll it back here.

          if (!(persistedEntity && currentEdits)) {
            _context4.next = 77;
            break;
          }

          _context4.next = 63;
          return receiveEntityRecords(kind, name, persistedEntity, undefined, true);

        case 63:
          _context4.t1 = editEntityRecord;
          _context4.t2 = kind;
          _context4.t3 = name;
          _context4.t4 = recordId;
          _context4.t5 = _objectSpread2.default;
          _context4.t6 = {};
          _context4.t7 = currentEdits;
          _context4.next = 72;
          return (0, _controls.select)('getEntityRecordEdits', kind, name, recordId);

        case 72:
          _context4.t8 = _context4.sent;
          _context4.t9 = (0, _context4.t5)(_context4.t6, _context4.t7, _context4.t8);
          _context4.t10 = {
            undoIgnore: true
          };
          _context4.next = 77;
          return (0, _context4.t1)(_context4.t2, _context4.t3, _context4.t4, _context4.t9, _context4.t10);

        case 77:
          _context4.next = 79;
          return {
            type: 'SAVE_ENTITY_RECORD_FINISH',
            kind: kind,
            name: name,
            recordId: recordId,
            error: error,
            isAutosave: isAutosave
          };

        case 79:
          return _context4.abrupt("return", updatedRecord);

        case 80:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, null, [[11, 57]]);
}
/**
 * Action triggered to save an entity record's edits.
 *
 * @param {string} kind     Kind of the entity.
 * @param {string} name     Name of the entity.
 * @param {Object} recordId ID of the record.
 * @param {Object} options  Saving options.
 */


function saveEditedEntityRecord(kind, name, recordId, options) {
  var edits, record;
  return _regenerator.default.wrap(function saveEditedEntityRecord$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _controls.select)('hasEditsForEntityRecord', kind, name, recordId);

        case 2:
          if (_context5.sent) {
            _context5.next = 4;
            break;
          }

          return _context5.abrupt("return");

        case 4:
          _context5.next = 6;
          return (0, _controls.select)('getEntityRecordNonTransientEdits', kind, name, recordId);

        case 6:
          edits = _context5.sent;
          record = (0, _objectSpread2.default)({
            id: recordId
          }, edits);
          return _context5.delegateYield(saveEntityRecord(kind, name, record, options), "t0", 9);

        case 9:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}
/**
 * Returns an action object used in signalling that Upload permissions have been received.
 *
 * @param {boolean} hasUploadPermissions Does the user have permission to upload files?
 *
 * @return {Object} Action object.
 */


function receiveUploadPermissions(hasUploadPermissions) {
  return {
    type: 'RECEIVE_USER_PERMISSION',
    key: 'create/media',
    isAllowed: hasUploadPermissions
  };
}
/**
 * Returns an action object used in signalling that the current user has
 * permission to perform an action on a REST resource.
 *
 * @param {string}  key       A key that represents the action and REST resource.
 * @param {boolean} isAllowed Whether or not the user can perform the action.
 *
 * @return {Object} Action object.
 */


function receiveUserPermission(key, isAllowed) {
  return {
    type: 'RECEIVE_USER_PERMISSION',
    key: key,
    isAllowed: isAllowed
  };
}
/**
 * Returns an action object used in signalling that the autosaves for a
 * post have been received.
 *
 * @param {number}       postId    The id of the post that is parent to the autosave.
 * @param {Array|Object} autosaves An array of autosaves or singular autosave object.
 *
 * @return {Object} Action object.
 */


function receiveAutosaves(postId, autosaves) {
  return {
    type: 'RECEIVE_AUTOSAVES',
    postId: postId,
    autosaves: (0, _lodash.castArray)(autosaves)
  };
}
//# sourceMappingURL=actions.js.map